<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéè ShinkaEvolve: Open-Ended Program Evolution üéè</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <!-- Remove Highlight.js CSS -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.min.css"> -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: #f8f9fa;
        }
        
        #container {
            display: flex;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #tree-panel {
            width: 50%;
            height: 100%;
            overflow: auto;
            min-width: 200px;
            max-width: 80%;
            padding: 15px 20px;
            background-color: #ffffff;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
        }
        
        #divider {
            width: 8px;
            background-color: #ddd;
            height: 100%;
            cursor: col-resize;
            position: relative;
            flex: 0 0 8px;
            transition: background-color 0.2s;
            z-index: 10;
        }

        #divider:hover, #divider.dragging {
            background-color: #3498db;
        }

        #divider::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background-color: #888;
            border-radius: 1px;
        }
        
        #details-panel {
            width: 50%;
            height: 100%;
            overflow: auto;
            flex: 1 1 auto;
            min-width: 200px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 2px;
        }
        
        .node.selected circle {
            fill: #f8c291;
            stroke: #e58e26;
            stroke-width: 3px;
        }
        
        .node text {
            font: 11px sans-serif;
            fill: #444;
            pointer-events: none;
        }
        
        .node:hover text {
            font-weight: bold;
            fill: #000;
        }
        
        .link {
            fill: none;
            stroke: #ddd;
            stroke-width: 1.5px;
        }
        
        .link.best-path {
            stroke: #ff8c00;
            stroke-width: 3px;
            stroke-opacity: 1;
        }
        
        #tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 5px;
            background-color: #f1f1f1;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
        }
        
        .tab.active {
            background-color: #fff;
            border-color: #ddd;
            border-bottom-color: #fff;
            margin-bottom: -1px;
            padding-bottom: 11px;
            font-weight: bold;
        }

        /* Meta sub-tab styles */
        .meta-sub-tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .meta-sub-tab:hover {
            background-color: #e9ecef;
        }

        .meta-sub-tab.active {
            border-bottom: 2px solid #007bff;
            background-color: #f8f9fa;
            color: #007bff;
        }
        
        #tab-content {
            flex-grow: 1;
            background-color: #fff;
            padding: 15px;
            border: 1px solid #ddd;
            border-top: none;
            overflow: auto;
        }
        
        .content-section {
            display: none;
            background-color: #f8f9fa;
            padding: 20px;
        }
        
        .content-section.active {
            display: block;
        }
        
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow: auto;
        }
        
        code {
            font-family: 'Consolas', 'Monaco', 'Andale Mono', monospace;
        }
        
        /* Add styles for code highlighting and smaller font size */
        pre code.hljs {
            font-size: 10px;
            line-height: 1.3;
        }
        
        .content-section {
            font-size: 14px;
        }
        
        /* Style for disabled generation slider */
        #generation-slider:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #generation-slider:disabled + #generation-value {
            opacity: 0.5;
        }
        
        .content-section h3 {
            font-size: 18px;
        }
        
        /* Highlight Python code tabs */
        #agent-code, #solution-code {
            background-color: #f8f8f8;
            border-radius: 4px;
            padding-bottom: 5px;
        }
        
        /* Make sure code blocks in Python tabs have good contrast */
        #agent-code pre, #solution-code pre {
            background-color: #ffffff;
            border: 1px solid #eaeaea;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        /* Custom code colors for Python */
        .hljs-keyword {
            color: #0000ff;
            font-weight: bold;
        }
        
        .hljs-string {
            color: #a31515;
        }
        
        .hljs-built_in, .hljs-function {
            color: #795e26;
        }
        
        .hljs-comment {
            color: #008000;
        }
        
        .hljs-number {
            color: #098658;
        }
        
        .file-selector {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            min-width: 120px;
        }
        
        #task-select, #result-select {
            flex: 1;
            max-width: 200px;
            min-width: 150px;
        }
        
        #refresh-files {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        #refresh-files:hover {
            background: #e9ecef;
        }
        
        #reload-data {
            background: #ebf5ff;
            border: 1px solid #b3d7ff;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 5px;
        }
        
        #reload-data:hover {
            background: #d4eaff;
        }
        
        #reload-data.loading {
            background: #d4eaff;
            pointer-events: none;
            opacity: 0.7;
            animation: spin 1s linear infinite;
        }

        #auto-refresh-toggle {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 5px;
        }

        #auto-refresh-toggle:hover {
            background: #fff1b8;
        }

        #auto-refresh-toggle.active {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        #auto-refresh-toggle.active:hover {
            background: #c1e5c5;
        }


        #download-programs-btn {
            background: #6f42c1;
            border: 1px solid #5a2d91;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
            color: white;
            margin-left: 5px;
        }

        #download-programs-btn:hover {
            background: #5a2d91;
        }
        

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .node-info {
            font-size: 12px;
            color: #666;
            margin-left: 5px;
        }
        
        .metric-good {
            color: #2ecc71;
            font-weight: bold;
        }
        
        .metric-bad {
            color: #e74c3c;
            font-weight: bold;
        }
        
        #node-summary {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f1f8ff;
            border-left: 4px solid #2196f3;
            border-radius: 3px;
            font-size: 14px;
        }
        
        /* Add a visual indicator for resize handles */
        #tree-panel:hover {
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.2);
        }
        
        /* Add custom resize handler to make it more visible */
        #tree-panel::after {
            content: "";
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            background-color: #ddd;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        #tree-panel:hover::after {
            opacity: 0.8;
        }
        
        /* Format the title nicely */
        .panel-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
            text-align: center;
        }
        
        .panel-title .highlight {
            color: #3498db;
            font-weight: 700;
        }
        
        #tree {
            margin-top: 10px;
        }
        
        #file-list-container {
            margin-bottom: 5px;
        }
        
        #scan-status {
            font-size: 12px;
            color: #666;
            margin-left: 5px;
            margin-bottom: 5px;
        }
        
        .node.best-node circle {
            fill: #ffd700;
            stroke: #ff8c00;
            stroke-width: 3px;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.7));
        }
        
        .node.best-node text {
            font-weight: bold;
            fill: #ff8c00;
        }
        
        .best-node-indicator {
            font-size: 12px;
            font-weight: bold;
            fill: #ff8c00;
            text-anchor: middle;
            opacity: 0.9;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .node.best-node circle.pulse {
            animation: pulse 2s infinite;
            transform-origin: center;
            transform-box: fill-box;
        }
        
        .solution-container, .thought-container {
            margin-bottom: 25px; 
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .solution-container:nth-child(odd), .thought-container:nth-child(odd) {
            background-color: #fafafa;
        }
        
        .solution-container:nth-child(even), .thought-container:nth-child(even) {
            background-color: #fff;
        }
        
        .container-header {
            background-color: #f0f4f8;
            padding: 8px 12px;
            margin: -15px -15px 15px -15px;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .container-title {
            color: #2c3e50; 
            margin: 0;
            font-size: 16px;
        }
        
        .cost-badge {
            font-size: 14px; 
            color: #7f8c8d;
            background-color: #e9f5f9;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #d0e3eb;
        }
        
        .solutions-wrapper, .thoughts-wrapper {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .thought-content {
            line-height: 1.6;
        }
        
        pre code.hljs {
            padding: 12px;
            border-radius: 4px;
        }

        .conn-line {
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .node.selected .conn-line {
            stroke: #e58e26;
            stroke-width: 3px;
            stroke-opacity: 1;
        }
        
        .node:hover circle {
            filter: brightness(1.2);
        }
        
        /* Style for connected nodes */
        .node.connected circle {
            stroke-width: 2.5px;
            filter: drop-shadow(0 0 2px rgba(123, 154, 196, 0.5));
        }
        
        /* Add arrow markers */
        .arrow {
            fill: #7b9ac4;
        }
        
        /* Make node text more compact */
        .node text {
            font-size: 10px;
            text-anchor: middle;
            transform: translate(0, -10px);
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Add truncation for node labels */
        .node-label {
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #selected-node-details {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }

        #selected-node-details h4 {
            margin-top: 0;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 8px;
            margin-bottom: 12px;
        }
        
        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .details-section {
            min-height: 200px;
            display: flex;
            flex-direction: column;
            padding: 10px;
            background-color: #fff;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .details-section-content {
            flex-grow: 1;
        }
        
        .details-section p {
            font-size: 13px;
            margin: 0 0 5px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
        }

        .details-section p strong {
            color: #343a40;
            min-width: 100px;
            display: inline-block;
            vertical-align: top;
        }

        /* Handle long values that might overflow */
        .details-section p:not(:has(strong)) {
            word-break: break-all;
        }

        /* Specific handling for metadata values */
        .metadata-value {
            word-break: break-word;
            white-space: pre-wrap;
            max-width: 100%;
            display: inline-block;
        }

        /* Expandable metadata content styling - matching LLM result style */
        .metadata-details > summary {
            cursor: pointer;
            list-style: none; /* Hide default arrow */
            padding: 4px 0;
            font-weight: 500;
            color: #0366d6;
        }
        .metadata-details > summary::-webkit-details-marker {
            display: none;
        }
        .metadata-summary::before {
            content: '‚ñ∂';
            display: inline-block;
            font-size: 0.8em;
            margin-right: 8px;
            transition: transform 0.2s;
            transform-origin: center;
        }
        .metadata-details[open] > .metadata-summary::before {
            transform: rotate(90deg);
        }
        .metadata-value-expandable {
            padding-top: 10px;
        }
        .metadata-value-expandable pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f6f8fa;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .diff {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 12px;
            background-color: #f6f8fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 10px;
            white-space: pre-wrap;
        }
        .diff-line {
            display: block;
        }
        .diff-line.added {
            background-color: #e6ffed;
        }
        .diff-line.removed {
            background-color: #ffeef0;
        }

        #left-tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-top: 10px;
            flex-shrink: 0;
        }

        .left-tab {
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 4px;
            background-color: #f1f1f1;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            font-size: 14px;
        }

        .left-tab.active {
            background-color: #fff;
            border-color: #ddd;
            border-bottom-color: #fff;
            margin-bottom: -1px;
            font-weight: bold;
        }

        #program-table-container {
            height: calc(100vh - 250px);
            overflow-y: auto;
            padding-bottom: 20px;
            position: relative;
        }

        #program-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            position: relative;
        }

        #program-table th, #program-table td {
            border: 1px solid #ddd;
            padding: 6px 8px;
            text-align: left;
            white-space: nowrap;
        }

        #program-table th {
            background-color: #f8f9fa !important;
            position: sticky !important;
            top: 0 !important;
            z-index: 10 !important;
            border-bottom: 2px solid #dee2e6;
        }

        #program-table tr:hover {
            background-color: #f1f8ff;
            cursor: pointer;
        }

        #program-table tr.selected {
            background-color: #d4eaff !important;
        }

        #program-table th.sortable {
            cursor: pointer;
        }

        #program-table th.sortable:hover {
            background-color: #e9ecef;
        }

        .sort-arrow {
            display: inline-block;
            width: 1em;
            text-align: left;
            margin-left: 2px;
        }

        /* Meta analysis content styling */
        .meta-content-body h1,
        .meta-content-body h2,
        .meta-content-body h3,
        .meta-content-body h4,
        .meta-content-body h5,
        .meta-content-body h6 {
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .meta-content-body h1 { font-size: 24px; }
        .meta-content-body h2 { font-size: 20px; }
        .meta-content-body h3 { font-size: 18px; }
        .meta-content-body h4 { font-size: 16px; }
        .meta-content-body h5 { font-size: 14px; }
        .meta-content-body h6 { font-size: 12px; }

        .meta-content-body {
            white-space: normal; /* Use normal whitespace handling */
        }

        /* Ensure diff content also preserves line breaks */
        .diff-added, .diff-removed {
            white-space: pre-line;
        }

        .meta-content-body p {
            margin: 10px 0;
            line-height: 1.6;
        }
        .meta-content-body ul,
        .meta-content-body ol {
            margin: 10px 0 10px 20px;
            padding-left: 20px;
        }
        .meta-content-body li {
            margin: 5px 0;
            line-height: 1.5;
        }

        .meta-content-body code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .meta-content-body pre {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            overflow-x: auto;
            margin: 15px 0;
        }

        .meta-content-body pre code {
            background: none;
            padding: 0;
        }

        .meta-content-body blockquote {
            border-left: 4px solid #ddd;
            margin: 15px 0;
            padding-left: 15px;
            color: #666;
            font-style: italic;
        }

        /* Diff highlighting styles */
        .diff-added {
            background-color: #d4edda;
            color: #155724;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .diff-removed {
            background-color: #f8d7da;
            color: #721c24;
            padding: 2px 4px;
            border-radius: 3px;
            text-decoration: line-through;
        }

        .diff-unchanged {
            /* Normal text styling - no special formatting needed */
            color: inherit;
        }

        .meta-diff-info {
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #0066cc;
        }

        .left-content-section {
            display: none;
        }

        .left-content-section.active {
            display: block;
            height: 100%;
        }

        .details-section h5 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 14px;
            color: #495057;
        }

        .truncated-text {
            display: -webkit-box;
            -webkit-line-clamp: 10;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: help;
            word-wrap: break-word;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 300px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            word-wrap: break-word;
        }

        .tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Pulse animation for best node */
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.1);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.8;
            }
        }
        
        /* Enhanced node styling for best and selected nodes */
        .node.best-node circle {
            stroke: #ff8c00 !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0px 3px 6px rgba(255, 140, 0, 0.5)) !important;
        }
        
        .node.selected circle:first-child {
            stroke: #e58e26 !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0px 3px 8px rgba(229, 130, 38, 0.6)) !important;
        }

        .node-tooltip {
            position: absolute;
            text-align: left;
            padding: 8px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            border-radius: 4px;
            pointer-events: none;
            line-height: 1.5;
            z-index: 1000;
            max-width: 280px;
            word-wrap: break-word;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            transition: opacity 0.2s ease-in-out;
        }

        .truncated-name-span {
            display: inline-block;
            vertical-align: bottom;
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .legend-shape {
            stroke: #000;
            stroke-width: 1.5px;
            fill: #ccc;
        }

        .llm-result-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            table-layout: fixed;
        }
        .llm-result-table th, .llm-result-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
            vertical-align: top;
            word-wrap: break-word;
        }
        .llm-result-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            width: 150px;
        }
        .llm-result-table td pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #fff;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
        }

        .llm-result-details > summary {
            cursor: pointer;
            list-style: none; /* Hide default arrow */
            padding: 4px 0;
            font-weight: 500;
            color: #0366d6;
        }
        .llm-result-details > summary::-webkit-details-marker {
            display: none;
        }
        .llm-result-summary::before {
            content: '‚ñ∂';
            display: inline-block;
            font-size: 0.8em;
            margin-right: 8px;
            transition: transform 0.2s;
            transform-origin: center;
        }
        .llm-result-details[open] > .llm-result-summary::before {
            transform: rotate(90deg);
        }
        .llm-result-value {
            padding-top: 10px;
        }

        .code-container {
            display: flex;
        }

        .line-numbers-gutter {
            font-family: 'Consolas', 'Monaco', 'Andale Mono', monospace;
            font-size: 10px; /* Match code font size */
            line-height: 1.3; /* Match code line-height */
            text-align: right;
            padding: 10px;
            color: rgba(0,0,0,0.3);
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            user-select: none;
        }

        .line-numbers-gutter span {
            display: block;
        }

        #agent-code-wrapper pre {
            margin: 0;
            flex: 1;
        }

        /* Styles for Best Path View */
        .best-path-timeline {
            position: relative;
            margin: 0 auto;
            padding: 20px 0;
            width: 90%;
        }
        .best-path-timeline::after {
            content: '';
            position: absolute;
            width: 4px;
            background-color: #e0e0e0;
            top: 0;
            bottom: 0;
            left: 20px;
        }
        .timeline-item {
            padding: 10px 40px;
            position: relative;
            background-color: inherit;
            width: 100%;
            box-sizing: border-box;
        }
        .timeline-item::before {
            content: ' ';
            height: 0;
            position: absolute;
            top: 22px;
            width: 0;
            z-index: 1;
            left: 50px;
        }
        .timeline-item::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            right: auto;
            background-color: white;
            border: 4px solid #ff8c00;
            top: 15px;
            border-radius: 50%;
            z-index: 1;
            left: 10px;
        }
        .timeline-content {
            padding: 15px;
            background-color: #f8f9fa;
            position: relative;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        .timeline-content h4 {
            margin-top: 0;
            color: #343a40;
        }
        .timeline-content p {
            margin: 5px 0 0 0;
            font-size: 14px;
            line-height: 1.5;
        }
        .timeline-item.selected .timeline-content {
            border-color: #e58e26;
            box-shadow: 0 0 8px rgba(229, 130, 38, 0.4);
        }


    </style>
</head>
<body>
    <div id="container">
        <div id="tree-panel" style="position: relative;">
            <h2 class="panel-title"><span class="highlight">üéè ShinkaEvolve</span>: Open-Ended Program Evolution üéè</h2>
            <div class="file-selector">
                <label for="task-select">Task:</label>
                <select id="task-select">
                    <option value="">Select a task...</option>
                </select>
                <label for="result-select" style="margin-left: 15px;">Result:</label>
                <select id="result-select">
                    <option value="">Select a result...</option>
                </select>
                <button id="refresh-files" title="Refresh available databases">üîÑ</button>
                <button id="reload-data" title="Reload current data">üìä</button>
                <button id="auto-refresh-toggle" title="Toggle auto-refresh (every 3 seconds)">‚è±Ô∏è</button>
                <span id="scan-status" style="margin-left: 10px; font-size: 12px; color: #666;"></span>
                <button id="download-programs-btn" title="Download top performing programs">üíæ</button>
            </div>
            <div id="file-list-container">
                <div id="file-list"></div>
            </div>
            <div id="left-tabs">
                <div class="left-tab active" data-tab="tree-view">Tree</div>
                <div class="left-tab" data-tab="table-view">Programs</div>
                <div class="left-tab" data-tab="metrics-view">Metrics</div>
                <div class="left-tab" 
                data-tab="embeddings-view">Embeddings</div>
                <div class="left-tab" data-tab="clusters-view">Clusters</div>
                <div class="left-tab"
                data-tab="islands-view">Islands</div>
                <div class="left-tab" data-tab="model-posteriors-view">LLM Posterior</div>
                <div class="left-tab" data-tab="best-path-view">Path ‚Üí Best</div>

            </div>
            <div id="left-tab-content" style="flex-grow: 1; overflow: hidden; position: relative; height: calc(100vh - 200px);">
                <div id="tree-view" class="left-content-section active">
                    <div id="tree" style="height: 100%;"></div>
                </div>
                <div id="table-view" class="left-content-section">
                    <div style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #f8f9fa;">
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                            <input type="checkbox" id="show-incorrect-programs" style="margin: 0;">
                            Show incorrect programs
                        </label>
                    </div>
                    <div id="program-table-container">
                        <table id="program-table">
                            <thead>
                                <tr>
                                    <th class="sortable" data-sort="rank">Rank<span class="sort-arrow"></span></th>
                                    <th class="sortable" data-sort="generation">Gen<span class="sort-arrow"></span></th>
                                    <th class="sortable" data-sort="archive">Archive<span class="sort-arrow"></span></th>
                                    <th>Patch Name</th>
                                    <th>Type</th>
                                    <th class="sortable" data-sort="island_idx">Island<span class="sort-arrow"></span></th>
                                    <th>Score</th>
                                    <th class="sortable" data-sort="api_cost">API Cost<span class="sort-arrow"></span></th>
                                    <th class="sortable" data-sort="complexity">Complexity<span class="sort-arrow"></span></th>
                                    <th>Model</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
                <div id="embeddings-view" class="left-content-section">
                    <div id="embeddings-container" style="width: 100%; height: 100%; overflow: auto;">
                        <div id="embeddings-controls" style="padding: 10px; background-color: #f8f9fa; border-bottom: 1px solid #ddd;">
                            <h4 style="margin: 0 0 10px 0;">Embedding Similarity Matrix</h4>
                            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                                <label>
                                    Sort by:
                                    <select id="embedding-sort-method">
                                        <option value="chronological" selected>Chronological</option>
                                        <option value="cluster">Hierarchical Clustering</option>
                                        <option value="performance">Performance</option>
                                    </select>
                                </label>
                                <label>
                                    Color Scale: 
                                    <select id="color-scale">
                                        <option value="viridis">Viridis</option>
                                        <option value="plasma">Plasma</option>
                                        <option value="inferno">Inferno</option>
                                        <option value="magma" selected>Magma</option>
                                    </select>
                                </label>
                                <label>
                                    Cell Size: 
                                    <input type="range" id="cell-size" min="3" max="15" value="8" step="1">
                                    <span id="cell-size-value">8px</span>
                                </label>
                            </div>
                            <div style="display: flex; gap: 15px; align-items: center; margin-top: 10px;">
                                <label>
                                    Min Value: 
                                    <input type="number" id="heat-min" min="0" max="1" step="0.01" value="0.5" style="width: 70px;">
                                </label>
                                <label>
                                    Max Value: 
                                    <input type="number" id="heat-max" min="0" max="1" step="0.01" value="1" style="width: 70px;">
                                </label>
                            </div>
                        </div>
                        <div id="embeddings-heatmap" style="padding: 20px;"></div>
                    </div>
                </div>
                <div id="islands-view" class="left-content-section">
                    <div style="padding: 10px; border-bottom: 1px solid #dee2e6; background-color: #f8f9fa;">
                        <div style="display: flex; align-items: center; gap: 15px; font-size: 14px;">
                            <span style="font-weight: 500;">Y-Axis Range:</span>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <label for="island-y-min">Min:</label>
                                <input type="number" id="island-y-min" style="width: 70px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;" placeholder="Auto" step="0.1">
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <label for="island-y-max">Max:</label>
                                <input type="number" id="island-y-max" style="width: 70px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;" placeholder="Auto" step="0.1">
                            </div>
                        </div>
                    </div>
                    <div id="islands-container" style="width: 100%; height: calc(100% - 60px); position: relative;">
                    </div>
                </div>
                <div id="best-path-view" class="left-content-section">
                    <div id="best-path-container" style="width: 100%; height: 100%; overflow-y: auto; padding: 20px; box-sizing: border-box;">
                    </div>
                </div>

                <div id="model-posteriors-view" class="left-content-section">
                    <div id="model-posteriors-container" style="width: 100%; height: 100%; overflow-y: auto; padding: 20px; box-sizing: border-box;">
                        <h4 style="margin: 0 0 20px 0; text-align: center;">Model Posteriors Over Generations</h4>
                        <div id="model-posteriors-chart" style="width: 100%; height: 400px; overflow-x: auto;"></div>
                        <div id="model-posteriors-summary" style="margin-top: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">
                            <h5 style="margin: 0 0 10px 0;">Summary Statistics</h5>
                            <div id="model-posteriors-stats"></div>
                        </div>
                    </div>
                </div>

                <div id="clusters-view" class="left-content-section">
                    <div id="clusters-container" style="width: 100%; height: 100%; display: flex; flex-direction: column;">
                        <h4 style="margin: 10px 10px 0 10px; flex-shrink: 0; text-align: center;">PCA Embeddings</h4>
                        <div id="cluster-plots-wrapper" style="display: flex; flex-grow: 1; flex-direction: row; align-items: stretch;">
                            <div id="cluster-plot-2d" style="width: 50%; height: 100%;"></div>
                            <div style="position: relative; width: 50%; height: 100%;">
                                <div id="cluster-plot-3d" style="width: 100%; height: 100%;"></div>
                                <div id="size-legend-container" style="position: absolute; top: 50px; left: 20px; z-index: 10; background-color: rgba(248, 249, 250, 0.85); padding: 5px; border-radius: 5px; pointer-events: none;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="metrics-view" class="left-content-section">
                    <div id="metrics-container" style="width: 100%; height: 100%; overflow-y: auto; padding: 20px; box-sizing: border-box;">
                        <h4 style="margin: 0 0 20px 0; text-align: center;">Metrics Over Generations</h4>
                        <div id="metrics-plots" style="display: flex; flex-direction: column; gap: 20px;"></div>
                    </div>
                </div>
            </div>
            <div id="tree-legend" style="position: absolute; top: 175px; right: 20px; padding: 2px; border: 2px solid #ccc; border-radius: 5px; background-color: rgba(248, 249, 250, 0.9); font-size: 12px; display: none; box-shadow: 0 2px 6px rgba(0,0,0,0.15); z-index: 10;">
                <div style="display: flex; gap: 16px; align-items: flex-start;">
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <h5 style="margin: 0 0 4px 0; font-size: 13px;">Nodes</h5>
                        <div style="display: flex; align-items: center;">
                            <svg width="16" height="16" style="margin-right: 5px;">
                                <circle cx="8" cy="8" r="6" fill="#ffd700" stroke="#ff8c00" stroke-width="3"></circle>
                            </svg>
                            <span>Best</span>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <svg width="16" height="16" style="margin-right: 5px;">
                                <circle cx="8" cy="8" r="6" fill="#e74c3c" stroke="#c0392b" stroke-width="2"></circle>
                            </svg>
                            <span>Error</span>
                        </div>
                    </div>
                    <div id="shape-legend" style="display: flex; flex-direction: column; gap: 8px;">
                        <h5 style="margin: 0 0 4px 0; font-size: 13px;">Patches</h5>
                    </div>
                    <div>
                        <h5 style="margin: 0 0 4px 0; font-size: 13px;">Performance</h5>
                        <div id="score-heatbar" style="width: 100px; height: 15px; position: relative; border-radius: 3px; overflow: hidden;"></div>
                        <div style="display: flex; justify-content: space-between; font-size: 10px; margin-top: 2px;">
                            <span id="min-score">Min</span>
                            <span id="max-score">Max</span>
                        </div>
                        <div id="islands-legend" style="margin-top: 10px;">
                            <h5 style="margin: 0 0 4px 0; font-size: 13px;">Islands</h5>
                            <div id="islands-legend-items" style="display: flex; flex-direction: column; gap: 4px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="divider"></div>
        <div id="details-panel">
            <div id="node-summary"></div>
            <div id="tabs">
                <div class="tab active" data-tab="agent-info">Meta</div>
                <div class="tab" data-tab="pareto-front">Pareto Front</div>
                <div class="tab" data-tab="meta-analysis">Scratchpad</div>
                <div class="tab" data-tab="node-details">Node</div>
                <div class="tab" data-tab="agent-code">Code</div>
                <div class="tab" data-tab="code-diff">Diff</div>
                <div class="tab" data-tab="log-output">Evaluation</div>
                <div class="tab" data-tab="llm-result">LLM Result</div>
            </div>
            <div id="tab-content">
                <div id="agent-info" class="content-section active">
                    <p>Select a node from the tree to view agent information.</p>
                    </div>
                <div id="pareto-front" class="content-section">
                    <div id="pareto-controls" style="display: flex; gap: 20px; margin-bottom: 20px; align-items: center; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="pareto-y-axis">Y-Axis:</label>
                            <select id="pareto-y-axis" class="pareto-axis-select"></select>
                            <select id="pareto-y-objective" class="pareto-objective-select">
                                <option value="max">Higher is better</option>
                                <option value="min">Lower is better</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="pareto-x-axis">X-Axis:</label>
                            <select id="pareto-x-axis" class="pareto-axis-select"></select>
                            <select id="pareto-x-objective" class="pareto-objective-select">
                                <option value="max">Higher is better</option>
                                <option value="min">Lower is better</option>
                            </select>
                        </div>
                    </div>
                    <div id="pareto-plot" style="width: 100%; height: 500px;"></div>
                </div>
                <div id="meta-analysis" class="content-section">
                    <div id="meta-controls" style="display: flex; gap: 20px; margin-bottom: 20px; align-items: center; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="generation-slider">Generation:</label>
                            <input type="range" id="generation-slider" min="5" max="25" step="1" value="5" style="width: 200px;" disabled>
                            <span id="generation-value">5</span>
                        </div>

                        <button id="refresh-meta-btn" title="Refresh meta files">üîÑ Refresh</button>
                        <button id="download-pdf-btn" title="Download as PDF file">üìÑ Download PDF</button>
                    </div>
                    
                    <!-- Sub-tabs for different sections -->
                    <div id="meta-sub-tabs" style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #e0e0e0;">
                        <div class="meta-sub-tab active" data-section="individual-programs" style="padding: 8px 16px; cursor: pointer; border-bottom: 2px solid #007bff; background-color: #f8f9fa;">Individual Programs</div>
                        <div class="meta-sub-tab" data-section="global-insights" style="padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent;">Global Insights</div>
                        <div class="meta-sub-tab" data-section="meta-recommendations" style="padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent;">Meta Recommendations</div>
                    </div>
                    
                    <div id="meta-content" style="background-color: #fff; border: 1px solid #ddd; border-radius: 4px; padding: 20px; max-height: calc(100vh - 300px); overflow-y: auto;">
                        <p style="text-align: center; color: #666; margin-top: 50px;">Select a database to view meta analysis.</p>
                    </div>
                </div>
                <div id="node-details" class="content-section">
                    <p>Select a node to view its details.</p>
                </div>
                <div id="agent-code" class="content-section" style="position: relative;">
                    <div class="code-controls">
                        <button id="copy-code-btn" title="Copy code to clipboard">üìã Copy</button>
                        <button id="download-code-btn" title="Download code as file">üíæ Download</button>
                    </div>
                    <div id="agent-code-wrapper">
                        <p>Select a node from the tree to view code.</p>
                    </div>
                </div>
                <div id="code-diff" class="content-section">
                    <p>Select a node to view its code diff.</p>
                </div>
                <div id="log-output" class="content-section">
                    <p>Select a node to view its logs.</p>
                </div>
                <div id="llm-result" class="content-section">
                    <p>Select a node to view the LLM result.</p>
                </div>
            </div>
                </div>
            </div>
            
    <!-- Place all external script tags here, before the main inline script -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/diff@5.1.0/dist/diff.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Add our script after all external dependencies -->
    <script>
        // Basic error handling
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Error: ' + msg + '\nURL: ' + url + '\nLine: ' + lineNo + '\nColumn: ' + columnNo + '\nError object: ' + JSON.stringify(error));
            return false;
        };

        console.log("Script starting...");

        try {
            // ALWAYS use DOMContentLoaded to ensure the full initial DOM is ready
            console.log("Adding DOMContentLoaded listener...");
            document.addEventListener('DOMContentLoaded', initialize);
        } catch (error) {
            console.error("Error in initial script setup:", error);
        }

        // Data store for available databases and organized data
        let availableDatabases = [];
        let tasksAndResults = {}; // Structure: { taskName: [{ name: "result_timestamp", path: "full/path" }] }
        let sortState = { key: 'rank', dir: 'asc' };
        
        // Auto-refresh variables
        let autoRefreshInterval = null;
        let autoRefreshEnabled = false;
        let lastDataTimestamp = null;

        function initialize() {
            console.log("[DEBUG] Page loaded, starting initialization");
            try {
                // Add custom styles
                addStylesToDom();
                window.pendingNodeSelectionId = null;
                
                // Add arrow marker definition for connection lines
                d3.select("svg").append("defs").append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 4)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("class", "arrow")
                    .attr("d", "M0,-5L10,0L0,5");
                
                // Restore user preferences from localStorage
                restorePreferences();
                
                // Initialize database list
                findDatabases();
                
                // Add task and result selection handlers
                const taskSelect = document.getElementById('task-select');
                const resultSelect = document.getElementById('result-select');
                
                taskSelect.addEventListener('change', function() {
                    // Stop current auto-refresh before changing tasks
                    stopAutoRefresh();
                    
                    populateResultSelect(this.value);
                    
                    // Auto-select the first result if available
                    if (this.value && tasksAndResults[this.value] && tasksAndResults[this.value].length > 0) {
                        const firstResult = tasksAndResults[this.value][0].path;
                        resultSelect.value = firstResult;
                        loadDatabase(firstResult);
                        updateURL();
                    } else {
                        // Clear result selection if no results available
                        resultSelect.value = '';
                    }
                });
                
                resultSelect.addEventListener('change', function() {
                    if (this.value) {
                        // Stop current auto-refresh before loading new database
                        stopAutoRefresh();
                        loadDatabase(this.value);
                        updateURL();
                    }
                });
                
                // Add refresh button handler
                const refreshButton = document.getElementById('refresh-files');
                refreshButton.addEventListener('click', function() {
                    console.log("[DEBUG] Refresh button clicked");
                    findDatabases(true); // Force refresh of DB list
                });
                
                // Initialize the reload data button handler
                const reloadButton = document.getElementById('reload-data');
                reloadButton.addEventListener('click', function() {
                    console.log("[DEBUG] Reload data button clicked");
                    if (window.currentDbPath) {
                        window.isReloadingData = true; // Prevent state saving during reload
                        console.log("[DEBUG] Reloading data from:", window.currentDbPath);
                        // Show loading state
                        reloadButton.classList.add('loading');
                        const scanStatus = document.getElementById("scan-status");
                        scanStatus.textContent = "Reloading data...";
                        
                        // Reload the current data file
                        loadDatabase(window.currentDbPath);
                        
                        // Remove loading state after a short delay
                        setTimeout(() => {
                            reloadButton.classList.remove('loading');
                        }, 1000);
                    } else {
                        console.log("[DEBUG] No file currently loaded to reload");
                        alert("Please select a database file first");
                    }
                });

                // Initialize auto-refresh functionality
                initializeAutoRefresh();

                // Add auto-refresh toggle button handler
                const autoRefreshToggle = document.getElementById('auto-refresh-toggle');
                autoRefreshToggle.addEventListener('click', function() {
                    if (autoRefreshEnabled) {
                        stopAutoRefresh();
                        autoRefreshToggle.classList.remove('active');
                        autoRefreshToggle.title = "Enable auto-refresh (every 3 seconds)";
                        console.log("[DEBUG] Auto-refresh disabled by user");
                    } else {
                        if (window.currentDbPath) {
                            startAutoRefresh();
                            autoRefreshToggle.classList.add('active');
                            autoRefreshToggle.title = "Disable auto-refresh";
                            console.log("[DEBUG] Auto-refresh enabled by user");
                        } else {
                            alert("Please select a database file first");
                        }
                    }
                });
                
                // Initialize copy and download button handlers
                const copyBtn = document.getElementById('copy-code-btn');
                if (copyBtn) {
                    copyBtn.addEventListener('click', () => {
                        const codeElement = document.querySelector('#agent-code-wrapper pre code');
                        if (codeElement) {
                            navigator.clipboard.writeText(codeElement.innerText).then(() => {
                                copyBtn.innerHTML = '‚úÖ Copied!';
                                setTimeout(() => { copyBtn.innerHTML = 'üìã Copy'; }, 2000);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                                alert('Failed to copy code.');
                            });
                        }
                    });
                }

                const downloadBtn = document.getElementById('download-code-btn');
                if (downloadBtn) {
                    downloadBtn.addEventListener('click', () => {
                        const codeElement = document.querySelector('#agent-code-wrapper pre code');
                        const selectedNodeId = getSelectedNodeId();
                        
                        if (codeElement && window.treeData && selectedNodeId) {
                            const nodeData = window.treeData.find(d => d.id === selectedNodeId);
                            if (nodeData) {
                                try {
                                    const code = codeElement.innerText;
                                    const blob = new Blob([code], { type: 'text/plain;charset=utf-8' });
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    const agentName = (nodeData.metadata.patch_name || 'agent').replace(/\s+/g, '_');
                                    const gen = nodeData.generation;
                                    const language = nodeData.language || 'py';
                                    const extension = {
                                        'python': 'py',
                                        'cpp': 'cpp',
                                        'javascript': 'js',
                                        'cuda': 'cu'
                                    }[language] || language;

                                    a.download = `${agentName}_gen${gen}.${extension}`;
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    URL.revokeObjectURL(url);
                                } catch (e) {
                                    console.error('Download failed:', e);
                                    alert('Failed to download code.');
                                }
                            }
                        } else {
                            alert('Could not get code or node data to download.');
                        }
                    });
                }

                // Initialize the score type radio buttons
                initializeScoreTypeListeners();
                
                // Add tab handling with state persistence
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        this.classList.add('active');
                        
                        const tabId = this.getAttribute('data-tab');
                        document.querySelectorAll('.content-section').forEach(section => {
                            section.classList.remove('active');
                        });
                        document.getElementById(tabId).classList.add('active');
                        
                        // Save state and update URL
                        saveState();
                        
                        // Redraw charts if we're switching to the agent-info tab
                        if (tabId === 'agent-info' && !window.isResizing) {
                            console.log("[DEBUG] Switching to Meta Info tab, redrawing charts");
                            // Small delay to ensure the tab is visible before redrawing charts
                            setTimeout(() => {
                                createCharts(null);
                            }, 100);
                        }
                        if (tabId === 'pareto-front') {
                            updateParetoView();
                        }
                    });
                });
                
                // Initialize panel resizing functionality
                initializeResizer();
                setupTableSorting();
                
                // Add left panel tab handling with state persistence
                document.querySelectorAll('.left-tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        document.querySelectorAll('.left-tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.left-content-section').forEach(s => s.classList.remove('active'));
                        
                        this.classList.add('active');
                        const tabId = this.getAttribute('data-tab');
                        document.getElementById(tabId).classList.add('active');
                        
                        // Save state and update URL
                        saveState();
                        
                        const legend = document.getElementById('tree-legend');
                        if (tabId === 'tree-view') {
                            if (window.treeData) {
                                legend.style.display = 'block';
                                renderGraph(window.treeData);
                            }
                        } else {
                            legend.style.display = 'none';
                        }
                        
                        // Initialize embeddings view when tab is clicked
                        if (tabId === 'embeddings-view') {
                            // Use the helper function to ensure heatmap is created
                            setTimeout(() => {
                                ensureEmbeddingsHeatmap();
                            }, 100);
                        } else if (tabId === 'islands-view') {
                            setTimeout(() => {
                                if (window.treeData) {
                                    createIslandsVisualization(window.treeData);
                                }
                            }, 100);
                        } else if (tabId === 'best-path-view') {
                            setTimeout(() => {
                                if (window.treeData) {
                                    createBestPathVisualization(window.treeData);
                                }
                            }, 100);
                        } else if (tabId === 'model-posteriors-view') {
                            setTimeout(() => {
                                if (window.treeData) {
                                    createModelPosteriorsVisualization(window.treeData);
                                }
                            }, 100);
                        } else if (tabId === 'clusters-view') {
                            setTimeout(() => {
                                if (window.treeData) {
                                    createClusterPlots(window.treeData);
                                }
                            }, 100);
                        } else if (tabId === 'metrics-view') {
                            setTimeout(() => {
                                if (window.treeData) {
                                    // Force clear the metrics container before recreating
                                    const metricsContainer = document.getElementById('metrics-plots');
                                    if (metricsContainer) {
                                        metricsContainer.innerHTML = '';
                                    }
                                    createMetricsVisualization(window.treeData);
                                }
                            }, 100);
                        }
                    });
                });

                // Add embedding controls event handlers with state persistence
                const initializeEmbeddingControls = () => {
                    const sortMethodSelect = document.getElementById('embedding-sort-method');
                    const colorScale = document.getElementById('color-scale');
                    const cellSize = document.getElementById('cell-size');
                    const cellSizeValue = document.getElementById('cell-size-value');
                    const heatMin = document.getElementById('heat-min');
                    const heatMax = document.getElementById('heat-max');
                    
                    if (sortMethodSelect) {
                        sortMethodSelect.addEventListener('change', () => {
                            savePreferences();
                            if (window.treeData) createEmbeddingsHeatmap(window.treeData);
                        });
                    }
                    
                    if (colorScale) {
                        colorScale.addEventListener('change', () => {
                            savePreferences();
                            if (window.treeData) createEmbeddingsHeatmap(window.treeData);
                        });
                    }
                    
                    if (cellSize && cellSizeValue) {
                        cellSize.addEventListener('input', () => {
                            cellSizeValue.textContent = cellSize.value + 'px';
                            savePreferences();
                            if (window.treeData) createEmbeddingsHeatmap(window.treeData);
                        });
                    }
                    
                    if (heatMin) {
                        heatMin.addEventListener('input', () => {
                            savePreferences();
                            if (window.treeData) createEmbeddingsHeatmap(window.treeData);
                        });
                    }
                    
                    if (heatMax) {
                        heatMax.addEventListener('input', () => {
                            savePreferences();
                            if (window.treeData) createEmbeddingsHeatmap(window.treeData);
                        });
                    }
                };
                
                // Initialize embedding controls after DOM is ready
                initializeEmbeddingControls();
                
                // Initialize table controls
                const showIncorrectCheckbox = document.getElementById('show-incorrect-programs');
                if (showIncorrectCheckbox) {
                    showIncorrectCheckbox.addEventListener('change', function() {
                        if (window.treeData) {
                            populateProgramsTable(window.treeData);
                        }
                    });
                }
                
                // Initialize meta analysis controls
                initializeMetaAnalysis();

                // Restore state from URL after everything is initialized
                restoreFromURL();
                
                // Add cleanup on page unload
                window.addEventListener('beforeunload', function() {
                    stopAutoRefresh();
                });
                
                console.log("[DEBUG] Initialization complete");
            } catch (error) {
                console.error("[DEBUG] Fatal error during initialization:", error);
            }
        }
        
        // Function to initialize meta analysis controls
        function initializeMetaAnalysis() {
            const generationSlider = document.getElementById('generation-slider');
            const generationValue = document.getElementById('generation-value');
            const refreshMetaBtn = document.getElementById('refresh-meta-btn');
            // Store available meta files for current database
            window.availableMetaFiles = [];
            window.metaContentCache = {};
            
            if (generationSlider && generationValue) {
                generationSlider.addEventListener('input', function() {
                    let selectedGen = parseInt(this.value);
                    
                    // Get available generations
                    const availableGensStr = this.getAttribute('data-available-generations');
                    if (availableGensStr) {
                        const availableGens = JSON.parse(availableGensStr);
                        
                        // Find the closest available generation
                        const closest = availableGens.reduce((prev, curr) => {
                            return Math.abs(curr - selectedGen) < Math.abs(prev - selectedGen) ? curr : prev;
                        });
                        
                        selectedGen = closest;
                        this.value = selectedGen; // Update slider to show correct value
                    }
                    
                    generationValue.textContent = selectedGen;
                    loadMetaContent(selectedGen);
                });
            }

            
            if (refreshMetaBtn) {
                refreshMetaBtn.addEventListener('click', function() {
                    if (window.currentDbPath) {
                        loadAvailableMetaFiles(window.currentDbPath);
                    }
                });
            }
            
            const downloadPdfBtn = document.getElementById('download-pdf-btn');
            if (downloadPdfBtn) {
                downloadPdfBtn.addEventListener('click', function() {
                    downloadMetaAsPDF();
                });
            }

            // Initialize meta sub-tab functionality
            const metaSubTabs = document.querySelectorAll('.meta-sub-tab');
            metaSubTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all sub-tabs and reset border
                    metaSubTabs.forEach(t => {
                        t.classList.remove('active');
                        t.style.borderBottom = '2px solid transparent';
                        t.style.backgroundColor = '';
                    });
                    
                    // Add active class to clicked tab and set active border
                    this.classList.add('active');
                    this.style.borderBottom = '2px solid #007bff';
                    this.style.backgroundColor = '#f8f9fa';
                    
                    // Show the corresponding section
                    showMetaSection(this.getAttribute('data-section'));
                });
            });
        }

        
        // Function to download meta content as PDF using backend conversion
        function downloadMetaAsPDF() {
            if (!window.currentDbPath) {
                alert('Please select a database first.');
                return;
            }
            
            // Get the current generation
            const currentGen = document.getElementById('generation-value').textContent;
            
            console.log('[DEBUG] Starting PDF download process...');
            
            // Use the downloadMetaPdf function which calls the backend endpoint
            downloadMetaPdf(window.currentDbPath, currentGen);
        }
        
        // Function to download text content as a formatted text file
        function generateSimplePDFFromText(rawText, filename, dbName, generation, downloadBtn, originalText) {
            try {
                console.log('[DEBUG] Creating downloadable text file from content');
                console.log('[DEBUG] Raw text length:', rawText.length);
                console.log('[DEBUG] First 200 chars:', rawText.substring(0, 200));
                
                // Add header to the content
                const header = `Meta Analysis - Generation ${generation}
Database: ${dbName}
${'='.repeat(80)}
`;
                
                // Combine header and content
                const fullContent = header + rawText;
                
                // Create a blob with the text content
                const blob = new Blob([fullContent], { type: 'text/plain;charset=utf-8' });
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename.replace('.pdf', '.txt'); // Change extension to .txt
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up URL
                window.URL.revokeObjectURL(url);
                
                // Reset button state
                downloadBtn.textContent = originalText;
                downloadBtn.disabled = false;
                console.log('[DEBUG] Text file download triggered successfully');
                    
            } catch (error) {
                console.error('Text file generation failed:', error);
                alert('Failed to generate text file. Please try again.');
                downloadBtn.textContent = originalText;
                downloadBtn.disabled = false;
            }
        }

        
        // Function to load available meta files for a database
        function loadAvailableMetaFiles(dbPath) {
            console.log("[DEBUG] Loading available meta files for:", dbPath);
            
            // Clear the cache when loading a new database
            window.metaContentCache = {};
            
            // Make request to server to get list of meta files
            const xhr = new XMLHttpRequest();
            xhr.open('GET', `/get_meta_files?db_path=${encodeURIComponent(dbPath)}`, true);
            
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        try {
                            const metaFiles = JSON.parse(xhr.responseText);
                            window.availableMetaFiles = metaFiles;
                            console.log("[DEBUG] Found meta files:", metaFiles);
                            
                            // Update slider range based on available files
                            updateMetaSlider(metaFiles);
                            
                            // Load the highest generation meta file by default
                            if (metaFiles.length > 0) {
                                const highestGen = metaFiles[metaFiles.length - 1].generation;
                                const slider = document.getElementById('generation-slider');
                                if (slider) {
                                    slider.value = highestGen;
                                    document.getElementById('generation-value').textContent = highestGen;
                                    loadMetaContent(highestGen);
                                }
                            }
                        } catch (e) {
                            console.error("[ERROR] Failed to parse meta files response:", e);
                            showMetaError("Failed to load meta files list.");
                        }
                    } else if (xhr.status === 404) {
                        console.log("[DEBUG] No meta files found for this database");
                        showMetaMessage("No meta analysis files found for this database.");
                        window.availableMetaFiles = [];
                    } else {
                        console.error("[ERROR] Failed to load meta files:", xhr.status, xhr.statusText);
                        showMetaError("Failed to load meta files.");
                    }
                }
            };
            
            xhr.send();
        }
        
        // Function to update slider based on available meta files
        function updateMetaSlider(metaFiles) {
            const slider = document.getElementById('generation-slider');
            if (!slider) return;
            
            if (metaFiles.length === 0) {
                // If no meta files, disable slider and show message
                slider.disabled = true;
                showMetaMessage("No meta analysis files found for this database.");
                return;
            }
            
            const generations = metaFiles.map(f => f.generation).sort((a, b) => a - b);
            const minGen = Math.min(...generations);
            const maxGen = Math.max(...generations);
            
            // Update slider attributes - use step of 1 for better control
            slider.disabled = false;
            slider.min = minGen;
            slider.max = maxGen;
            slider.step = 1;
            
            // Store available generations for validation
            slider.setAttribute('data-available-generations', JSON.stringify(generations));
            
            console.log(`[DEBUG] Updated slider range: ${minGen} - ${maxGen}, available: ${generations.join(', ')}`);
        }
        
        // Function to show a message in the meta content area
        function showMetaMessage(message) {
            const metaContent = document.getElementById('meta-content');
            if (metaContent) {
                metaContent.innerHTML = `<p style="text-align: center; color: #666; margin-top: 50px;">${message}</p>`;
            }
        }
        
        // Function to load meta content for a specific generation
        function loadMetaContent(generation) {
            if (!window.currentDbPath) {
                showMetaMessage("Please select a database first.");
                return;
            }
            
            // Check if this generation is available
            const availableGen = window.availableMetaFiles.find(f => f.generation == generation);
            if (!availableGen) {
                showMetaMessage(`Meta analysis for generation ${generation} is not available.`);
                return;
            }
            
            console.log("[DEBUG] Loading meta content for generation:", generation);
            
            // Show loading state
            const metaContent = document.getElementById('meta-content');
            if (metaContent) {
                metaContent.innerHTML = '<p style="text-align: center; color: #666; margin-top: 50px;">Loading meta analysis...</p>';
            }
            
            // Make request to server to get meta content
            const xhr = new XMLHttpRequest();
            xhr.open('GET', `/get_meta_content?db_path=${encodeURIComponent(window.currentDbPath)}&generation=${generation}`, true);
            
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        try {
                            const response = JSON.parse(xhr.responseText);
                            // Cache the content
                            window.metaContentCache[generation] = response;
                            displayMetaContent(response);
                            
                            // Preload previous generation for diff comparison
                            const availableGens = window.availableMetaFiles.map(f => f.generation).sort((a, b) => a - b);
                            const currentIndex = availableGens.indexOf(parseInt(generation));
                            if (currentIndex > 0) {
                                const prevGen = availableGens[currentIndex - 1];
                                loadMetaContentForDiff(prevGen);
                            }
                        } catch (e) {
                            console.error("[ERROR] Failed to parse meta content response:", e);
                            showMetaError("Failed to parse meta analysis content.");
                        }
                    } else {
                        console.error("[ERROR] Failed to load meta content:", xhr.status, xhr.statusText);
                        showMetaError(`Failed to load meta analysis for generation ${generation}.`);
                    }
                }
            };
            
            xhr.send();
        }
        
        // Function to convert structured meta content to HTML
        function convertStructuredMetaToHTML(content) {
            // Split content into sections (# INDIVIDUAL PROGRAM SUMMARIES, # GLOBAL INSIGHTS SCRATCHPAD, # META RECOMMENDATIONS)
            const sections = content.split(/^(#\s*(?:INDIVIDUAL PROGRAM SUMMARIES|GLOBAL INSIGHTS SCRATCHPAD|META RECOMMENDATIONS))$/m);
            let html = '';
            let inSection = false;
            
            for (let i = 0; i < sections.length; i++) {
                const section = sections[i];
                
                if (section.match(/^#\s*(?:INDIVIDUAL PROGRAM SUMMARIES|GLOBAL INSIGHTS SCRATCHPAD|META RECOMMENDATIONS)$/)) {
                    // This is a section header - start a new section box
                    if (inSection) {
                        html += '</div></div>'; // Close previous section
                    }
                    const headerText = section.replace(/^#\s*/, '');
                    html += `
                        <div class="meta-section" style="margin-bottom: 25px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
                            <div class="meta-section-header" style="background-color: #f8f9fa; padding: 15px; border-bottom: 1px solid #ddd;">
                                <h2 style="margin: 0; color: #2c3e50; font-size: 18px;">${headerText}</h2>
                            </div>
                            <div class="meta-section-content" style="padding: 20px;">
                    `;
                    inSection = true;
                } else if (section.trim()) {
                    // This is section content
                    if (!inSection) {
                        // Content before first section - treat as introduction
                        html += `<div style="margin-bottom: 20px; padding: 15px; background-color: #f9f9f9; border-radius: 5px;">`;
                        html += marked.parse(section);
                        html += `</div>`;
                    } else {
                        // Content within a section - just use regular markdown parsing
                        html += marked.parse(section);
                    }
                }
            }
            
            // Close the last section if we're in one
            if (inSection) {
                html += '</div></div>';
            }
            
            return html;
        }
        
        // Function to format program summaries with **Program Name:** structure
        function formatProgramSummaries(content) {
            // Preprocess content to remove double asterisks
            content = content.replace(/\*\*Program Name:\*\*/g, 'Program Name:');
            content = content.replace(/\*\*Implementation:\*\*/g, 'Implementation:');
            content = content.replace(/\*\*Performance:\*\*/g, 'Performance:');
            content = content.replace(/\*\*Feedback:\*\*/g, 'Feedback:');
            
            // Split by Program Name: to get individual program entries
            const parts = content.split(/Program Name:\s*/);
            let html = '';
            
            // Handle the first part (before any "Program Name:") as introductory text
            if (parts[0] && parts[0].trim()) {
                const introText = processSimpleMarkdown(parts[0].trim());
                html += `<div style="margin-bottom: 20px; line-height: 1.5;">${introText}</div>`;
            }
            
            // Process the actual program entries (skip the first part which is intro text)
            const programEntries = parts.slice(1).filter(entry => entry.trim());
            
            programEntries.forEach(entry => {
                const lines = entry.trim().split('\n');
                if (lines.length === 0) return;
                
                let entryHtml = '<div class="meta-entry" style="margin-bottom: 20px; padding: 15px; background-color: #f9f9f9; border-radius: 5px;">';
                
                // First line should be the program name (after the **Program Name: prefix)
                const programName = lines[0].replace(/\*\*$/, '').trim();
                entryHtml += `<div class="meta-name" style="font-weight: bold; color: #2c3e50; margin-bottom: 12px; font-size: 16px;">Program Name: ${programName}</div>`;
                
                // Process the rest of the lines
                let currentField = '';
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    if (line.startsWith('Implementation:')) {
                        currentField = 'implementation';
                        const content = processSimpleMarkdown(line.replace(/^Implementation:\s*/, ''));
                        entryHtml += `<div class="meta-implementation" style="margin-bottom: 8px;"><strong>Implementation:</strong> ${content}</div>`;
                    } else if (line.startsWith('Performance:')) {
                        currentField = 'performance';
                        const content = processSimpleMarkdown(line.replace(/^Performance:\s*/, ''));
                        entryHtml += `<div class="meta-performance" style="margin-bottom: 8px;"><strong>Performance:</strong> ${content}</div>`;
                    } else if (line.startsWith('Feedback:')) {
                        currentField = 'feedback';
                        const content = processSimpleMarkdown(line.replace(/^Feedback:\s*/, ''));
                        entryHtml += `<div class="meta-feedback" style="margin-bottom: 8px;"><strong>Feedback:</strong> ${content}</div>`;
                    } else if (line.startsWith('-') || currentField) {
                        // Continuation line or bullet point
                        const cleanLine = line.replace(/^-\s*/, '');
                        // Process markdown in the content
                        const processedLine = processSimpleMarkdown(cleanLine);
                        const indentStyle = line.startsWith('-') ? 'margin-left: 0px;' : 'margin-left: 15px;';
                        entryHtml += `<div style="${indentStyle} margin-bottom: 5px; line-height: 1.5;">${processedLine}</div>`;
                    } else {
                        // Other content
                        const processedLine = processSimpleMarkdown(line);
                        entryHtml += `<div style="margin-bottom: 5px; line-height: 1.5;">${processedLine}</div>`;
                    }
                }
                
                entryHtml += '</div>';
                html += entryHtml;
            });
            
            return html;
        }
        
        // Helper function to process simple markdown formatting
        function processSimpleMarkdown(text) {
            return text
                // Convert **text** to <strong>text</strong>
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // Convert *text* to <em>text</em>
                .replace(/\*(.*?)\*/g, '<em>$1</em>');
        }
        
        // Function to format structured entries (Name/Summary/Performance)
        function formatStructuredEntries(content) {
            // First try to fix entries that may be missing proper separations
            let fixedContent = content
                // Add double newlines before Name: if missing (handles both cases)
                .replace(/([^\n])\nName:/g, '$1\n\nName:')
                .replace(/(Performance:.*?)(Name:)/g, '$1\n\n$2')
                // Clean up any triple+ newlines
                .replace(/\n{3,}/g, '\n\n');
            
            // Split by double newlines to get individual entries
            const entries = fixedContent.split(/\n\s*\n/).filter(entry => entry.trim());
            let html = '';
            
            entries.forEach(entry => {
                const lines = entry.trim().split('\n');
                let entryHtml = '<div class="meta-entry" style="margin-bottom: 20px; padding: 15px; background-color: #f9f9f9; border-radius: 5px;">';
                
                let currentField = '';
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('Name:')) {
                        currentField = 'name';
                        entryHtml += `<div class="meta-name" style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">${trimmedLine}</div>`;
                    } else if (trimmedLine.startsWith('Summary:')) {
                        currentField = 'summary';
                        entryHtml += `<div class="meta-summary" style="margin-bottom: 8px; line-height: 1.5;">${trimmedLine}</div>`;
                    } else if (trimmedLine.startsWith('Performance:')) {
                        currentField = 'performance';
                        entryHtml += `<div class="meta-performance" style="font-style: italic; color: #34495e;">${trimmedLine}</div>`;
                    } else if (trimmedLine) {
                        // Continuation of previous field
                        const indentStyle = currentField === 'name' ? 'margin-left: 0px;' : 'margin-left: 10px;';
                        entryHtml += `<div style="${indentStyle} margin-bottom: 5px; line-height: 1.5;">${trimmedLine}</div>`;
                    }
                });
                
                entryHtml += '</div>';
                html += entryHtml;
            });
            
            return html;
        }

        // Store parsed meta sections globally
        window.parsedMetaSections = {};

        // Function to show specific meta section based on sub-tab selection
        function showMetaSection(sectionType) {
            const sectionContent = document.getElementById('meta-section-content');
            if (!sectionContent || !window.parsedMetaSections) {
                console.log("[DEBUG] showMetaSection: Missing elements or data", {
                    sectionContent: !!sectionContent,
                    parsedMetaSections: !!window.parsedMetaSections
                });
                return;
            }
            
            const sections = window.parsedMetaSections;
            let content = '';
            
            console.log("[DEBUG] showMetaSection:", sectionType);
            
            switch(sectionType) {
                case 'individual-programs':
                    content = sections.individualPrograms || '<p>No individual program summaries available.</p>';
                    break;
                case 'global-insights':
                    content = sections.globalInsights || '<p>No global insights available.</p>';
                    break;
                case 'meta-recommendations':
                    content = sections.metaRecommendations || '<p>No meta recommendations available.</p>';
                    break;
                default:
                    content = '<p>Section not found.</p>';
            }
            
            console.log("[DEBUG] Final content length:", content.length);
            sectionContent.innerHTML = content;
        }

        // Function to parse meta content into sections
        function parseMetaIntoSections(content) {
            const sections = {
                individualPrograms: '',
                globalInsights: '',
                metaRecommendations: ''
            };
            
            // Also store raw content for diff comparison
            const rawSections = {
                individualPrograms: '',
                globalInsights: '',
                metaRecommendations: ''
            };
            
            // Split content by main section headers
            const parts = content.split(/^#\s*(INDIVIDUAL PROGRAM SUMMARIES|GLOBAL INSIGHTS SCRATCHPAD|META RECOMMENDATIONS)$/m);
            
            for (let i = 1; i < parts.length; i += 2) {
                const sectionTitle = parts[i].trim();
                const sectionContent = parts[i + 1] || '';
                
                if (sectionTitle === 'INDIVIDUAL PROGRAM SUMMARIES') {
                    rawSections.individualPrograms = sectionContent.trim();
                    // Use the formatProgramSummaries function to create program boxes
                    sections.individualPrograms = formatProgramSummaries(sectionContent.trim());
                } else if (sectionTitle === 'GLOBAL INSIGHTS SCRATCHPAD') {
                    rawSections.globalInsights = sectionContent.trim();
                    sections.globalInsights = marked.parse(sectionContent.trim());
                } else if (sectionTitle === 'META RECOMMENDATIONS') {
                    rawSections.metaRecommendations = sectionContent.trim();
                    sections.metaRecommendations = marked.parse(sectionContent.trim());
                }
            }
            
            // Store raw sections globally for diff comparison
            sections._rawSections = rawSections;
            
            return sections;
        }



        // Function to display meta content with markdown rendering and optional diff highlighting
        function displayMetaContent(metaData, skipAsyncLoad = false) {
            const metaContent = document.getElementById('meta-content');
            if (!metaContent) return;
            
            try {
                const currentGen = metaData.generation;
                
                // Parse content into sections
                window.parsedMetaSections = parseMetaIntoSections(metaData.content);
                
                console.log("[DEBUG] Displaying meta content for generation", currentGen);
                
                // Show the content for the currently active sub-tab
                const activeSubTab = document.querySelector('.meta-sub-tab.active');
                const activeSection = activeSubTab ? activeSubTab.getAttribute('data-section') : 'individual-programs';
                
                console.log("[DEBUG] Active sub-tab:", activeSubTab, "Active section:", activeSection);
                
                // Display the header info
                metaContent.innerHTML = `
                    <div style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
                        <h3 style="margin: 0; color: #333;">Scratchpad - Generation ${metaData.generation}</h3>
                        <p style="margin: 5px 0 0 0; color: #666; font-size: 14px;">File: ${metaData.filename}</p>
                    </div>
                    <div class="meta-content-body" style="line-height: 1.6;" id="meta-section-content">
                        <!-- Content will be loaded by showMetaSection -->
                    </div>
                `;
                
                // Show the appropriate section (use setTimeout to ensure DOM is updated)
                setTimeout(() => {
                    showMetaSection(activeSection);
                }, 0);
                
                console.log("[DEBUG] Successfully displayed meta content for generation", metaData.generation);
            } catch (e) {
                console.error("[ERROR] Failed to render meta content:", e);
                showMetaError("Failed to render meta analysis content.");
            }
        }
        
        // Function to generate simple diff HTML that preserves markdown structure
        function generateSimpleDiffHTML(oldText, newText) {
            if (typeof Diff === 'undefined') {
                console.warn("[WARN] Diff library not loaded, showing markdown");
                return marked.parse(newText);
            }
            
            try {
                // Use line-based diff for better markdown preservation
                const diff = Diff.diffLines(oldText, newText);
                let result = '';
                
                diff.forEach(function(part) {
                    const lines = part.value.split('\n');
                    lines.forEach(function(line, index) {
                        if (line.trim() === '' && index === lines.length - 1) return; // Skip final empty line
                        
                        if (part.added) {
                            result += `<div class="diff-added" style="display: block; margin: 2px 0;">${marked.parseInline(line)}</div>\n`;
                        } else if (part.removed) {
                            result += `<div class="diff-removed" style="display: block; margin: 2px 0;">${marked.parseInline(line)}</div>\n`;
                        } else {
                            result += `${marked.parseInline(line)}<br>\n`;
                        }
                    });
                });
                
                return result;
            } catch (e) {
                console.error("[ERROR] Failed to generate simple diff:", e);
                return marked.parse(newText);
            }
        }
        
        // Function to download meta content as PDF
        function downloadMetaPdf(dbPath, generation) {
            console.log(`Downloading meta PDF for DB: ${dbPath}, Generation: ${generation}`);
            const url = `/download_meta_pdf?db_path=${encodeURIComponent(dbPath)}&generation=${generation}`;
            window.open(url, '_blank');
        }
        
        // Function to load meta content specifically for diff comparison (without displaying)
        function loadMetaContentForDiff(generation, onComplete) {
            if (window.metaContentCache[generation]) {
                if (onComplete) onComplete();
                return; // Already cached
            }
            
            console.log("[DEBUG] Loading meta content for diff comparison:", generation);
            
            const xhr = new XMLHttpRequest();
            xhr.open('GET', `/get_meta_content?db_path=${encodeURIComponent(window.currentDbPath)}&generation=${generation}`, true);
            
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        window.metaContentCache[generation] = response;
                        console.log("[DEBUG] Cached meta content for generation", generation);
                        
                        // Call the completion callback if provided
                        if (onComplete) onComplete();
                    } catch (e) {
                        console.error("[ERROR] Failed to cache meta content for diff:", e);
                    }
                }
            };
            
            xhr.send();
        }
        

        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to show meta error message
        function showMetaError(message) {
            const metaContent = document.getElementById('meta-content');
            if (metaContent) {
                metaContent.innerHTML = `<p style="text-align: center; color: #e74c3c; margin-top: 50px;">${message}</p>`;
            }
        }
        

        
        // Function to initialize the panel resizer
        function initializeResizer() {
            const divider = document.getElementById('divider');
            const treePanel = document.getElementById('tree-panel');
            const container = document.getElementById('container');
            let isDragging = false;
            
            // Store original width percentages
            let initialTreePanelWidth;
            let initialClientX;
            
            // Flag to prevent other updates during resize
            window.isResizing = false;
            
            // Mouse down event on the divider
            divider.addEventListener('mousedown', function(e) {
                // Prevent default selection behavior
                e.preventDefault();
                
                // Set dragging flag
                isDragging = true;
                window.isResizing = true;
                divider.classList.add('dragging');
                
                // Store initial positions
                initialTreePanelWidth = treePanel.offsetWidth;
                initialClientX = e.clientX;
            });
            
            // Mouse move event (only active when dragging)
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                // Calculate the new width
                const containerWidth = container.offsetWidth;
                const delta = e.clientX - initialClientX;
                let newWidth = initialTreePanelWidth + delta;
                
                // Enforce min and max constraints
                const minWidth = 200; // Minimum width in pixels
                const maxWidth = containerWidth * 0.8; // Maximum width at 80% of container
                
                if (newWidth < minWidth) newWidth = minWidth;
                if (newWidth > maxWidth) newWidth = maxWidth;
                
                // Calculate the percentage width
                const newWidthPercent = (newWidth / containerWidth) * 100;
                
                // Update the tree panel width
                treePanel.style.width = `${newWidthPercent}%`;
                
                // Save panel width preference
                savePreferences();
                
                // Update the tree without complete redraw
                if (window.currentTreeRoot) {
                    // Use requestAnimationFrame for smoother updates
                    if (window.treeUpdateRAF) {
                        cancelAnimationFrame(window.treeUpdateRAF);
                    }
                    window.treeUpdateRAF = requestAnimationFrame(function() {
                        renderTree(window.currentTreeRoot, true); // true = reuse existing elements
                    });
                }
            });
            
            // Mouse up event to stop dragging (listen on entire document)
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    divider.classList.remove('dragging');
                    
                    // Final update with reuse to ensure everything is correctly positioned
                    if (window.currentTreeRoot) {
                        renderTree(window.currentTreeRoot, true);
                    }
                    
                    // Delay resetting the resize flag to prevent immediate refreshes
                    setTimeout(() => {
                        window.isResizing = false;
                    }, 300);
                }
            });
            
            // Prevent cursor changes when dragging extends outside the divider
            document.addEventListener('mouseleave', function() {
                if (isDragging) {
                    isDragging = false;
                    divider.classList.remove('dragging');
                    window.isResizing = false;
                }
            });
            
            // Add a visual indicator when hovering over divider
            divider.addEventListener('mouseenter', function() {
                divider.classList.add('hover');
            });
            
            divider.addEventListener('mouseleave', function() {
                if (!isDragging) {
                    divider.classList.remove('hover');
                }
            });
        }

        // Function to find all .db files in the results directory
        async function findDatabases(force = false) {
            const taskSelect = document.getElementById("task-select");
            const resultSelect = document.getElementById("result-select");
            const scanStatus = document.getElementById("scan-status");

            // Use cached list unless forcing a refresh
            if (availableDatabases.length > 0 && !force) {
                organizeDatabases(availableDatabases);
                return;
            }

            scanStatus.textContent = "Loading available databases...";

            try {
                const response = await fetch('/list_databases');
                if (!response.ok) {
                    throw new Error(`Failed to load database list (HTTP ${response.status})`);
                }
                const dbs = await response.json();
                console.log("[DEBUG] Server returned databases:", dbs);

                availableDatabases = dbs;
                organizeDatabases(dbs);

                // Auto-load a DB if one is specified in the URL
                const urlParams = new URLSearchParams(window.location.search);
                const dbPathFromUrl = urlParams.get('db_path');
                if (dbPathFromUrl) {
                    const matchingDb = availableDatabases.find(db => db.path === dbPathFromUrl);
                    if (matchingDb) {
                        // Parse the path to extract task and result
                        const pathParts = dbPathFromUrl.split('/');
                        if (pathParts.length >= 3) {
                            const task = pathParts[pathParts.length - 3];
                            taskSelect.value = task;
                            populateResultSelect(task);
                            resultSelect.value = dbPathFromUrl;
                            loadDatabase(dbPathFromUrl);
                        }
                    }
                } else if (dbs.length > 0 && !force) {
                    // Auto-select the first task and result
                    const firstTask = Object.keys(tasksAndResults)[0];
                    if (firstTask && tasksAndResults[firstTask].length > 0) {
                        taskSelect.value = firstTask;
                        populateResultSelect(firstTask);
                        const firstResult = tasksAndResults[firstTask][0].path;
                        resultSelect.value = firstResult;
                        loadDatabase(firstResult);
                    }
                }

            } catch (error) {
                console.error("[DEBUG] Error fetching database list:", error);
                scanStatus.textContent = "Error loading database list.";
                taskSelect.innerHTML = '<option value="">Error loading databases</option>';
                resultSelect.innerHTML = '<option value="">Select a result...</option>';
            }
        }
        
        function organizeDatabases(dbs) {
            const scanStatus = document.getElementById("scan-status");
            
            // Clear existing data
            tasksAndResults = {};
            
            if (dbs.length === 0) {
                scanStatus.textContent = "No databases found.";
                return;
            }

            // Organize databases by task
            dbs.forEach(db => {
                const pathParts = db.path.split('/');
                if (pathParts.length >= 3) {
                    const task = pathParts[pathParts.length - 3]; // Third to last part is the task
                    const result = pathParts[pathParts.length - 2]; // Second to last part is the result
                    
                    if (!tasksAndResults[task]) {
                        tasksAndResults[task] = [];
                    }
                    
                    tasksAndResults[task].push({
                        name: result, // No need to remove extension since this is a directory name
                        path: db.path,
                        sortKey: db.sort_key || '0'
                    });
                }
            });

            // Sort results within each task by date (newest first)
            Object.keys(tasksAndResults).forEach(task => {
                tasksAndResults[task].sort((a, b) => b.sortKey.localeCompare(a.sortKey));
            });

            populateTaskSelect();
            scanStatus.textContent = `Found ${dbs.length} database(s) across ${Object.keys(tasksAndResults).length} task(s).`;
        }

        function populateTaskSelect() {
            const taskSelect = document.getElementById("task-select");
            
            // Clear existing options
            taskSelect.innerHTML = '<option value="">Select a task...</option>';
            
            const tasks = Object.keys(tasksAndResults).sort();
            tasks.forEach(task => {
                const option = document.createElement("option");
                option.value = task;
                option.textContent = task;
                taskSelect.appendChild(option);
            });
        }

        function populateResultSelect(selectedTask) {
            const resultSelect = document.getElementById("result-select");
            
            // Clear existing options
            resultSelect.innerHTML = '<option value="">Select a result...</option>';
            
            if (!selectedTask || !tasksAndResults[selectedTask]) {
                return;
            }

            tasksAndResults[selectedTask].forEach(result => {
                const option = document.createElement("option");
                option.value = result.path;
                option.textContent = result.name;
                resultSelect.appendChild(option);
            });
        }

        // Configuration
        const config = {
            // This section is now managed by fetching from the server
        };

        // Helper function to format timestamps from YYYYMMDD_HHMMSS format to readable format
        function formatTimestamp(timestamp) {
            if (!timestamp) return 'unknown';
            
            const tsString = String(timestamp);
            
            // If it's already formatted or isn't in the expected format, return as is
            if (tsString === 'latest' || tsString === 'unknown') {
                return tsString;
            }

            // Check if it's a Unix timestamp (number, potentially with decimals)
            if (!isNaN(parseFloat(tsString)) && isFinite(tsString)) {
                const date = new Date(parseFloat(tsString) * 1000); // from seconds to ms
                const pad = (num) => String(num).padStart(2, '0');
                const year = date.getFullYear();
                const month = pad(date.getMonth() + 1);
                const day = pad(date.getDate());
                const hour = pad(date.getHours());
                const minute = pad(date.getMinutes());
                const second = pad(date.getSeconds());
                return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
            }
            
            // Check if the timestamp matches our expected format
            const tsRegex = /^(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})$/;
            const match = tsString.match(tsRegex);
            
            if (match) {
                const [_, year, month, day, hour, minute, second] = match;
                // Format as YYYY-MM-DD HH:MM
                return `${year}-${month}-${day} ${hour}:${minute}`;
            }
            
            return tsString;
        }

        // Auto-refresh functionality
        function initializeAutoRefresh() {
            console.log("[DEBUG] Initializing auto-refresh functionality");
            
            // Start auto-refresh when a database is loaded
            if (window.currentDbPath) {
                startAutoRefresh();
            }
        }

        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            autoRefreshEnabled = true;
            console.log("[DEBUG] Starting auto-refresh with 3 second intervals");
            
            // Update button state
            const autoRefreshToggle = document.getElementById('auto-refresh-toggle');
            if (autoRefreshToggle) {
                autoRefreshToggle.classList.add('active');
                autoRefreshToggle.title = "Disable auto-refresh";
            }
            
            autoRefreshInterval = setInterval(() => {
                if (autoRefreshEnabled && window.currentDbPath && !window.isReloadingData && !window.isResizing) {
                    checkForNewData();
                }
            }, 3000); // Check every 3 seconds
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            autoRefreshEnabled = false;
            
            // Update button state
            const autoRefreshToggle = document.getElementById('auto-refresh-toggle');
            if (autoRefreshToggle) {
                autoRefreshToggle.classList.remove('active');
                autoRefreshToggle.title = "Enable auto-refresh (every 3 seconds)";
            }
            

            
            console.log("[DEBUG] Auto-refresh stopped");
        }
        async function checkForNewData() {
            if (!window.currentDbPath) return;
            
            try {
                // Check if there's new data available
                const response = await fetch(`/get_programs?db_path=${encodeURIComponent(window.currentDbPath)}&timestamp_check=true`);
                if (!response.ok) {
                    console.log("[DEBUG] Auto-refresh: Failed to check for new data");
                    return;
                }
                
                const result = await response.json();
                
                // Check if we have a timestamp to compare
                if (result.last_modified_timestamp) {
                    if (lastDataTimestamp && result.last_modified_timestamp > lastDataTimestamp) {
                        console.log("[DEBUG] Auto-refresh: New data detected, refreshing...");
                        
                        // Update the scan status to show auto-refresh
                        const scanStatus = document.getElementById("scan-status");
                        const originalText = scanStatus.textContent;
                        scanStatus.textContent = "Auto-refreshing...";
                        
                        // Reload the data
                        window.isReloadingData = true;
                        await loadDatabaseSilent(window.currentDbPath);
                        
                        // The scan status is now updated by loadDatabaseSilent with the new timestamp
                    }
                    
                    // Update our stored timestamp
                    lastDataTimestamp = result.last_modified_timestamp;
                } else if (result.length !== undefined) {
                    // Fallback: compare data length if timestamp not available
                    const currentDataLength = window.treeData ? window.treeData.length : 0;
                    if (result.length > currentDataLength) {
                        console.log("[DEBUG] Auto-refresh: New data detected (length changed), refreshing...");
                        
                        const scanStatus = document.getElementById("scan-status");
                        const originalText = scanStatus.textContent;
                        scanStatus.textContent = "Auto-refreshing...";
                        
                        window.isReloadingData = true;
                        await loadDatabaseSilent(window.currentDbPath);
                        
                        // The scan status is now updated by loadDatabaseSilent with the new timestamp
                    }
                }
            } catch (error) {
                console.log("[DEBUG] Auto-refresh: Error checking for new data:", error);
                // Don't show alerts for auto-refresh errors, just log them
            }
        }

        // Silent version of loadDatabase that doesn't show loading states
        async function loadDatabaseSilent(dbPath) {
            try {
                const response = await fetch(`/get_programs?db_path=${encodeURIComponent(dbPath)}`);
                if (!response.ok) {
                    throw new Error(`Failed to load data (HTTP ${response.status})`);
                }
                
                const data = await response.json();
                
                if (!data || data.length === 0) {
                    console.log("[DEBUG] Auto-refresh: No new data received");
                    return;
                }
                
                console.log("[DEBUG] Auto-refresh: Processing", data.length, "programs");
                window.rawDbData = data;
                
                // Update the scan status with new program count and timestamp
                const scanStatus = document.getElementById("scan-status");
                if (scanStatus) {
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
                    const baseText = `Loaded ${data.length} programs [${timeStr}]`;
                    scanStatus.textContent = baseText;
                }
                
                // Store the current selected node and active right tab to restore after refresh
                const selectedNodeId = getSelectedNodeId();
                const currentRightTab = document.querySelector('.tab.active');
                const currentRightTabId = currentRightTab ? currentRightTab.getAttribute('data-tab') : null;
                
                processData(data);
                
                // Try to restore the selected node if it still exists
                if (selectedNodeId && window.treeData) {
                    const nodeStillExists = window.treeData.find(d => d.id === selectedNodeId);
                    if (nodeStillExists) {
                        // Use a timeout to ensure the DOM has been updated
                        setTimeout(() => {
                            selectNodeById(selectedNodeId, false, false); // Don't force right tab switch during re-render
                            
                            // Restore the right tab after node selection
                            if (currentRightTabId && currentRightTabId !== 'agent-code') {
                                setTimeout(() => {
                                    const tabElement = document.querySelector(`.tab[data-tab="${currentRightTabId}"]`);
                                    if (tabElement) {
                                        tabElement.click();
                                    }
                                }, 50);
                            }
                        }, 100);
                    }
                } else {
                    // No node was selected, but still restore right tab if it's not the default
                    if (currentRightTabId && currentRightTabId !== 'agent-info') {
                        setTimeout(() => {
                            const tabElement = document.querySelector(`.tab[data-tab="${currentRightTabId}"]`);
                            if (tabElement) {
                                tabElement.click();
                            }
                        }, 150);
                    }
                }
                
            } catch (error) {
                console.log("[DEBUG] Auto-refresh: Failed to load data silently:", error);
            } finally {
                window.isReloadingData = false;
            }
        }

        function getSelectedNodeId() {
            const selectedNode = document.querySelector('.node.selected');
            if (selectedNode) {
                // Extract node ID from D3 data
                const d3Node = d3.select(selectedNode).datum();
                return d3Node ? d3Node.data.id : null;
            }
            return null;
        }

        // Function to load and process data from a database file
        function loadDatabase(dbPath) {
            console.log("[DEBUG] Attempting to load DB from:", dbPath);

            document.getElementById("node-summary").innerHTML = "";
            d3.selectAll('.node').classed('selected', false);
            
            document.getElementById("agent-code-wrapper").innerHTML = "<p>Select a node from the tree to view code.</p>";
            document.querySelector('#agent-code .code-controls').style.display = 'none';
            document.getElementById("node-details").innerHTML = "<p>Select a node to view its details.</p>";
            document.getElementById("code-diff").innerHTML = "<p>Select a node to view its code diff.</p>";
            
            // Clear content of other left-panel tabs to force re-render on click
            document.getElementById("embeddings-heatmap").innerHTML = "";
            document.getElementById("islands-container").innerHTML = "";
            document.getElementById("best-path-container").innerHTML = "";
            // Don't clear the model-posteriors-container completely, just the chart content
            const modelPosteriorsChart = document.getElementById("model-posteriors-chart");
            if (modelPosteriorsChart) {
                modelPosteriorsChart.innerHTML = "";
            }


            // Reset Pareto plot controls
            paretoListenersAdded = false;
            const ySelect = document.getElementById('pareto-y-axis');
            const xSelect = document.getElementById('pareto-x-axis');
            if (ySelect) ySelect.innerHTML = '';
            if (xSelect) xSelect.innerHTML = '';



            window.currentDbPath = dbPath;
            
            if (window.isResizing) {
                console.log("[DEBUG] Skipping DB loading during resize");
                return;
            }
            
            const scanStatus = document.getElementById("scan-status");
            scanStatus.textContent = "Loading data...";
            
            fetch(`/get_programs?db_path=${encodeURIComponent(dbPath)}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load data (HTTP ${response.status})`);
                        }
                    return response.json();
                })
                .then(data => {
                    console.log("[DEBUG] Data received from server:", data.length, "programs");
                    
                    if (!data || data.length === 0) {
                        throw new Error("Database contains no programs.");
                    }
                    
                    window.rawDbData = data;
                    
                    // Update status with timestamp
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
                    scanStatus.textContent = `Loaded ${data.length} programs [${timeStr}]`;
                    
                    // Set initial timestamp for auto-refresh comparison
                    lastDataTimestamp = Date.now();
                    
                    processData(data);
                    
                    // Start auto-refresh for this database
                    startAutoRefresh();
                })
                .catch(error => {
                    console.error(`[DEBUG] Failed to load database: ${error.message}`);
                    
                    // Check if this is a concurrent access issue (503 = Service Unavailable)
                    const isConcurrentAccess = error.message.includes('503') || 
                                             error.message.includes('temporarily unavailable');
                    
                    if (isConcurrentAccess) {
                        scanStatus.textContent = "Database busy - evolution may be running";
                        scanStatus.style.color = '#ffc107'; // Warning yellow
                        
                        // Show concurrent access warning in the file list area
                        const fileList = document.getElementById("file-list");
                        fileList.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #ffc107; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 5px; margin: 10px 0;">
                                <h3>‚ö†Ô∏è Database Temporarily Unavailable</h3>
                                <p>The database appears to be in use by a running evolution process.</p>
                                <p><strong>With WAL mode enabled:</strong> This should resolve shortly.</p>
                                <p>Try refreshing in a few seconds, or wait for the evolution to complete.</p>
                                <button onclick="loadDatabase('${dbPath}')" style="margin-top: 10px; padding: 8px 16px; background-color: #ffc107; border: none; border-radius: 3px; cursor: pointer;">
                                    üîÑ Retry Now
                                </button>
                            </div>
                        `;
                        
                        // Don't stop auto-refresh for concurrent access - it might resolve
                        console.log("[DEBUG] Database busy, keeping auto-refresh active");
                    } else {
                        scanStatus.textContent = "Error loading data.";
                        scanStatus.style.color = '#dc3545'; // Error red
                        
                        // Show general error message
                        const fileList = document.getElementById("file-list");
                        fileList.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #dc3545; background-color: #f8d7da; border: 1px solid #dc3545; border-radius: 5px; margin: 10px 0;">
                                <h3>‚ùå Failed to Load Database</h3>
                                <p>Error: ${error.message}</p>
                                <p>Please check the database file and try again.</p>
                            </div>
                        `;
                        
                        // Stop auto-refresh on general errors
                        stopAutoRefresh();
                    }
                })
                .finally(() => {
                    window.isReloadingData = false; // Re-enable state saving
                    console.log("[DEBUG] Data reloading finished.");
                });
        }

        // Process the data and generate the tree
        function processData(data) {
            if (!data || data.length === 0) {
                console.error("[DEBUG] No data to process!");
                document.getElementById("tree-legend").style.display = "none"; // Hide the legend when no data
                return;
            }
            
            console.log("[DEBUG] Processing data:", data.length, "rows");
            try {
                // Determine the active tabs *before* doing anything else
                const activeLeftTab = document.querySelector('.left-tab.active');
                const activeLeftTabId = activeLeftTab ? activeLeftTab.getAttribute('data-tab') : 'tree-view';
                const activeRightTab = document.querySelector('.tab.active');
                const activeRightTabId = activeRightTab ? activeRightTab.getAttribute('data-tab') : 'agent-info';

                // Sort and process data
                data.sort((a, b) => {
                    if (a.generation !== b.generation) return a.generation - b.generation;
                    return a.timestamp - b.timestamp;
                });
                const genCounters = {};
                data.forEach(row => {
                    if (!genCounters[row.generation]) genCounters[row.generation] = 0;
                    row.iter_id = genCounters[row.generation]++;
                });
                // Ensure no virtual root nodes ever get into the global data
                window.treeData = data.filter(d => !d.id || !d.id.includes('___virtual_root'));
                
                // Update views that are always visible or independent of the left tab
                populateProgramsTable(data);
                updateMetaInfoTab(data);
                updateParetoView();
                
                // Restore the right-side tab state instead of hardcoded click
                if (activeRightTabId && document.querySelector(`.tab[data-tab="${activeRightTabId}"]`)) {
                    document.querySelector(`.tab[data-tab="${activeRightTabId}"]`).click();
                } else {
                    document.querySelector('.tab[data-tab="agent-info"]').click();
                }
                
                updateScoreHeatbar();
                
                // Clear any cached view data to force refreshes when new data is loaded
                window.embeddingsCreated = false;
                
                // Clear all visualization containers to force complete refresh
                const clearContainer = (id) => {
                    const container = document.getElementById(id);
                    if (container) container.innerHTML = '';
                };
                
                clearContainer('embeddings-heatmap');
                clearContainer('islands-container');
                clearContainer('best-path-container');

                clearContainer('cluster-plot-2d');
                clearContainer('cluster-plot-3d');
                clearContainer('metrics-plots');
                
                // Now, render the correct left-hand view based on the stored activeLeftTabId
                if (activeLeftTabId === 'tree-view') {
                    document.getElementById("tree-legend").style.display = "block";
                    renderGraph(data);
                } else {
                    document.getElementById("tree-legend").style.display = "none";
                    // Process the active view to improve performance
                    setTimeout(() => {
                        if (activeLeftTabId === 'embeddings-view') {
                            createEmbeddingsHeatmap(data);
                        } else if (activeLeftTabId === 'islands-view') {
                            createIslandsVisualization(data);
                        } else if (activeLeftTabId === 'best-path-view') {
                            createBestPathVisualization(data);
                        } else if (activeLeftTabId === 'model-posteriors-view') {
                            createModelPosteriorsVisualization(data);
                        } else if (activeLeftTabId === 'clusters-view') {
                            createClusterPlots(data);
                        } else if (activeLeftTabId === 'metrics-view') {
                            createMetricsVisualization(data);
                        }
                        
                        // Also always refresh metrics in background for quick tab switching
                        setTimeout(() => {
                            createMetricsVisualization(data);
                        }, 200);
                    }, 100);
                }
                
                // Store data refresh flag to ensure views update when switching tabs
                window.dataRefreshed = true;
                
                // Load available meta files for the current database
                if (window.currentDbPath) {
                    loadAvailableMetaFiles(window.currentDbPath);
                }
            } catch (error) {
                console.error("[DEBUG] Error in processData:", error);
            }
        }
        function renderGraph(data) {
            console.log("[DEBUG] Starting graph rendering with D3 tree layout");

            try {
                d3.select("#tree").html(""); // Clear existing tree

                const margin = {top: 300, right: 120, bottom: 300, left: 120};
                const treeView = document.getElementById('tree-view');
                if (!treeView) {
                    console.error("[DEBUG] tree-view element not found");
                    return;
                }
                const panelWidth = treeView.offsetWidth;
                const panelHeight = treeView.offsetHeight;

                const svg = d3.select("#tree").append("svg")
                    .attr("width", panelWidth)
                    .attr("height", panelHeight)
                    .attr("preserveAspectRatio", "xMidYMid meet")
                    .call(d3.zoom().extent([[0, 0], [panelWidth, panelHeight]]).scaleExtent([0.1, 8]).on("zoom", e => g.attr("transform", e.transform)))
                    .append("g");
                
                const g = svg.append("g");

                // Create unified root structure for generation 0 programs
                let processedData = [...data];
                const gen0Programs = data.filter(d => d.generation === 0);
                const unifiedRootId = '___unified_root___';
                
                if (gen0Programs.length > 1) {
                    // Create a unified root node representing the common origin
                    const firstGen0 = gen0Programs[0];
                    const unifiedRoot = {
                        id: unifiedRootId,
                        parent_id: null,
                        code: firstGen0.code,
                        language: firstGen0.language,
                        generation: 0,
                        timestamp: Math.min(...gen0Programs.map(p => p.timestamp)),
                        agent_name: 'Initial Program',
                        combined_score: firstGen0.combined_score,
                        public_metrics: firstGen0.public_metrics,
                        private_metrics: firstGen0.private_metrics,
                        text_feedback: firstGen0.text_feedback,
                        metadata: { ...firstGen0.metadata, patch_name: 'Initial Program' },
                        complexity: firstGen0.complexity,
                        embedding: firstGen0.embedding,
                        embedding_pca_2d: firstGen0.embedding_pca_2d,
                        embedding_pca_3d: firstGen0.embedding_pca_3d,
                        island_idx: null, // No specific island for the unified root
                        isUnifiedRoot: true
                    };
                    
                    // Add the unified root to the data
                    processedData.push(unifiedRoot);
                    
                    // Update all generation 0 programs to point to the unified root
                    // Note: We don't increment generations here to preserve original data for other views
                    processedData = processedData.map(d => {
                        if (d.generation === 0 && d.id !== unifiedRootId) {
                            return {
                                ...d,
                                parent_id: unifiedRootId
                            };
                        }
                        return d;
                    });
                    
                    console.log(`[DEBUG] Created unified root for ${gen0Programs.length} generation 0 programs`);
                }
                
                const nodes = processedData.map(d => ({...d, agent_name: d.metadata.patch_name || d.agent_name || "unnamed_agent"}));
                const nodeMap = new Map(nodes.map(node => [node.id, node]));

                let hierarchyData = JSON.parse(JSON.stringify(nodes));
                const rootNodes = hierarchyData.filter(n => !n.parent_id || !nodeMap.has(n.parent_id));
                const virtualRootId = '___virtual_root___';

                // Only create virtual root if we have multiple roots AND we don't have a unified root
                const hasUnifiedRoot = rootNodes.some(n => n.isUnifiedRoot);
                if (rootNodes.length > 1 && !hasUnifiedRoot) {
                    hierarchyData.push({ id: virtualRootId, parent_id: '', agent_name: 'VIRTUAL ROOT', isVirtual: true, generation: -1 });
                    rootNodes.forEach(rn => {
                        rn.parent_id = virtualRootId;
                    });
                }
                
                const root = d3.stratify()
                    .id(d => d.id)
                    .parentId(d => d.parent_id)
                    (hierarchyData);

                root.sort((a, b) => a.data.generation - b.data.generation || a.data.timestamp - b.data.timestamp);

                const nodeWidth = 100;
                const nodeHeight = 200;
                const treeLayout = d3.tree().nodeSize([nodeWidth, nodeHeight]);
                treeLayout(root);

                const treeHeight = root.height * nodeHeight;
                const calculatedTopMargin = (panelHeight - treeHeight) / 2;
                margin.top = Math.max(100, calculatedTopMargin);

                let minX = Infinity, maxX = -Infinity;
                root.each(d => {
                    if (d.x < minX) minX = d.x;
                    if (d.x > maxX) maxX = d.x;
                });
                const treeWidth = maxX - minX;
                
                d3.select("#tree svg")
                    .attr("viewBox", `${minX - margin.left} 0 ${treeWidth + margin.left + margin.right} ${treeHeight + margin.top + margin.bottom}`);
                
                g.attr("transform", `translate(0, ${margin.top})`);
                
                // Clear any stale best path data first
                window.bestNodeId = null;
                window.allBestPaths = [];
                window.bestScoreNodes = [];
                
                // Find the actual best score among correct nodes only
                const correctValidNodes = nodes.filter(d => {
                    const isCorrect = d.correct === true || d.correct === 'true' || d.correct === 1;
                    const hasValidScore = d.combined_score !== null && 
                                         d.combined_score !== undefined && 
                                         !isNaN(d.combined_score);
                    if (hasValidScore && !isCorrect) {
                        console.log("[DEBUG] Excluding incorrect node:", d.id.substring(0, 8), "correct:", d.correct, "score:", d.combined_score);
                    }
                    return isCorrect && hasValidScore;
                });
                console.log("[DEBUG] Total correct valid nodes for scoring:", correctValidNodes.length);
                
                // Debug: show some examples of correct vs incorrect nodes
                const allValidNodes = nodes.filter(d => d.combined_score !== null && d.combined_score !== undefined && !isNaN(d.combined_score));
                const incorrectNodes = allValidNodes.filter(d => !(d.correct === true || d.correct === 'true' || d.correct === 1));
                console.log("[DEBUG] Total valid nodes:", allValidNodes.length, "Incorrect nodes:", incorrectNodes.length);
                if (incorrectNodes.length > 0) {
                    console.log("[DEBUG] Sample incorrect nodes:", incorrectNodes.slice(0, 3).map(d => ({id: d.id.substring(0, 8), correct: d.correct, score: d.combined_score})));
                }
                if (correctValidNodes.length > 0) {
                    console.log("[DEBUG] Sample correct nodes:", correctValidNodes.slice(0, 3).map(d => ({id: d.id.substring(0, 8), correct: d.correct, score: d.combined_score})));
                }
                
                // Fallback to all valid nodes if no correct nodes exist
                let scoringNodes = correctValidNodes;
                if (correctValidNodes.length === 0) {
                    console.warn("[DEBUG] No correct nodes found for scoring, falling back to all valid nodes");
                    scoringNodes = allValidNodes;
                    if (scoringNodes.length === 0) {
                        console.warn("[DEBUG] No valid nodes found for scoring");
                        window.allBestPaths = [];
                        return;
                    }
                }
                
                // Find the highest score among the selected nodes
                const actualBestScore = Math.max(...scoringNodes.map(d => d.combined_score));
                console.log("[DEBUG] Actual best score found:", actualBestScore);
                
                // Use a more robust epsilon for floating-point comparison
                const epsilon = Math.max(1e-6, Math.abs(actualBestScore) * 1e-10);
                console.log("[DEBUG] Using epsilon:", epsilon);
                
                // Find all nodes with the best score (from the correct scoring nodes)
                const allNodesWithBestScore = scoringNodes.filter(d => {
                    const scoreDiff = Math.abs(d.combined_score - actualBestScore);
                    const isEqual = scoreDiff < epsilon;
                    if (isEqual) {
                        console.log("[DEBUG] Found node with best score:", d.id.substring(0, 8), "score:", d.combined_score, "correct:", d.correct, "diff:", scoreDiff);
                    }
                    return isEqual;
                });

                // Double-check: ensure only correct nodes are included for path highlighting
                const correctNodesWithBestScore = allNodesWithBestScore.filter(d => {
                    const isCorrect = d.correct === true || d.correct === 'true' || d.correct === 1;
                    if (!isCorrect) {
                        console.log("[DEBUG] EXCLUDING incorrect node from best score paths:", d.id.substring(0, 8), "correct:", d.correct, "score:", d.combined_score);
                    }
                    return isCorrect;
                });
                
                // FORCE SINGLE PATH: Only use the first (best) correct node
                const nodesWithBestScore = correctNodesWithBestScore.length > 0 ? [correctNodesWithBestScore[0]] : [];
                
                console.log("[DEBUG] SINGLE PATH MODE: Using only one best correct node:", nodesWithBestScore.length > 0 ? nodesWithBestScore[0].id.substring(0, 8) : "none");
                
                // Set the best node (should already be correct since we filtered to correct nodes)
                const bestNode = nodesWithBestScore[0];
                
                // Safety check: ensure the best node is actually correct
                const bestNodeIsCorrect = bestNode && (bestNode.correct === true || bestNode.correct === 'true' || bestNode.correct === 1);
                if (!bestNodeIsCorrect) {
                    console.error("[DEBUG] ERROR: Best node is not marked as correct:", bestNode ? bestNode.id.substring(0, 8) : 'null', "correct:", bestNode ? bestNode.correct : 'N/A');
                }
                
                if (correctValidNodes.length > 0) {
                    console.log("[DEBUG] Using best correct node:", bestNode.id.substring(0, 8), "score:", bestNode.combined_score, "correct:", bestNode.correct);
                } else {
                    console.log("[DEBUG] Using best fallback node (no correct nodes available):", bestNode.id.substring(0, 8), "score:", bestNode.combined_score, "correct:", bestNode.correct);
                }
                
                window.bestNodeId = bestNode.id;
                
                // Store information about multiple best paths (only correct nodes)
                window.bestScoreNodes = nodesWithBestScore;
                window.currentBestPathIndex = 0;

                let bestNodeD3 = null;
                root.each(d => {
                    if (d.data.id === window.bestNodeId) {
                        bestNodeD3 = d;
                    }
                });

                const ancestorIds = new Set();
                if (bestNodeD3 && window.bestNodeId) {
                    // Double-check: only populate ancestorIds if the best node is actually correct
                    const bestNodeDataIsCorrect = bestNodeD3.data.correct === true || bestNodeD3.data.correct === 'true' || bestNodeD3.data.correct === 1;
                    if (bestNodeDataIsCorrect) {
                        bestNodeD3.ancestors().forEach(ancestor => {
                            ancestorIds.add(ancestor.data.id);
                        });
                        console.log("[DEBUG] Populated ancestorIds for correct best node:", window.bestNodeId.substring(0, 8), "path length:", ancestorIds.size);
                    } else {
                        console.error("[DEBUG] ERROR: Not populating ancestorIds because best node is incorrect:", window.bestNodeId.substring(0, 8), "correct:", bestNodeD3.data.correct);
                    }
                } else {
                    console.log("[DEBUG] No ancestorIds populated - no valid best node found");
                }
                
                // Store all best paths for highlighting - FORCE SINGLE PATH
                window.allBestPaths = [];
                let foundNodesCount = 0;
                
                // SINGLE PATH MODE: Only process the first (and only) node
                if (nodesWithBestScore.length > 0) {
                    const singleBestNode = nodesWithBestScore[0];
                    console.log("[DEBUG] SINGLE PATH: Processing only one node:", singleBestNode.id.substring(0, 8));
                
                    // Process only the single best node
                    [singleBestNode].forEach((node, index) => {
                    let nodeD3 = null;
                    
                    // First try to find the node in the D3 tree
                    root.each(d => {
                        if (d.data.id === node.id) {
                            nodeD3 = d;
                        }
                    });
                    
                    if (nodeD3) {
                        foundNodesCount++;
                        const pathIds = new Set();
                        const pathNodes = nodeD3.ancestors();
                        
                        // Add the node itself to the path
                        pathIds.add(nodeD3.data.id);
                        
                        // Add all ancestors
                        pathNodes.forEach(ancestor => {
                            pathIds.add(ancestor.data.id);
                        });
                        
                        console.log("[DEBUG] Path", index + 1, "- Node:", node.id.substring(0, 8), 
                                   "Path length:", pathIds.size, "Score:", node.combined_score, "Generation:", node.generation);
                        
                        window.allBestPaths.push({
                            nodeId: node.id,
                            pathIds: pathIds,
                            score: node.combined_score,
                            generation: node.generation
                        });
                    } else {
                        console.warn("[DEBUG] Could not find D3 node for best score node:", node.id.substring(0, 8), 
                                    "- attempting manual path reconstruction");
                        
                        // Fallback: try to reconstruct path manually using the original nodes data
                        const pathIds = new Set();
                        pathIds.add(node.id);
                        
                        // Try to trace back through parent relationships
                        let currentNode = node;
                        while (currentNode && currentNode.parent_id) {
                            const parentNode = nodes.find(n => n.id === currentNode.parent_id);
                            if (parentNode) {
                                pathIds.add(parentNode.id);
                                currentNode = parentNode;
                            } else {
                                console.warn("[DEBUG] Could not find parent node:", currentNode.parent_id);
                                break;
                            }
                        }
                        
                        if (pathIds.size > 1) {
                            console.log("[DEBUG] Reconstructed path", index + 1, "- Node:", node.id.substring(0, 8), 
                                       "Path length:", pathIds.size, "Score:", node.combined_score);
                            
                            window.allBestPaths.push({
                                nodeId: node.id,
                                pathIds: pathIds,
                                score: node.combined_score,
                                generation: node.generation,
                                reconstructed: true
                            });
                            foundNodesCount++;
                        }
                    }
                    });
                } else {
                    console.log("[DEBUG] SINGLE PATH: No valid best node found");
                }
                
                console.log("[DEBUG] SINGLE PATH: Successfully found", foundNodesCount, "path(s)");
                
                // FORCE SINGLE PATH: Truncate to only the first path if multiple exist
                if (window.allBestPaths.length > 1) {
                    console.log("[DEBUG] FORCE TRUNCATING to single path from", window.allBestPaths.length, "paths");
                    window.allBestPaths = [window.allBestPaths[0]];
                }
                
                // FORCE SINGLE NODE: Ensure bestScoreNodes only has one node
                if (window.bestScoreNodes.length > 1) {
                    console.log("[DEBUG] FORCE TRUNCATING bestScoreNodes to single node from", window.bestScoreNodes.length, "nodes");
                    window.bestScoreNodes = [window.bestScoreNodes[0]];
                }
                
                // Summary for debugging - SINGLE PATH MODE
                if (window.allBestPaths.length === 1) {
                    console.log("[DEBUG] SINGLE PATH MODE: One path found to:", window.allBestPaths[0].nodeId.substring(0, 8), "Score:", window.allBestPaths[0].score);
                } else {
                    console.warn("[DEBUG] SINGLE PATH MODE: No paths found");
                }

                const scores = nodes
                    .filter(d => d.correct && d.combined_score !== null && !isNaN(d.combined_score))
                    .map(d => d.combined_score);

                const minScore = scores.length > 0 ? Math.min(...scores) : 0;
                const maxScore = scores.length > 0 ? Math.max(...scores) : 1;
                const colorScale = d3.scaleSequential(d3.interpolateViridis).domain([minScore, maxScore]);
                
                const shapeMap = {
                    'init': d3.symbolDiamond,
                    'full': d3.symbolCircle,
                    'diff': d3.symbolSquare,
                    'cross': d3.symbolCross
                };
                const getShape = (patchType) => shapeMap[patchType] || d3.symbolCircle;
                const symbol = d3.symbol().size(2500);

                // Create color scale for islands with distinctive colors (avoiding orange used for best path)
                const islandColors = [
                    "#1f77b4", // blue
                    "#2ca02c", // green  
                    "#9467bd", // purple
                    "#8c564b", // brown
                    "#e377c2", // pink
                    "#7f7f7f", // gray
                    "#bcbd22", // olive
                    "#17becf", // cyan
                    "#aec7e8"  // light blue
                ];
                const islandColorScale = d3.scaleOrdinal(islandColors);
                
                const usedPatchTypes = [...new Set(nodes.map(d => d.metadata.patch_type).filter(Boolean))];
                const usedIslands = [...new Set(nodes.map(d => d.island_idx).filter(idx => idx !== null && idx !== undefined))].sort((a, b) => a - b);
                updateShapeLegend(shapeMap, usedPatchTypes, usedIslands, islandColorScale);

                const defs = g.append("defs");
                defs.append("marker")
                    .attr("id", "arrowhead-standard")
                    .attr("viewBox", "-10 -5 10 10").attr("refX", 20).attr("refY", 0).attr("orient", "auto")
                    .attr("markerWidth", 8).attr("markerHeight", 8)
                    .append("path").attr("d", "M -10,-5 L 0,0 L -10,5 Z").attr('fill', '#999');

                defs.append("marker")
                    .attr("id", "arrowhead-selected")
                    .attr("viewBox", "-10 -5 10 10").attr("refX", 20).attr("refY", 0).attr("orient", "auto")
                    .attr("markerWidth", 10).attr("markerHeight", 10)
                    .append("path").attr("d", "M -10,-5 L 0,0 L -10,5 Z").attr('fill', '#e58e26');
                
                const visibleLinks = root.links().filter(d => !d.source.data.isVirtual);

                const link = g.append("g")
                    .attr("class", "links")
                    .selectAll("path")
                    .data(visibleLinks)
                    .enter().append("path")
                    .attr("class", "link")
                    .attr("fill", "none")
                    .style("stroke", d => {
                        // Check if this link is on the SINGLE best path
                        if (window.allBestPaths && window.allBestPaths.length > 0) {
                            // FORCE SINGLE PATH: Only check the first path
                            const singlePath = window.allBestPaths[0];
                            if (singlePath.pathIds.has(d.source.data.id) && singlePath.pathIds.has(d.target.data.id)) {
                                // Additional safety: ensure both nodes are correct before highlighting
                                const sourceCorrect = d.source.data.correct === true || d.source.data.correct === 'true' || d.source.data.correct === 1;
                                const targetCorrect = d.target.data.correct === true || d.target.data.correct === 'true' || d.target.data.correct === 1;
                                if (sourceCorrect && targetCorrect) {
                                    return '#ff8c00'; // Always use orange for the single path
                                } else {
                                    console.log("[DEBUG] Blocking orange highlight for link with incorrect node(s):", d.source.data.id.substring(0, 8), "->", d.target.data.id.substring(0, 8));
                                    return "#999";
                                }
                            }
                        }
                        return "#999"; // Default color for non-best paths
                    })
                    .style("stroke-width", d => {
                        // Check if this link is on any best path
                        if (window.allBestPaths && window.allBestPaths.length > 0) {
                            for (let path of window.allBestPaths) {
                                if (path.pathIds.has(d.source.data.id) && path.pathIds.has(d.target.data.id)) {
                                    return 4;
                                }
                            }
                        }
                        return 1.5; // Default width
                    })
                    .style("stroke-opacity", d => {
                        // Check if this link is on any best path
                        if (window.allBestPaths && window.allBestPaths.length > 0) {
                            for (let path of window.allBestPaths) {
                                if (path.pathIds.has(d.source.data.id) && path.pathIds.has(d.target.data.id)) {
                                    return 1;
                                }
                            }
                        }
                        return 0.8; // Default opacity
                    })
                    .attr("d", d3.linkVertical()
                        .x(d => d.x)
                        .y(d => d.y)
                    );

                const visibleNodes = root.descendants().filter(d => !d.data.isVirtual);
                
                const node = g.append("g").attr("class", "nodes").selectAll("g").data(visibleNodes)
                    .enter().append("g")
                    .attr("class", d => d.data.id === window.bestNodeId ? "node best-node" : "node")
                    .attr("transform", d => `translate(${d.x},${d.y})`)
                    .on('click', (event, d) => {
                        d3.selectAll('.node').classed('selected', false);
                        d3.select(event.currentTarget).classed('selected', true);
                        
                        const selectedNodeId = d.data.id;
                        const selectedAncestors = new Set(d.ancestors().map(n => n.data.id));

                        // Update link styles - FORCE SINGLE PATH
                        link.style("stroke", l => {
                                if (window.allBestPaths && window.allBestPaths.length > 0) {
                                    // FORCE SINGLE PATH: Only check the first path
                                    const singlePath = window.allBestPaths[0];
                                    if (singlePath.pathIds.has(l.source.data.id) && singlePath.pathIds.has(l.target.data.id)) {
                                        return '#ff8c00'; // Always orange for single path
                                    }
                                }
                                
                                // Check if this link is on the selected path (non-best paths)
                                const onSelectedPath = selectedAncestors.has(l.source.data.id) && selectedAncestors.has(l.target.data.id);
                                if (onSelectedPath) {
                                    return "gold";
                                }
                                return "#999";
                            })
                            .style("stroke-width", l => {
                                // Check if this link is on any best path
                                if (window.allBestPaths && window.allBestPaths.length > 0) {
                                    for (let path of window.allBestPaths) {
                                        if (path.pathIds.has(l.source.data.id) && path.pathIds.has(l.target.data.id)) {
                                            return 4;
                                        }
                                    }
                                }
                                // Check if this link is on the selected path
                                const onSelectedPath = selectedAncestors.has(l.source.data.id) && selectedAncestors.has(l.target.data.id);
                                return onSelectedPath ? 5 : 1.5;
                            })
                            .style("stroke-opacity", l => {
                                // Check if this link is on any best path or selected path
                                if (window.allBestPaths && window.allBestPaths.length > 0) {
                                    for (let path of window.allBestPaths) {
                                        if (path.pathIds.has(l.source.data.id) && path.pathIds.has(l.target.data.id)) {
                                            return 1;
                                        }
                                    }
                                }
                                const onSelectedPath = selectedAncestors.has(l.source.data.id) && selectedAncestors.has(l.target.data.id);
                                return onSelectedPath ? 1 : 0.8;
                            });
                        
                        // Update node styles - FORCE SINGLE PATH
                        node.selectAll('path')
                            .style("stroke", n => {
                                if (window.allBestPaths && window.allBestPaths.length > 0) {
                                    // FORCE SINGLE PATH: Only check the first path
                                    const singlePath = window.allBestPaths[0];
                                    if (singlePath.pathIds.has(n.data.id)) {
                                        return '#ff8c00'; // Always orange for single path
                                    }
                                }
                                return "#000"; // Default stroke
                            })
                            .style("stroke-width", n => {
                                // Check if this node is on any best path
                                if (window.allBestPaths && window.allBestPaths.length > 0) {
                                    for (let path of window.allBestPaths) {
                                        if (path.pathIds.has(n.data.id)) {
                                            return 4;
                                        }
                                    }
                                }
                                return 3; // Default width
                            })
                            .style("filter", n => n.data.id === window.bestNodeId ? "drop-shadow(0px 3px 6px rgba(255, 140, 0, 0.5))" : "drop-shadow(0px 2px 4px rgba(0,0,0,0.2))");
                        
                        node.filter('.selected')
                            .select('path')
                            .style("stroke", "#e58e26").style("stroke-width", 4)
                            .style("filter", "drop-shadow(0px 3px 8px rgba(229, 130, 38, 0.6))");

                        displayNodeDetails(d.data);
                        document.querySelector('.tab[data-tab="agent-code"]').click();
                    })
                    .on('mouseover', (event, d) => {
                        const tooltip = d3.select("body").append("div")
                            .attr("class", "node-tooltip")
                            .style("opacity", 0);

                        tooltip.transition().duration(200).style("opacity", 1);
                        
                        const patchName = d.data.metadata.patch_name || 'unnamed';
                        const score = formatScore(d.data.combined_score);
                        const patchType = d.data.metadata.patch_type || 'N/A';
                        const islandIdx = d.data.island_idx !== null && d.data.island_idx !== undefined ? d.data.island_idx : 'N/A';
                        
                        if (d.data.isUnifiedRoot) {
                            tooltip.html(`
                                <strong style="color: #9b59b6; font-size: 13px;">‚≠ê ${patchName}</strong><br>
                                <strong>Type:</strong> Unified Root<br>
                                <strong>Score:</strong> ${score}<br>
                                <em>Common origin for all islands</em>
                            `);
                        } else {
                            tooltip.html(`
                                <strong style="color: #58a6ff; font-size: 13px;">${patchName}</strong><br>
                                <strong>Score:</strong> ${score}<br>
                                <strong>Type:</strong> ${patchType}<br>
                                <strong>Island:</strong> ${islandIdx}
                            `);
                        }
                        
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 10) + "px");
                    })
                    .on('mousemove', (event, d) => {
                        d3.select(".node-tooltip")
                            .style("left", (event.pageX + 15) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on('mouseout', (event, d) => {
                        d3.selectAll(".node-tooltip").transition().duration(200).style("opacity", 0).remove();
                    });

                node.append("path")
                    .attr("d", d => {
                        // Use a star shape for the unified root
                        if (d.data.isUnifiedRoot) {
                            symbol.type(d3.symbolStar).size(750);
                        } else {
                            symbol.type(getShape(d.data.metadata.patch_type));
                        }
                        return symbol();
                    })
                    .style("fill", d => {
                        if (d.data.isUnifiedRoot) return '#9b59b6'; // Purple for unified root
                        if (d.data.id === window.bestNodeId) return '#ffd700';
                        if (!d.data.correct) return '#e74c3c';
                        const score = d.data.combined_score;
                        if (score !== null && !isNaN(score)) {
                            return colorScale(score);
                        }
                        return '#3498db';
                    })
                    .style("stroke", d => {
                        // Check if this node is on the SINGLE best path
                        if (window.allBestPaths && window.allBestPaths.length > 0) {
                            // FORCE SINGLE PATH: Only check the first path
                            const singlePath = window.allBestPaths[0];
                            if (singlePath.pathIds.has(d.data.id)) {
                                // Additional safety: ensure node is correct before highlighting
                                const nodeCorrect = d.data.correct === true || d.data.correct === 'true' || d.data.correct === 1;
                                if (nodeCorrect) {
                                    return '#ff8c00'; // Always use orange for the single path
                                } else {
                                    console.log("[DEBUG] Blocking orange highlight for incorrect node:", d.data.id.substring(0, 8), "correct:", d.data.correct);
                                    return "#000";
                                }
                            }
                        }
                        return "#000"; // Default stroke
                    })
                    .style("stroke-width", d => {
                        // Check if this node is on any best path
                        if (window.allBestPaths && window.allBestPaths.length > 0) {
                            for (let path of window.allBestPaths) {
                                if (path.pathIds.has(d.data.id)) {
                                    return 4;
                                }
                            }
                        }
                        return 3; // Default width
                    })
                    .style("filter", d => d.data.id === window.bestNodeId ? "drop-shadow(0px 3px 6px rgba(255, 140, 0, 0.5))" : "drop-shadow(0px 2px 4px rgba(0,0,0,0.2))");

                // Add animated rings for the SINGLE best node
                if (window.allBestPaths && window.allBestPaths.length > 0) {
                    // FORCE SINGLE PATH: Only process the first path, always use orange
                    const singlePath = window.allBestPaths[0];
                    [singlePath].forEach((path, index) => {
                        const pathColor = '#ff8c00'; // Always orange for single path
                        const shadowColor = 'rgba(255, 140, 0, 0.3)'; // Always orange shadow
                        
                        node.filter(d => d.data.id === path.nodeId)
                            .insert("circle", ":first-child")
                            .attr("r", 24)
                            .style("fill", "none")
                            .style("stroke", pathColor)
                            .style("stroke-width", 3)
                            .style("stroke-dasharray", "5,3")
                            .style("opacity", 0.8)
                            .style("filter", `drop-shadow(0px 2px 4px ${shadowColor})`)
                            .style("animation", "pulse 2s infinite");
                    });
                } else {
                    // Fallback: add ring for the single best node if no paths detected
                    node.filter(d => d.data.id === window.bestNodeId)
                        .insert("circle", ":first-child")
                        .attr("r", 24).style("fill", "none").style("stroke", "#ff8c00")
                        .style("stroke-width", 3).style("stroke-dasharray", "5,3").style("opacity", 0.8)
                        .style("filter", "drop-shadow(0px 2px 4px rgba(255, 140, 0, 0.3))")
                        .style("animation", "pulse 2s infinite");
                }

                node.append("text")
                    .attr("dy", "0.75em")
                    .attr("text-anchor", "middle")
                    .style("font-size", "24px").style("font-weight", "bold").style("fill", "white")
                    .style("pointer-events", "none")
                    .text(d => d.data.generation);

                // Add island index indicator with background
                const islandNodes = node.filter(d => d.data.island_idx !== null && d.data.island_idx !== undefined);
                
                // Add background rectangle for island text
                islandNodes.append("rect")
                    .attr("x", -15)
                    .attr("y", -35)
                    .attr("width", 30)
                    .attr("height", 20)
                    .attr("rx", 4)
                    .style("fill", d => islandColorScale(d.data.island_idx))
                    .style("stroke", "#2c3e50")
                    .style("stroke-width", "1px")
                    .style("pointer-events", "none");
                
                // Add island text (centered in the rectangle)
                islandNodes.append("text")
                    .attr("x", 0)
                    .attr("y", -15)  // Adjusted for larger rectangle
                    .attr("text-anchor", "middle")
                    .attr("dy", "0.35em")  // Better vertical centering
                    .style("font-size", "17px")
                    .style("font-weight", "bold")
                    .style("fill", "white")
                    .style("pointer-events", "none")
                    .text(d => `I${d.data.island_idx}`);

                if (window.pendingNodeSelectionId) {
                    const nodeIdToSelect = window.pendingNodeSelectionId;
                    window.pendingNodeSelectionId = null; // Clear it immediately

                    // Use a short timeout to ensure D3 has finished DOM manipulations
                    setTimeout(() => {
                        const nodeElement = d3.selectAll('.node')
                            .filter(d => d.data.id === nodeIdToSelect)
                            .node();
                        
                        if (nodeElement) {
                            console.log('[DEBUG] Applying pending node selection:', nodeIdToSelect);
                            nodeElement.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                        } else {
                            console.warn('[DEBUG] Could not find node for pending selection:', nodeIdToSelect);
                        }
                    }, 100);
                }
                

            } catch (error) {
                console.error("[DEBUG] Error in renderGraph:", error);
            }
        }

        function updateShapeLegend(shapeMap, usedPatchTypes, usedIslands = [], islandColorScale = null) {
            const legendContainer = d3.select("#shape-legend");
            legendContainer.selectAll(".shape-legend-item").remove(); // Clear previous items

            const legendSymbol = d3.symbol().size(64);

            // Add patch type legend items
            for (const type in shapeMap) {
                if (usedPatchTypes.includes(type)) {
                    const legendItem = legendContainer.append("div")
                        .attr("class", "shape-legend-item")
                        .style("display", "flex")
                        .style("align-items", "center");

                    const svg = legendItem.append("svg")
                        .attr("width", 16)
                        .attr("height", 16)
                        .style("margin-right", "5px");

                    legendSymbol.type(shapeMap[type]);

                    svg.append("path")
                        .attr("d", legendSymbol)
                        .attr("class", "legend-shape")
                        .attr("transform", "translate(8, 8)");

                    legendItem.append("span").text(type);
                }
            }

            // Add island legend items to the dedicated islands legend container
            const islandsLegendContainer = d3.select("#islands-legend-items");
            islandsLegendContainer.selectAll(".island-legend-item").remove(); // Clear previous island items
            
            if (usedIslands.length > 0 && islandColorScale) {
                // Show the islands legend section
                d3.select("#islands-legend").style("display", "block");
                
                usedIslands.forEach(islandIdx => {
                    const legendItem = islandsLegendContainer.append("div")
                        .attr("class", "island-legend-item")
                        .style("display", "flex")
                        .style("align-items", "center");

                    const svg = legendItem.append("svg")
                        .attr("width", 16)
                        .attr("height", 16)
                        .style("margin-right", "5px");

                    // Create a small colored rectangle for island
                    svg.append("rect")
                        .attr("x", 2)
                        .attr("y", 4)
                        .attr("width", 12)
                        .attr("height", 8)
                        .attr("rx", 2)
                        .style("fill", islandColorScale(islandIdx))
                        .style("stroke", "#2c3e50")
                        .style("stroke-width", "1px");

                    // Add small text inside the rectangle
                    svg.append("text")
                        .attr("x", 8)
                        .attr("y", 8)
                        .attr("text-anchor", "middle")
                        .attr("dy", "0.35em")
                        .style("font-size", "8px")
                        .style("font-weight", "bold")
                        .style("fill", "white")
                        .text(`I${islandIdx}`);

                    legendItem.append("span").text(`Island ${islandIdx}`);
                });
            } else {
                // Hide the islands legend section if no islands
                d3.select("#islands-legend").style("display", "none");
            }
        }

        // Global variables for chart data and instances
        let cumulativeMaxScores = [];
        let cumulativeMeanScores = [];
        let cumulativeTotalCosts = [];
        let cumulativeApiCosts = [];
        let cumulativeEmbedCosts = [];
        let cumulativeNoveltyCosts = [];
        let cumulativeMetaCosts = [];
        let generationCosts = [];
        let generationEmbedCosts = [];
        let generationNoveltyCosts = [];
        let generationMetaCosts = [];
        let individualScores = []; // Added array to store individual performance scores
        let bestPathScores = [];
        let scoreChartInstance = null;
        let costChartInstance = null;
        
        // Initialize the Meta Info tab with default content
        function initializeMetaInfoTab() {
            document.getElementById("agent-info").innerHTML = `
                <h3>Meta Information</h3>
                <p id="meta-placeholder" class="placeholder-text">Loading data... Select a CSV file to visualize metrics.</p>
                
                <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px;">
                    <div style="flex: 1; min-width: 200px; background-color: #f8f9fa; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <h4 style="margin-top: 0;">Overview</h4>
                        <p><strong>Total Generations:</strong> <span id="meta-total-generations">N/A</span></p>
                        <p><strong>Correct:</strong> <span id="meta-correct-programs">N/A</span></p>
                        <p><strong>Total Cost:</strong> <span id="meta-total-cost">N/A</span></p>
                        <p><strong>Avg Cost/Program:</strong> <span id="meta-cost-avg">N/A</span></p>
                    </div>
                    
                    <div style="flex: 1; min-width: 200px; background-color: #f8f9fa; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <h4 style="margin-top: 0;">Best Solution</h4>
                        <p><strong>Best Score:</strong> <span id="meta-best-score" class="metric-good">N/A</span></p>
                        <p><strong>Name:</strong> <span id="meta-best-agent-name" class="truncated-name-span">N/A</span></p>
                        <p><strong>Generation:</strong> <span id="meta-best-agent-gen">N/A</span></p>
                        <p><strong>Island:</strong> <span id="meta-best-agent-island">N/A</span></p>
                    </div>
                    
                    <div style="flex: 1; min-width: 200px; background-color: #f8f9fa; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <h4 style="margin-top: 0;">Cost Breakdown</h4>
                        <p><strong>Total API Cost:</strong> <span id="meta-cost-api">N/A</span></p>
                        <p><strong>Total Embedding Cost:</strong> <span id="meta-cost-embed">N/A</span></p>
                        <p><strong>Total Novelty Cost:</strong> <span id="meta-cost-novelty">N/A</span></p>
                        <p><strong>Total Meta Cost:</strong> <span id="meta-cost-meta">N/A</span></p>
                    </div>
            </div>

            <div id="selected-node-details" style="display: none;"></div>

            <div style="display: flex; flex-wrap: wrap; margin-top: 20px;">
                <div style="width: 100%; margin-bottom: 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0;">Performance Score Progression</h4>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="display: flex; align-items: center; gap: 5px; font-size: 14px;">
                                <label for="score-y-min">Min:</label>
                                <input type="number" id="score-y-min" style="width: 70px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;" placeholder="Auto" oninput="setTimeout(() => createCharts(null), 10)" step="0.1">
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; font-size: 14px;">
                                <label for="score-y-max">Max:</label>
                                <input type="number" id="score-y-max" style="width: 70px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;" placeholder="Auto" oninput="setTimeout(() => createCharts(null), 10)" step="0.1">
                            </div>
                        </div>
                    </div>
                    <div style="height: 250px; position: relative;">
                        <canvas id="scoreChart" width="400" height="250"></canvas>
                    </div>
                </div>
                <div style="width: 100%; margin-bottom: 20px;">
                    <h4 style="margin-top: 15px;">Cumulative Cost Breakdown</h4>
                    <div style="height: 250px; position: relative;">
                        <canvas id="costChart" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>
            `;
        }
        // Update the Meta Info tab with global data
        function updateMetaInfoTab(data) {
            console.log("[DEBUG] Updating Meta Info tab with data");

            // First, ensure the tab is set up with the correct HTML structure
            initializeMetaInfoTab();

            // Ensure metric arrays are initialized for this update cycle
            cumulativeMaxScores = [];
            cumulativeMeanScores = [];
            cumulativeTotalCosts = [];
            cumulativeApiCosts = [];
            cumulativeEmbedCosts = [];
            cumulativeNoveltyCosts = [];
            cumulativeMetaCosts = [];
            generationCosts = [];
            generationEmbedCosts = [];
            generationNoveltyCosts = [];
            generationMetaCosts = [];
            individualScores = []; // Reset individual scores array
            bestPathScores = [];
            let allScoresForMeanCalc = [];
            
            // Hide placeholder
            const placeholder = document.getElementById("meta-placeholder");
            if (placeholder) placeholder.style.display = 'none';
            
            // Calculate overall statistics
            const generations = [...new Set(data.map(d => d.generation))].sort((a, b) => a - b);
            const numGenerations = generations.length;
            const numAgents = data.length;
            
            // Filter valid scores
            const validScores = data.filter(d => d.correct)
                .map(d => d.combined_score)
                .filter(s => s !== null && s !== undefined && !isNaN(parseFloat(s)))
                .map(s => parseFloat(s));
            
            // Determine best score based on max selection
            const bestScore = validScores.length > 0 ? 
                Math.max(...validScores) : 'N/A';
            
            // Find the agent with the best score
            let bestAgent = null;
            if (validScores.length > 0 && typeof bestScore === 'number') {
                bestAgent = data.find(d => parseFloat(d.combined_score) === bestScore);
            }
            
            if (bestAgent) {
                const nodeMap = new Map(data.map(node => [node.id, node]));
                const path = [];
                let currentNode = bestAgent;
                while (currentNode) {
                    path.unshift(currentNode);
                    currentNode = nodeMap.get(currentNode.parent_id);
                }
                bestPathScores = path.map(node => ({
                    x: node.generation,
                    y: node.combined_score,
                    id: node.id,
                    agent_name: node.metadata.patch_name || 'unnamed'
                }));
            }

            // Calculate total costs
            let totalApiCostNum = 0;
            let totalEmbedCostNum = 0;
            let totalNoveltyCostNum = 0;
            let totalMetaCostNum = 0;
            data.forEach(d => {
                const apiCost = d.metadata?.api_costs ? parseFloat(d.metadata.api_costs) : 0;
                const embedCost = d.metadata?.embed_cost ? parseFloat(d.metadata.embed_cost) : 0;
                const noveltyCost = d.metadata?.novelty_cost ? parseFloat(d.metadata.novelty_cost) : 0;
                const metaCost = d.metadata?.meta_cost ? parseFloat(d.metadata.meta_cost) : 0;
                totalApiCostNum += isNaN(apiCost) ? 0 : apiCost;
                totalEmbedCostNum += isNaN(embedCost) ? 0 : embedCost;
                totalNoveltyCostNum += isNaN(noveltyCost) ? 0 : noveltyCost;
                totalMetaCostNum += isNaN(metaCost) ? 0 : metaCost;
            });
            const totalCombinedCost = totalApiCostNum + totalEmbedCostNum + totalNoveltyCostNum + totalMetaCostNum;

            // Calculate cumulative minimum and maximum scores for each generation
            let currentMax = -Infinity;
            
            generations.forEach(genId => {
                const genData = data.filter(d => d.generation === genId);
                const genScores = genData.filter(d => d.correct).map(d => {
                    const score = d.combined_score;
                    if (score === null || score === undefined) {
                        return null;
                    }
                    const numScore = typeof score === 'string' ? parseFloat(score) : score;
                    return isNaN(numScore) ? null : numScore;
                })
                .filter(s => s !== null);
                
                // Add individual data points for each valid score in this generation
                genData.forEach(d => {
                    const score = d.combined_score;
                    if (score !== null && score !== undefined && d.correct) {
                        const numScore = typeof score === 'string' ? parseFloat(score) : score;
                        if (!isNaN(numScore)) {
                            individualScores.push({
                                x: genId,
                                y: numScore,
                                id: d.id,
                                agent_name: d.metadata?.patch_name || 'unnamed',
                                iter_id: d.iter_id
                            });
                        }
                    }
                });
                
                if (genScores.length > 0) {
                    const maxScore = Math.max(...genScores);
                    currentMax = Math.max(currentMax, maxScore);
                    allScoresForMeanCalc.push(...genScores);
                }
                
                if (currentMax !== -Infinity) {
                    cumulativeMaxScores.push({ 
                        x: genId, 
                        y: currentMax
                    });
                }

                if (allScoresForMeanCalc.length > 0) {
                    const meanScore = allScoresForMeanCalc.reduce((a, b) => a + b, 0) / allScoresForMeanCalc.length;
                    cumulativeMeanScores.push({
                        x: genId,
                        y: meanScore
                    });
                }
            });
            
            // Calculate cumulative costs using api_costs, embed_cost, novelty_cost, and meta_cost from metadata
            let cumulativeCost = 0;
            let cumulativeApiCost = 0;
            let cumulativeEmbedCost = 0;
            let cumulativeNoveltyCost = 0;
            let cumulativeMetaCost = 0;
            
            generations.forEach(genId => {
                const genData = data.filter(d => d.generation === genId);
                let genCost = 0;
                let genEmbedCost = 0;
                let genNoveltyCost = 0;
                let genMetaCost = 0;
                
                genData.forEach(d => {
                    const cost = d.metadata && d.metadata.api_costs ? parseFloat(d.metadata.api_costs) : 0;
                    const embedCost = d.metadata && d.metadata.embed_cost ? parseFloat(d.metadata.embed_cost) : 0;
                    const noveltyCost = d.metadata && d.metadata.novelty_cost ? parseFloat(d.metadata.novelty_cost) : 0;
                    const metaCost = d.metadata && d.metadata.meta_cost ? parseFloat(d.metadata.meta_cost) : 0;
                    genCost += isNaN(cost) ? 0 : cost;
                    genEmbedCost += isNaN(embedCost) ? 0 : embedCost;
                    genNoveltyCost += isNaN(noveltyCost) ? 0 : noveltyCost;
                    genMetaCost += isNaN(metaCost) ? 0 : metaCost;
                    
                    // Debug logging for first few items
                    if (genData.indexOf(d) < 2) {
                        console.log("[DEBUG] Gen", genId, "Program:", d.id.substring(0, 8), 
                                  "API Cost:", cost, "Embed Cost:", embedCost, "Novelty Cost:", noveltyCost, "Meta Cost:", metaCost,
                                  "Metadata keys:", d.metadata ? Object.keys(d.metadata) : 'no metadata');
                    }
                });
                
                console.log("[DEBUG] Generation", genId, "Total API Cost:", genCost, "Total Embed Cost:", genEmbedCost, "Total Novelty Cost:", genNoveltyCost, "Total Meta Cost:", genMetaCost);
                
                generationCosts.push({
                    x: genId,
                    y: genCost
                });

                generationEmbedCosts.push({
                    x: genId,
                    y: genEmbedCost
                });

                generationNoveltyCosts.push({
                    x: genId,
                    y: genNoveltyCost
                });

                generationMetaCosts.push({
                    x: genId,
                    y: genMetaCost
                });

                cumulativeApiCost += genCost;
                cumulativeEmbedCost += genEmbedCost;
                cumulativeNoveltyCost += genNoveltyCost;
                cumulativeMetaCost += genMetaCost;
                cumulativeCost += (genCost + genEmbedCost + genNoveltyCost + genMetaCost);
                
                cumulativeApiCosts.push({
                    x: genId,
                    y: cumulativeApiCost
                });
                
                cumulativeEmbedCosts.push({
                    x: genId,
                    y: cumulativeEmbedCost
                });

                cumulativeNoveltyCosts.push({
                    x: genId,
                    y: cumulativeNoveltyCost
                });

                cumulativeMetaCosts.push({
                    x: genId,
                    y: cumulativeMetaCost
                });
                
                cumulativeTotalCosts.push({
                    x: genId,
                    y: cumulativeCost
                });
            });
            
            // Clear other cost arrays as they are no longer used
            cumulativeAgentCosts = [];
            cumulativeSolutionCosts = [];
            
            // Add detailed logging before updating DOM
            console.log("[DEBUG] Calculated Stats:", {
                numGenerations,
                numAgents,
                totalCost: totalApiCostNum.toFixed(2),
                bestScore: typeof bestScore === 'number' ? bestScore.toFixed(6) : bestScore,
                bestAgentName: bestAgent ? bestAgent.agent_name : 'N/A',
                bestAgentGen: bestAgent ? bestAgent.gen_id : 'N/A',
                bestAgentIter: bestAgent ? bestAgent.iter_id : 'N/A',
            });

            // Update Overview section
            document.getElementById('meta-total-generations').textContent = numGenerations;
            
            // Calculate and update success rate (correct programs / total agents)
            const correctAgents = data.filter(d => d.correct).length;
            const correctRate = numAgents > 0 ? (correctAgents / numAgents) * 100 : 0;
            document.getElementById('meta-correct-programs').textContent = 
                `${correctRate.toFixed(1)}% (${correctAgents}/${numAgents})`;
            
            document.getElementById('meta-total-cost').textContent = '$' + totalCombinedCost.toFixed(4);

            // Update Best Solution section
            const bestScoreEl = document.getElementById('meta-best-score');
            bestScoreEl.textContent = typeof bestScore === 'number' ? bestScore.toFixed(6) : bestScore;
            bestScoreEl.className = typeof bestScore === 'number' ? 'metric-good' : '';
            
            const bestAgentName = bestAgent ? (bestAgent.metadata.patch_name || 'unnamed') : 'N/A';
            document.getElementById('meta-best-agent-name').textContent = bestAgentName;
            document.getElementById('meta-best-agent-gen').textContent = bestAgent ? bestAgent.generation : 'N/A';
            document.getElementById('meta-best-agent-island').textContent = bestAgent ? bestAgent.island_idx : 'N/A';

            // Update Cost Breakdown section
            document.getElementById('meta-cost-api').textContent = '$' + totalApiCostNum.toFixed(4);
            document.getElementById('meta-cost-embed').textContent = '$' + totalEmbedCostNum.toFixed(4);
            document.getElementById('meta-cost-novelty').textContent = '$' + totalNoveltyCostNum.toFixed(4);
            document.getElementById('meta-cost-meta').textContent = '$' + totalMetaCostNum.toFixed(4);
            document.getElementById('meta-cost-avg').textContent = numAgents > 0 ? '$' + (totalCombinedCost / numAgents).toFixed(4) : 'N/A';
            
            console.log("[DEBUG] Meta Info tab text content updated");
        }

        // Display node details in the right panel
        function displayNodeDetails(data) {
            console.log("[DEBUG] Displaying node details for:", data.agent_name, "Gen:", data.generation, "ID:", data.id);
            
            // Sync selection in the program table
            const tableBody = document.querySelector("#program-table tbody");
            if (tableBody) {
                tableBody.querySelectorAll('tr').forEach(r => r.classList.remove('selected'));
                const row = tableBody.querySelector(`tr[data-node-id="${data.id}"]`);
                if (row) {
                    row.classList.add('selected');
                }
            }
            
            // Sync selection in the best path timeline
            const bestPathContainer = document.querySelector("#best-path-container");
            if (bestPathContainer) {
                bestPathContainer.querySelectorAll('.timeline-item').forEach(i => i.classList.remove('selected'));
                const item = bestPathContainer.querySelector(`.timeline-item[data-node-id="${data.id}"]`);
                if (item) {
                    item.classList.add('selected');
                }
            }
            
            // Save state when node is selected
            saveState();
            
            const agentName = data.metadata.patch_name || data.agent_name || "unnamed_agent";
            const score = data.combined_score;
            
            // Update node summary
            document.getElementById("node-summary").innerHTML = `
                <h3>${agentName} (Gen ${data.generation})</h3>
                <p><strong>ID:</strong> <span style="font-family: monospace;">${data.id}</span></p>
                <p><strong>Parent ID:</strong> <span style="font-family: monospace;">${data.parent_id || 'None'}</span></p>
                <p><strong>Score:</strong> <span class="${getScoreClass(score)}">${formatScore(score)}</span></p>
                ${data.error ? `<p><strong>Error:</strong> <span class="metric-bad">${data.error}</span></p>` : ''}
            `;
            


            // Update charts in Meta Info tab to highlight this generation
            if (document.querySelector('.tab[data-tab="agent-info"]').classList.contains('active') && !window.isResizing) {
                createCharts(data.generation);
            }

            // --- Update Node Details Tab ---
            const nodeDetailsContainer = document.getElementById('node-details');

            let publicMetricsHtml = '';
            if (data.public_metrics && Object.keys(data.public_metrics).length > 0) {
                for (const [key, value] of Object.entries(data.public_metrics)) {
                    publicMetricsHtml += `<p><strong>${key}:</strong> ${formatScore(value)}</p>`;
                }
            } else {
                publicMetricsHtml = '<p>No public metrics available.</p>';
            }

            let privateMetricsHtml = '';
            if (data.private_metrics && Object.keys(data.private_metrics).length > 0) {
                for (const [key, value] of Object.entries(data.private_metrics)) {
                    privateMetricsHtml += `<p><strong>${key}:</strong> ${formatScore(value)}</p>`;
                }
            } else {
                privateMetricsHtml = '<p>No private metrics available.</p>';
            }

            let metadataHtml = '';
            let privateMetaFieldsHtml = '';
            
            if (data.metadata) {
                for (const [key, value] of Object.entries(data.metadata)) {
                    if (key !== 'thought' && key !== 'code_analysis_metrics' && key !== 'patch_description' && key !== 'stdout_log' && key !== 'stderr_log' && key !== 'llm_result') {
                        
                        let valueHtml;
                        if (typeof value === 'object' && value !== null) {
                            valueHtml = `<pre style="white-space: pre-wrap; word-wrap: break-word; background-color: #f6f8fa; padding: 10px; border-radius: 3px; margin-top: 5px;">${escapeHtml(JSON.stringify(value, null, 2))}</pre>`;
                            metadataHtml += `<div style="margin-bottom: 10px;"><strong>${key}:</strong>${valueHtml}</div>`;
                        } else {
                            const valueStr = String(value);
                            
                            // Check if this is one of the fields that should be moved to Private Metrics & Feedback
                            if (key === 'meta_recommendations' || key === 'novelty_explanation' || key === 'meta_summary' || key === 'meta_scratch_pad') {
                                valueHtml = `
                                    <details class="metadata-details">
                                        <summary class="metadata-summary">Expand to view</summary>
                                        <div class="metadata-value-expandable">
                                            <pre><code class="nohighlight">${escapeHtml(valueStr)}</code></pre>
                                        </div>
                                    </details>
                                `;
                                privateMetaFieldsHtml += `<p><strong>${key}:</strong>${valueHtml}</p>`;
                            } else {
                                const isLongValue = valueStr.length > 50;
                                const valueClass = isLongValue ? 'metadata-value' : '';
                                valueHtml = `<span class="${valueClass}">${escapeHtml(valueStr)}</span>`;
                                metadataHtml += `<p><strong>${key}:</strong> ${valueHtml}</p>`;
                            }
                        }
                    }
                }
            }
            
            if (!metadataHtml) {
                metadataHtml = '<p>No metadata available.</p>';
            }

            let analysisMetricsHtml = '';
            if (data.metadata && data.metadata.code_analysis_metrics) {
                analysisMetricsHtml = `
                    <table style="width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 10px;">
                        <thead>
                            <tr style="background-color: #f0f0f0;">
                                <th style="border: 1px solid #ddd; padding: 6px; text-align: left; width: 60%;">Metric</th>
                                <th style="border: 1px solid #ddd; padding: 6px; text-align: right; width: 40%;">Value</th>
                            </tr>
                        </thead>
                        <tbody>`;
                
                for (const [key, value] of Object.entries(data.metadata.code_analysis_metrics)) {
                    const formattedValue = typeof value === 'number' ? value.toFixed(2) : value;
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    
                    analysisMetricsHtml += `
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 6px;">${displayKey}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: right; font-family: monospace;">${formattedValue}</td>
                        </tr>`;
                }
                
                analysisMetricsHtml += `
                        </tbody>
                    </table>`;
            } else {
                analysisMetricsHtml = '<p>No analysis metrics.</p>';
            }

            let gridItemsHtml = `
                    <div class="details-section">
                        <h5>General</h5>
                        <p><strong>Language:</strong> ${data.language || 'N/A'}</p>
                        <p><strong>Island:</strong> ${data.island_idx !== null && data.island_idx !== undefined ? data.island_idx : 'N/A'}</p>
                        <p><strong>Timestamp:</strong> ${formatTimestamp(data.timestamp)}</p>
                        <p><strong>Correct:</strong> ${data.correct ? 'Yes' : 'No'}</p>
                        <p><strong>Children:</strong> ${data.children_count || 0}</p>
                        <p><strong>Complexity:</strong> ${data.complexity || 'N/A'}</p>
        </div>
                    <div class="details-section">
                        <h5>Performance Score</h5>
                        <p><strong>Combined Score:</strong> ${formatScore(data.combined_score)}</p>
                    </div>
                    <div class="details-section">
                        <h5>Public Metrics</h5>
                        ${publicMetricsHtml}
                    </div>
                    <div class="details-section">
                        <h5>Private Metrics & Feedback</h5>
                        ${privateMetricsHtml}
                        ${privateMetaFieldsHtml ? `
                            <div style="margin-top: 15px;">
                                <h6 style="color: #666; margin-bottom: 10px;">Meta Analysis:</h6>
                                ${privateMetaFieldsHtml}
                            </div>
                        ` : ''}
                        ${data.text_feedback && data.text_feedback.trim() ? `
                            <div style="margin-top: 15px;">
                                <details class="metadata-details">
                                    <summary class="metadata-summary" style="cursor: pointer; font-weight: bold; color: #007bff; margin-bottom: 8px;">üìù Text Feedback</summary>
                                    <div style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; border-left: 4px solid #007bff; margin-top: 8px; white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(data.text_feedback)}</div>
                                </details>
                            </div>
                        ` : '<p style="margin-top: 15px; color: #666; font-style: italic;">No text feedback available.</p>'}
                    </div>
                    <div class="details-section">
                        <h5>Metadata</h5>
                        ${metadataHtml}
                    </div>
                    <div class="details-section">
                        <h5>Code Analysis</h5>
                        ${analysisMetricsHtml}
                </div>
            `;

            if (!(data.metadata && data.metadata.thought)) {
                const patchType = data.metadata.patch_type || 'N/A';
                const patchName = data.metadata.patch_name || 'N/A';
                const patchDescription = data.metadata.patch_description || '';
                
                let patchDescriptionHtml = '';
                if (patchDescription) {
                    patchDescriptionHtml = `
                        <p><strong>Description:</strong> 
                        <span class="tooltip">
                            <span class="truncated-text">${patchDescription}</span>
                            <span class="tooltip-text">${patchDescription}</span>
                        </span>
                        </p>
                    `;
                }
                
                let inspirationHtml = '';
                const topKIds = data.top_k_inspiration_ids || [];
                const archiveIds = data.archive_inspiration_ids || [];
                const parentId = data.parent_id;
                
                if (parentId || topKIds.length > 0 || archiveIds.length > 0) {
                    inspirationHtml = `
                        <table style="width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 10px;">
                            <thead>
                                <tr style="background-color: #f0f0f0;">
                                    <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">Type</th>
                                    <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">Node ID</th>
                                    <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">Gen</th>
                                    <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">I</th>
                                    <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">Score</th>
                                </tr>
                            </thead>
                            <tbody>`;
                    
                    // Add parent node first if it exists
                    if (parentId) {
                        // Debug: Check if we're looking for a virtual root
                        if (parentId.includes('___virtual_root')) {
                            console.error("[DEBUG] Virtual root found in inspiration data! ParentId:", parentId);
                            console.error("[DEBUG] window.treeData contains virtual roots:", window.treeData.some(n => n.id.includes('___virtual_root')));
                        }
                        
                        const parentNode = window.treeData ? window.treeData.find(n => n.id === parentId) : null;
                        const gen = parentNode ? parentNode.generation : 'N/A';
                        const island = parentNode && parentNode.island_idx !== null && parentNode.island_idx !== undefined ? parentNode.island_idx : 'N/A';
                        const score = parentNode && parentNode.combined_score !== null && parentNode.combined_score !== undefined ? parentNode.combined_score.toFixed(2) : 'N/A';
                        const shortId = parentId.length > 8 ? parentId.substring(0, 8) + '...' : parentId;
                        
                        inspirationHtml += `
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 4px;">Parent</td>
                                <td style="border: 1px solid #ddd; padding: 4px; font-family: monospace; color: #007bff; cursor: pointer; text-decoration: underline;" onclick="selectNodeById('${parentId}')">${shortId}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${gen}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${island}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${score}</td>
                            </tr>`;
                    }
                    
                    topKIds.forEach(id => {
                        const node = window.treeData ? window.treeData.find(n => n.id === id) : null;
                        const gen = node ? node.generation : 'N/A';
                        const island = node && node.island_idx !== null && node.island_idx !== undefined ? node.island_idx : 'N/A';
                        const score = node && node.combined_score !== null && node.combined_score !== undefined ? node.combined_score.toFixed(2) : 'N/A';
                        const shortId = id.length > 8 ? id.substring(0, 8) + '...' : id;
                        
                        inspirationHtml += `
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 4px;">Top-K</td>
                                <td style="border: 1px solid #ddd; padding: 4px; font-family: monospace; color: #007bff; cursor: pointer; text-decoration: underline;" onclick="selectNodeById('${id}')">${shortId}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${gen}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${island}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${score}</td>
                            </tr>`;
                    });
                    
                    archiveIds.forEach(id => {
                        const node = window.treeData ? window.treeData.find(n => n.id === id) : null;
                        const gen = node ? node.generation : 'N/A';
                        const island = node && node.island_idx !== null && node.island_idx !== undefined ? node.island_idx : 'N/A';
                        const score = node && node.combined_score !== null && node.combined_score !== undefined ? node.combined_score.toFixed(2) : 'N/A';
                        const shortId = id.length > 8 ? id.substring(0, 8) + '...' : id;
                        
                        inspirationHtml += `
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 4px;">Archive</td>
                                <td style="border: 1px solid #ddd; padding: 4px; font-family: monospace; color: #007bff; cursor: pointer; text-decoration: underline;" onclick="selectNodeById('${id}')">${shortId}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${gen}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${island}</td>
                                <td style="border: 1px solid #ddd; padding: 4px;">${score}</td>
                            </tr>`;
                    });
                    
                    inspirationHtml += `
                            </tbody>
                        </table>`;
            } else {
                    inspirationHtml = '<p>No inspiration nodes available.</p>';
                }

                gridItemsHtml += `
                    <div class="details-section">
                        <h5>Patch Information</h5>
                        <div class="details-section-content">
                        <p><strong>Patch Type:</strong> ${patchType}</p>
                        <p><strong>Patch Name:</strong> ${patchName}</p>
                            ${patchDescriptionHtml}
                        </div>
                    </div>
                    <div class="details-section">
                        <h5>Inspiration</h5>
                        <div class="details-section-content">
                            ${inspirationHtml}
                    </div>
                    </div>
                `;
            }

            let migrationHistoryHtml = '';
            if (data.migration_history && data.migration_history.length > 0) {
                migrationHistoryHtml = `
                    <table style="width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 10px;">
                        <thead>
                            <tr style="background-color: #f0f0f0;">
                                <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">Gen</th>
                                <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">From</th>
                                <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">To</th>
                                <th style="border: 1px solid #ddd; padding: 4px; text-align: left;">Timestamp</th>
                            </tr>
                        </thead>
                        <tbody>`;
                
                data.migration_history.forEach(m => {
                    migrationHistoryHtml += `
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 4px;">${m.generation}</td>
                            <td style="border: 1px solid #ddd; padding: 4px;">${m.from}</td>
                            <td style="border: 1px solid #ddd; padding: 4px;">${m.to}</td>
                            <td style="border: 1px solid #ddd; padding: 4px;">${formatTimestamp(m.timestamp)}</td>
                        </tr>`;
                });
                
                migrationHistoryHtml += `</tbody></table>`;
            } else {
                migrationHistoryHtml = '<p>No migration history.</p>';
            }

            gridItemsHtml += `
                <div class="details-section">
                    <h5>Migration History</h5>
                    <div class="details-section-content">
                        ${migrationHistoryHtml}
                    </div>
                </div>
            `;

            let longContentHtml = '';
            if (data.metadata && data.metadata.thought) {
                longContentHtml += `
                    <div class="details-section" style="margin-top: 15px;">
                        <h5>Thought Process</h5>
                        <div class="markdown">${marked.parse(data.metadata.thought)}</div>
                    </div>
                `;
            }

            const nodeDetailsHtml = `
                <h4>Selected Node Details</h4>
                <div class="details-grid">
                    ${gridItemsHtml}
                </div>
                ${longContentHtml}
            `;
            
            nodeDetailsContainer.innerHTML = nodeDetailsHtml;
            
            // Update code tab
            const codeWrapper = document.getElementById("agent-code-wrapper");
            if (data.code) {
                document.querySelector('#agent-code .code-controls').style.display = 'flex';
                
                const sanitizedCode = escapeHtml(data.code);
                const lines = data.code.split('\n');
                const lineNumbers = Array.from({length: lines.length}, (_, i) => `<span>${i + 1}</span>`).join('');

                codeWrapper.innerHTML = `
                    <div class="code-container">
                        <div class="line-numbers-gutter">${lineNumbers}</div>
                        <pre><code class="language-${data.language || 'python'}">${sanitizedCode}</code></pre>
                    </div>
                `;

                // Use a slight delay to ensure the DOM has updated
                setTimeout(() => {
                    const codeBlock = codeWrapper.querySelector('code');
                    if (codeBlock) {
                        // Ensure hljs is available
                        if (typeof hljs !== 'undefined') {
                            hljs.highlightElement(codeBlock);
                        } else {
                            console.warn('highlight.js not found, skipping syntax highlighting.');
                        }
                    }
                }, 50);
            } else {
                document.querySelector('#agent-code .code-controls').style.display = 'none';
                codeWrapper.innerHTML = "<p>No code available for this node.</p>";
            }

            // Update diff tab
            const diffWrapper = document.getElementById("code-diff");
            if (data.code_diff) {
                diffWrapper.innerHTML = `<pre class="diff">${formatDiff(data.code_diff)}</pre>`;
            } else {
                diffWrapper.innerHTML = "<p>No code diff available for this node.</p>";
            }
            
            // Populate Log Output tab
            const logOutputContainer = document.getElementById("log-output");
            const stdoutLog = data.metadata?.stdout_log;
            const stderrLog = data.metadata?.stderr_log;
            let logHtml = '';

            if (stdoutLog) {
                logHtml += `<h5>STDOUT</h5><pre><code class="nohighlight">${escapeHtml(stdoutLog)}</code></pre>`;
            }

            if (stderrLog) {
                logHtml += `<h5>STDERR</h5><pre><code class="nohighlight">${escapeHtml(stderrLog)}</code></pre>`;
            }

            if (!stdoutLog && !stderrLog) {
                logHtml = "<p>No log output available for this node.</p>";
            }
            logOutputContainer.innerHTML = logHtml;

            // Populate LLM Result tab
            const llmResultContainer = document.getElementById("llm-result");
            const llmResult = data.metadata?.llm_result;
            let llmResultHtml = renderLlmResultTable(llmResult); // Try to render as a table first

            if (!llmResultHtml) {
                // Fallback to pretty-printing the whole object
                if (llmResult && typeof llmResult === 'object') {
                    llmResultHtml = `<pre style="white-space: pre-wrap; word-wrap: break-word; background-color: #f6f8fa; padding: 10px; border-radius: 3px;">${escapeHtml(JSON.stringify(llmResult, null, 2))}</pre>`;
                } else if (llmResult) {
                    llmResultHtml = `<pre><code class="nohighlight">${escapeHtml(String(llmResult))}</code></pre>`;
                } else {
                    llmResultHtml = "<p>No LLM result available for this node.</p>";
                }
            }
            llmResultContainer.innerHTML = llmResultHtml;

            // Apply syntax highlighting to code blocks
            document.querySelectorAll('pre code:not(.nohighlight)').forEach((block) => {
                hljs.highlightElement(block);
            });
        }
        
        function renderLlmResultTable(llmResult) {
            if (!llmResult || typeof llmResult !== 'object' || Array.isArray(llmResult) || Object.keys(llmResult).length === 0) {
                return null; // Not a non-empty object
            }

            const expandableKeys = ['content', 'msg', 'system_msg', 'new_msg_history', 'thought'];
            let html = '<table class="llm-result-table"><tbody>';

            for (const [key, value] of Object.entries(llmResult)) {
                html += `<tr><th>${escapeHtml(key)}</th><td>`;

                let contentHtml;
                if (typeof value === 'object' && value !== null) {
                    // Pretty-print nested objects/arrays as JSON
                    contentHtml = `<pre><code class="language-json">${escapeHtml(JSON.stringify(value, null, 2))}</code></pre>`;
                } else {
                    const valueStr = String(value);
                    // Use <pre> to preserve all formatting of string values
                    contentHtml = `<pre><code class="nohighlight">${escapeHtml(valueStr)}</code></pre>`;
                }
                
                if (expandableKeys.includes(key)) {
                    html += `
                        <details class="llm-result-details">
                            <summary class="llm-result-summary">Expand to view</summary>
                            <div class="llm-result-value">
                                ${contentHtml}
                            </div>
                        </details>
                    `;
                } else {
                    html += contentHtml;
                }

                html += `</td></tr>`;
            }

            html += '</tbody></table>';
            return html;
        }

        // Helper function to escape HTML content to prevent XSS and formatting issues
        function escapeHtml(text) {
            if (!text) return '';
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }



        function formatDiff(diffText) {
            if (!diffText) return '';
            return diffText.split('\n').map(line => {
                const escapedLine = escapeHtml(line);
                if (line.startsWith('+') && !line.startsWith('+++')) {
                    return `<span class="diff-line added">${escapedLine}</span>`;
                } else if (line.startsWith('-') && !line.startsWith('---')) {
                    return `<span class="diff-line removed">${escapedLine}</span>`;
                } else if (line.startsWith('@@')) {
                    return `<span class="diff-line" style="color: #6a737d; background: #f1f8ff;">${escapedLine}</span>`;
                }
                return `<span class="diff-line">${escapedLine}</span>`;
            }).join('');
        }

        // Get CSS class for score display
        function getScoreClass(score) {
            if (score === null || score === undefined) {
                return "metric-bad";
            }
            return "metric-good";
        }

        // Format score for display
        function formatScore(score) {
            if (score === null || score === undefined) {
                return "N/A";
            }
            
            // Convert to number if it's a string
            const numScore = typeof score === 'string' ? parseFloat(score) : score;
            
            // Check if it's a valid number
            if (typeof numScore === 'number' && !isNaN(numScore)) {
                return numScore.toFixed(6);
            } else {
                // Return the original value as string if it's not a valid number
                return String(score);
            }
        }
        // Create charts for the Meta Info tab
        function createCharts(currentGenId) {
            console.log("[DEBUG] Creating charts, currentGenId:", currentGenId);
            
            // Skip chart creation during panel resizing
            if (window.isResizing) {
                console.log("[DEBUG] Skipping chart creation during resize");
                return;
            }
            
            try {
                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.error("[DEBUG] Chart.js is not loaded!");
                    return;
                }
                
                // Also update the best solution panel when chart type changes
                if (!currentGenId) {
                    // Get all available data
                    const allData = window.treeData || [];
                    if (allData.length > 0) {
                        updateBestSolutionPanel(allData);
                    }
                }
                
                // Get canvas elements
                const scoreCanvas = document.getElementById('scoreChart');
                const costCanvas = document.getElementById('costChart');
                
                if (!scoreCanvas || !costCanvas) {
                    console.error("[DEBUG] Canvas elements not found!");
                    return;
                }
                
                // Ensure canvas is visible and properly sized before attempting to draw
                if (scoreCanvas.offsetWidth === 0 || costCanvas.offsetWidth === 0) {
                    console.error("[DEBUG] Canvas has zero width, tab may not be visible");
                    // Force redraw after a short delay to allow DOM to update
                    setTimeout(() => createCharts(currentGenId), 500);
                    return;
                }
                
                console.log("[DEBUG] Canvas dimensions - scoreChart:", 
                          scoreCanvas.offsetWidth, "x", scoreCanvas.offsetHeight,
                          "costChart:", costCanvas.offsetWidth, "x", costCanvas.offsetHeight);
                
                // Clear existing canvases to force redraw
                const clearCanvas = (canvas) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                };
                
                clearCanvas(scoreCanvas);
                clearCanvas(costCanvas);
                
                // Filter data to ensure it's valid for Chart.js
                const validScoreData = (cumulativeMaxScores || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));
                
                const validCumulativeMeanScoreData = (cumulativeMeanScores || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));
                
                const validIndividualScoreData = (individualScores || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({
                        x: item.x, 
                        y: parseFloat(item.y),
                        id: item.id,
                        agent_name: item.agent_name,
                        iter_id: item.iter_id
                    }));
                
                const validBestPathScoreData = (bestPathScores || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y), id: item.id, agent_name: item.agent_name}));

                const validAgentCostData = (cumulativeAgentCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));
                    
                const validSolutionCostData = (cumulativeSolutionCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));
                    
                const validTotalCostData = (cumulativeTotalCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));
                
                const validGenerationCostData = (generationCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));

                const validEmbedCostData = (generationEmbedCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));

                const validNoveltyCostData = (generationNoveltyCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));

                const validCumulativeApiCostData = (cumulativeApiCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));

                const validCumulativeEmbedCostData = (cumulativeEmbedCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));

                const validCumulativeNoveltyCostData = (cumulativeNoveltyCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));

                const validMetaCostData = (generationMetaCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));

                const validCumulativeMetaCostData = (cumulativeMetaCosts || [])
                    .filter(item => item.y !== null && item.y !== undefined && !isNaN(parseFloat(item.y)))
                    .map(item => ({x: item.x, y: parseFloat(item.y)}));

                console.log("[DEBUG] Valid score data points:", validScoreData.length);
                console.log("[DEBUG] Valid agent cost data points:", validAgentCostData.length);
                console.log("[DEBUG] Valid solution cost data points:", validSolutionCostData.length);
                console.log("[DEBUG] Valid total cost data points:", validTotalCostData.length);
                console.log("[DEBUG] Valid generation cost data points:", validGenerationCostData.length);
                console.log("[DEBUG] Valid embed cost data points:", validEmbedCostData.length);
                console.log("[DEBUG] Valid novelty cost data points:", validNoveltyCostData.length);
                console.log("[DEBUG] Valid meta cost data points:", validMetaCostData.length);
                
                if (validScoreData.length === 0 && validTotalCostData.length === 0) {
                    console.error("[DEBUG] No valid data for charts!");
                    // Display a message on the canvas
                    const displayNoDataMessage = (canvas, message) => {
                        const ctx = canvas.getContext('2d');
                        ctx.font = '14px Arial';
                        ctx.fillStyle = '#666';
                        ctx.textAlign = 'center';
                        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
                    };
                    
                    displayNoDataMessage(scoreCanvas, 'No valid score data available');
                    displayNoDataMessage(costCanvas, 'No valid cost data available');
                    return;
                }
                
                // Create score chart if we have valid data
                if (validScoreData.length > 0) {
                    console.log("[DEBUG] Creating score chart with", validScoreData.length, "points");
                    console.log("[DEBUG] Adding", validIndividualScoreData.length, "individual score points");
                    
                    // Read Y-axis min/max values first, for cleaner debugging
                    const yMinValue = document.getElementById('score-y-min').value;
                    const yMaxValue = document.getElementById('score-y-max').value;
                    const yMin = yMinValue !== '' ? parseFloat(yMinValue) : undefined;
                    const yMax = yMaxValue !== '' ? parseFloat(yMaxValue) : undefined;
                    
                    console.log("[DEBUG] Y-axis settings - Min:", yMin, "Max:", yMax);
                    
                    // Destroy existing chart instance if it exists
                    if (scoreChartInstance) {
                        scoreChartInstance.destroy();
                        scoreChartInstance = null;
                    }
                    
                    // Create a new chart with the updated Y-axis settings
                    scoreChartInstance = new Chart(scoreCanvas, {
                        type: 'line',
                        data: {
                            datasets: [
                                {
                                    label: 'Cumulative Max',
                                    data: validScoreData,
                                    borderColor: '#3498db',
                                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                                    borderWidth: 2,
                                    pointBackgroundColor: validScoreData.map(p => p.x === currentGenId ? '#e74c3c' : '#3498db'),
                                    pointRadius: validScoreData.map(p => p.x === currentGenId ? 6 : 4),
                                    pointHoverRadius: 8,
                                    fill: false,
                                    tension: 0.2
                                },
                                {
                                    label: 'Best Path',
                                    data: validBestPathScoreData,
                                    borderColor: '#ff8c00',
                                    backgroundColor: 'rgba(255, 140, 0, 0.1)',
                                    borderWidth: 3,
                                    pointRadius: 5,
                                    pointHoverRadius: 7,
                                    fill: false,
                                    tension: 0.2,
                                    type: 'line'
                                },
                                {
                                    label: 'Cumulative Mean',
                                    data: validCumulativeMeanScoreData,
                                    borderColor: '#2ecc71',
                                    borderWidth: 2,
                                    pointRadius: 0,
                                    fill: false,
                                    tension: 0.2
                                },
                                {
                                    label: 'Individual Solutions',
                                    data: validIndividualScoreData,
                                    type: 'scatter',
                                    backgroundColor: 'rgba(231, 76, 60, 0.5)',
                                    borderColor: 'rgba(231, 76, 60, 0.8)',
                                    pointRadius: 4,
                                    pointHoverRadius: 6,
                                    borderWidth: 1,
                                    showLine: false
                                }
                            ]
                        },
                        options: {
                            onClick: (evt, elements, chart) => {
                                if (elements.length === 0) return;
                                const firstPoint = elements[0];
                                const datasetIndex = firstPoint.datasetIndex;
                                const index = firstPoint.index;

                                if (datasetIndex === 2) { // Individual Solution Scores
                                    const dataPoint = validIndividualScoreData[index];
                                    if (dataPoint && dataPoint.id) {
                                        selectNodeById(dataPoint.id);
                                    }
                                } else if (datasetIndex === 0) { // Cumulative Max Score
                                    const generation = chart.data.datasets[datasetIndex].data[index].x;
                                    if (generation !== undefined && window.treeData) {
                                        const programsInGen = window.treeData.filter(p => p.generation === generation && p.correct);
                                        if (programsInGen.length > 0) {
                                            const bestProgramInGen = programsInGen.reduce((best, current) => {
                                                const bestScore = best.combined_score ?? -Infinity;
                                                const currentScore = current.combined_score ?? -Infinity;
                                                return currentScore > bestScore ? current : best;
                                            });
                                            if (bestProgramInGen && bestProgramInGen.id) {
                                                selectNodeById(bestProgramInGen.id);
                                            }
                                        }
                                    }
                                } else if (datasetIndex === 1) { // Best Path Score
                                    const dataPoint = validBestPathScoreData[index];
                                    if (dataPoint && dataPoint.id) {
                                        selectNodeById(dataPoint.id);
                                    }
                                }
                            },
                            onHover: (event, elements, chart) => {
                                const canvas = chart.canvas;
                                // Set cursor to pointer for any point on the chart
                                canvas.style.cursor = (elements.length > 0) ? 'pointer' : 'default';
                            },
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    title: {
                                        display: true,
                                        text: 'Generation'
                                    },
                                    ticks: {
                                        stepSize: 1
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Combined Score (‚¨Ü is better)'
                                    },
                                    min: yMin,
                                    max: yMax
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        title: (items) => {
                                            if (items.length === 0) return '';
                                            const item = items[0];
                                            if (item.datasetIndex === 2) { // Individual score dataset
                                                const dataPoint = validIndividualScoreData[item.dataIndex];
                                                if (dataPoint && dataPoint.agent_name) {
                                                    return `Generation ${item.parsed.x}, Agent: ${dataPoint.agent_name}`;
                                                }
                                            }
                                            if (item.datasetIndex === 1) { // Best path score dataset
                                                const dataPoint = validBestPathScoreData[item.dataIndex];
                                                if (dataPoint && dataPoint.agent_name) {
                                                    return `Best Path: ${dataPoint.agent_name} (Gen ${item.parsed.x})`;
                                                }
                                                return `Best Path at Generation ${item.parsed.x}`;
                                            }
                                            return `Generation ${item.parsed.x}`;
                                        },
                                        label: (item) => {
                                            if (item.datasetIndex === 2) { // Individual score dataset
                                                return `Score: ${item.parsed.y?.toFixed(6) || 'N/A'}`;
                                            }
                                            if (item.datasetIndex === 1) { // Best path score dataset
                                                const dataPoint = validBestPathScoreData[item.dataIndex];
                                                if (dataPoint && dataPoint.y !== undefined && dataPoint.y !== null) {
                                                    return `Best Path Score: ${dataPoint.y.toFixed(6)}`;
                                                }
                                                return 'Best Path Score: N/A';
                                            }
                                            return `Score: ${item.parsed.y?.toFixed(6) || 'N/A'}`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log("[DEBUG] Score chart created");
                }
                
                // Create cost chart
                if (validTotalCostData.length > 0) {
                    console.log("[DEBUG] Creating cost chart with API, embedding, and novelty costs breakdown");
                    
                    // Destroy existing chart instance if it exists
                    if (costChartInstance) {
                        costChartInstance.destroy();
                        costChartInstance = null;
                    }
                    
                    // Define a custom mixed chart type with stacked bars and a line
                    costChartInstance = new Chart(costCanvas, {
                        type: 'bar',
                        data: {
                            datasets: [
                                {
                                    label: 'Proposal/G.',
                                    data: validGenerationCostData,
                                    backgroundColor: 'rgba(52, 152, 219, 0.8)',
                                    borderColor: 'rgba(52, 152, 219, 1)',
                                    borderWidth: 1,
                                    yAxisID: 'y1'
                                },
                                {
                                    label: 'Embed/G.',
                                    data: validEmbedCostData,
                                    backgroundColor: 'rgba(155, 89, 182, 0.8)',
                                    borderColor: 'rgba(155, 89, 182, 1)',
                                    borderWidth: 1,
                                    yAxisID: 'y1'
                                },
                                {
                                    label: 'Novelty/G.',
                                    data: validNoveltyCostData,
                                    backgroundColor: 'rgba(230, 126, 34, 0.8)',
                                    borderColor: 'rgba(230, 126, 34, 1)',
                                    borderWidth: 1,
                                    yAxisID: 'y1'
                                },
                                {
                                    label: 'Meta/G.',
                                    data: validMetaCostData,
                                    backgroundColor: 'rgba(142, 68, 173, 0.8)',
                                    borderColor: 'rgba(142, 68, 173, 1)',
                                    borderWidth: 1,
                                    yAxisID: 'y1'
                                },
                                {
                                    label: '‚àë Proposal',
                                    data: validCumulativeApiCostData,
                                    type: 'line',
                                    borderColor: 'rgba(52, 152, 219, 1)',
                                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                                    borderWidth: 2,
                                    pointRadius: 3,
                                    pointHoverRadius: 6,
                                    fill: false,
                                    tension: 0.1,
                                    yAxisID: 'y'
                                },
                                {
                                    label: '‚àë Embed',
                                    data: validCumulativeEmbedCostData,
                                    type: 'line',
                                    borderColor: 'rgba(155, 89, 182, 1)',
                                    backgroundColor: 'rgba(155, 89, 182, 0.1)',
                                    borderWidth: 2,
                                    pointRadius: 3,
                                    pointHoverRadius: 6,
                                    fill: false,
                                    tension: 0.1,
                                    yAxisID: 'y'
                                },
                                {
                                    label: '‚àë Novelty',
                                    data: validCumulativeNoveltyCostData,
                                    type: 'line',
                                    borderColor: 'rgba(230, 126, 34, 1)',
                                    backgroundColor: 'rgba(230, 126, 34, 0.1)',
                                    borderWidth: 2,
                                    pointRadius: 3,
                                    pointHoverRadius: 6,
                                    fill: false,
                                    tension: 0.1,
                                    yAxisID: 'y'
                                },
                                {
                                    label: '‚àë Meta',
                                    data: validCumulativeMetaCostData,
                                    type: 'line',
                                    borderColor: 'rgba(142, 68, 173, 1)',
                                    backgroundColor: 'rgba(142, 68, 173, 0.1)',
                                    borderWidth: 2,
                                    pointRadius: 3,
                                    pointHoverRadius: 6,
                                    fill: false,
                                    tension: 0.1,
                                    yAxisID: 'y'
                                },
                                {
                                    label: '‚àë Total',
                                    data: validTotalCostData,
                                    type: 'line',
                                    borderColor: 'rgba(231, 76, 60, 1)',
                                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                                    borderWidth: 3,
                                    pointBackgroundColor: validTotalCostData.map(p => p.x === currentGenId ? 
                                        'rgba(231, 76, 60, 1)' : 'rgba(231, 76, 60, 0.7)'),
                                    pointRadius: validTotalCostData.map(p => p.x === currentGenId ? 6 : 4),
                                    pointHoverRadius: 8,
                                    fill: false,
                                    tension: 0.1,
                                    yAxisID: 'y'
                                }
                            ]
                        },
                        options: {
                            barPercentage: 0.8,
                            categoryPercentage: 1.0,
                            onClick: (evt, elements, chart) => {
                                console.log('[DEBUG] Cost chart clicked.', { elements });
                                if (elements.length === 0) return;
                                const firstPoint = elements[0];
                                const generation = chart.data.datasets[firstPoint.datasetIndex].data[firstPoint.index].x;
                                
                                if (generation !== undefined && window.treeData) {
                                    const programsInGen = window.treeData.filter(p => p.generation === generation && p.correct);
                                    if (programsInGen.length > 0) {
                                        const bestProgramInGen = programsInGen.reduce((best, current) => {
                                            const bestScore = best.combined_score ?? -Infinity;
                                            const currentScore = current.combined_score ?? -Infinity;
                                            return currentScore > bestScore ? current : best;
                                        });
                                        if (bestProgramInGen && bestProgramInGen.id) {
                                            selectNodeById(bestProgramInGen.id);
                                        }
                                    }
                                }
                            },
                            onHover: (event, elements, chart) => {
                                const canvas = chart.canvas;
                                canvas.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                            },
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    title: {
                                        display: true,
                                        text: 'Generation'
                                    },
                                    ticks: {
                                        stepSize: 1
                                    }
                                },
                                y: {
                                    type: 'linear',
                                    position: 'left',
                                    title: {
                                        display: true,
                                        text: 'Cumulative Cost ($)'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    position: 'right',
                                    title: {
                                        display: true,
                                        text: 'Per-Generation Cost ($)'
                                    },
                                    grid: {
                                        drawOnChartArea: false
                                    }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        title: (items) => `Generation ${items[0].parsed.x}`,
                                        label: (item) => {
                                            const dataset = item.dataset;
                                            const value = item.parsed.y;
                                            return `${dataset.label}: $${value.toFixed(4)}`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log("[DEBUG] Cost chart created");
                }
            } catch (error) {
                console.error("[DEBUG] Error in createCharts:", error);
            }
        }

        // Add window resize event listener to redraw the tree
        window.addEventListener('resize', function() {
            console.log("[DEBUG] Window resized");
            
            // Skip reload during manual panel resizing
            if (window.isResizing) {
                console.log("[DEBUG] Skipping window resize handler during panel resize");
                return;
            }
            
            // Debounce resize handler to prevent multiple rapid updates
            if (window.resizeTimeout) {
                clearTimeout(window.resizeTimeout);
            }
            
            window.resizeTimeout = setTimeout(function() {
                if (window.treeData) {
                    renderGraph(window.treeData);
                } else {
                    // Full reload only if necessary
                                    const resultSelect = document.getElementById('result-select');
                if (resultSelect.value) {
                    loadDatabase(resultSelect.value);
                    }
                }
            }, 300);
        });
        
        // Add specific panel resize handling to redraw the tree when panels are resized
        const observer = new ResizeObserver(() => {
            console.log("[DEBUG] Panel resized");
            const resultSelect = document.getElementById('result-select');
            
            if (resultSelect.value) {
                loadDatabase(resultSelect.value);
            }
        });
        
        // Observe the tree panel for size changes
        observer.observe(document.getElementById('tree-panel'));

        // Add this new function
        function updateBestSolutionPanel(data) {
            // Filter valid scores
            const validScores = data.filter(d => d.correct).map(d => d.combined_score)
                .filter(s => s !== null && s !== undefined && !isNaN(parseFloat(s)))
                .map(s => parseFloat(s));
            
            // Determine best score based on max selection
            const bestScore = validScores.length > 0 ? 
                Math.max(...validScores) : 'N/A';
            
            // Find the agent with the best score
            let bestAgent = null;
            if (validScores.length > 0 && typeof bestScore === 'number') {
                bestAgent = data.find(d => parseFloat(d.combined_score) === bestScore);
            }
            
            // Update Best Solution section
            const bestScoreEl = document.getElementById('meta-best-score');
            bestScoreEl.textContent = typeof bestScore === 'number' ? bestScore.toFixed(6) : bestScore;
            bestScoreEl.className = typeof bestScore === 'number' ? 'metric-good' : ''; // Adjust class if needed
            
            document.getElementById('meta-best-agent-name').textContent = bestAgent ? (bestAgent.metadata.patch_name || 'unnamed') : 'N/A';
            document.getElementById('meta-best-agent-gen').textContent = bestAgent ? bestAgent.generation : 'N/A';

            console.log("[DEBUG] Updated best solution panel with max score:", bestScore);
        }

        // Initialize the score type radio buttons
        function initializeScoreTypeListeners() {
            console.log("[DEBUG] Initializing score type radio button listeners");
            const radioButtons = document.querySelectorAll('input[name="score-type"]');
            
            // Log how many radio buttons we found
            console.log("[DEBUG] Found", radioButtons.length, "score type radio buttons");
            
            radioButtons.forEach(radio => {
                radio.addEventListener('change', function() {
                    console.log("[DEBUG] Radio button change event fired");
                    const useMinScore = document.querySelector('input[name="score-type"][value="min"]').checked;
                    console.log("[DEBUG] Score type changed to:", useMinScore ? "min" : "max");
                    
                    // Use the window.treeData directly to update the best solution panel
                    if (window.treeData && window.treeData.length > 0) {
                        console.log("[DEBUG] Tree data available, length:", window.treeData.length);
                        
                        // First update the best solution panel
                        updateBestSolutionPanel(window.treeData, useMinScore);
                        
                        // Rebuild the tree with the new best node
                        console.log("[DEBUG] Rebuilding tree with useMinScore =", useMinScore);
                        const root = buildTree(window.treeData);
                        
                        // Force a complete rebuild of the tree by clearing the container first
                        console.log("[DEBUG] Clearing and rerendering tree");
                        d3.select("#tree").html("");
                        renderTree(root, false);
                        console.log("[DEBUG] Tree rerendering complete");
                        
                        // Then redraw the charts
                        createCharts(null);
                        
                        // Update the score heatbar
                        updateScoreHeatbar();
                    } else {
                        console.error("[DEBUG] No tree data available for rerendering");
                    }
                });
            });
            
            // Update y-axis scale controls when inputs change
            const yMinInput = document.getElementById('score-y-min');
            const yMaxInput = document.getElementById('score-y-max');
            
            if (yMinInput && yMaxInput) {
                // Create a function that updates charts with a slight delay
                const updateChartsOnInput = () => {
                    console.log("[DEBUG] Y axis value changed - Triggering chart update");
                    // Use setTimeout to ensure the input value is properly processed
                    setTimeout(() => createCharts(null), 10);
                };
                
                // Use input event for real-time updates as user types
                yMinInput.addEventListener('input', updateChartsOnInput);
                yMaxInput.addEventListener('input', updateChartsOnInput);
                
                // Keep change events for completeness
                yMinInput.addEventListener('change', updateChartsOnInput);
                yMaxInput.addEventListener('change', updateChartsOnInput);
            }
            
            // Set up event listeners for island y-axis controls
            const islandYMinInput = document.getElementById('island-y-min');
            const islandYMaxInput = document.getElementById('island-y-max');
            
            if (islandYMinInput && islandYMaxInput) {
                const updateIslandChartsOnInput = () => {
                    console.log("[DEBUG] Island Y axis value changed - Triggering island visualization update");
                    // Use setTimeout to ensure the input value is properly processed
                    setTimeout(() => {
                        if (window.treeData) {
                            createIslandsVisualization(window.treeData);
                        }
                    }, 10);
                };
                
                // Use input event for real-time updates as user types
                islandYMinInput.addEventListener('input', updateIslandChartsOnInput);
                islandYMaxInput.addEventListener('input', updateIslandChartsOnInput);
                
                // Keep change events for completeness
                islandYMinInput.addEventListener('change', updateIslandChartsOnInput);
                islandYMaxInput.addEventListener('change', updateIslandChartsOnInput);
            }
        }

        // Function to handle score type changes
        function handleScoreTypeChange(isMinScore) {
            console.log("[DEBUG] handleScoreTypeChange called with isMinScore =", isMinScore);
            
            // Make sure the radio button state is synchronized
            document.querySelector('input[name="score-type"][value="min"]').checked = isMinScore;
            document.querySelector('input[name="score-type"][value="max"]').checked = !isMinScore;
            
            // If we have raw data, reprocess it completely
            if (window.rawDbData && window.rawDbData.length > 0) {
                console.log("[DEBUG] Reprocessing raw data with", window.rawDbData.length, "rows");
                
                // Simulate a complete data reload by reprocessing the data
                processData(window.rawDbData);
                return;
            }
            
            // Fallback to using the existing tree data
            if (window.treeData && window.treeData.length > 0) {
                console.log("[DEBUG] Using existing tree data with", window.treeData.length, "rows");
                
                // First update the best solution panel
                updateBestSolutionPanel(window.treeData, isMinScore);
                
                // Rebuild the tree with the new best node
                console.log("[DEBUG] Rebuilding tree with isMinScore =", isMinScore);
                const root = buildTree(window.treeData);
                
                // Force a complete rebuild of the tree by clearing the container first
                console.log("[DEBUG] Clearing and rerendering tree");
                d3.select("#tree").html("");
                renderTree(root, false);
                console.log("[DEBUG] Tree rerendering complete");
                
                // Then redraw the charts
                createCharts(null);
                
                // Update the score heatbar
                updateScoreHeatbar();
            } else if (window.currentDbPath) {
                // If all else fails but we have a file path, reload the file
                console.log("[DEBUG] Reloading file from path:", window.currentDbPath);
                loadDatabase(window.currentDbPath);
            } else {
                console.error("[DEBUG] No data available for rerendering");
            }
        }

        // Add some CSS to make the tree connections look better
        function addStylesToDom() {
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .conn-line {
                    pointer-events: none;
                    transition: all 0.3s ease;
                }
                
                .node.selected .conn-line {
                    stroke: #e58e26;
                    stroke-width: 3px;
                    stroke-opacity: 1;
                }
                
                .node:hover circle {
                    filter: brightness(1.2);
                }
                
                /* Style for connected nodes */
                .node.connected circle {
                    stroke-width: 2.5px;
                    filter: drop-shadow(0 0 2px rgba(123, 154, 196, 0.5));
                }
                
                /* Add arrow markers */
                .arrow {
                    fill: #7b9ac4;
                }
                
                /* Make node text more compact */
                .node text {
                    font-size: 10px;
                    text-anchor: middle;
                    transform: translate(0, -10px);
                    max-width: 120px;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }
                
                /* Add truncation for node labels */
                .node-label {
                    max-width: 150px;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }
            `;
            document.head.appendChild(styleElement);
        }

        // Add this new function before the createCharts function
        function updateScoreHeatbar() {
            const heatbarContainer = document.getElementById("score-heatbar");
            if (!heatbarContainer || !window.treeData) return;
            
            // Get valid scores from the data, excluding non-correct nodes
            const validScores = window.treeData
                .filter(d => d.correct && d.combined_score != null && !isNaN(parseFloat(d.combined_score)))
                .map(d => parseFloat(d.combined_score));

            if (validScores.length === 0) {
                document.getElementById("min-score").textContent = "N/A";
                document.getElementById("max-score").textContent = "N/A";
                heatbarContainer.style.background = 'none';
                return;
            }

            const minScore = Math.min(...validScores);
            const maxScore = Math.max(...validScores);
            
            document.getElementById("min-score").textContent = minScore.toFixed(2);
            document.getElementById("max-score").textContent = maxScore.toFixed(2);
            
            const colorScale = d3.scaleSequential(d3.interpolateViridis).domain([minScore, maxScore]);

            const numStops = 10;
            const colorStops = d3.range(numStops + 1).map(i => {
                const t = i / numStops;
                const score = minScore + t * (maxScore - minScore);
                return `${colorScale(score)} ${t * 100}%`;
            });

            heatbarContainer.style.background = `linear-gradient(to right, ${colorStops.join(', ')})`;
        }
        function populateProgramsTable(data) {
            const tableBody = document.querySelector("#program-table tbody");
            if (!tableBody) return;

            tableBody.innerHTML = "";

            // Check if we should show incorrect programs
            const showIncorrectCheckbox = document.getElementById('show-incorrect-programs');
            const showIncorrect = showIncorrectCheckbox ? showIncorrectCheckbox.checked : false;

            // Filter data based on checkbox state
            let filteredData = data;
            if (!showIncorrect) {
                filteredData = data.filter(d => d.correct);
            }

            // Separate correct and incorrect programs for ranking
            const correctPrograms = filteredData.filter(d => d.correct && d.combined_score !== null);
            const incorrectPrograms = filteredData.filter(d => !d.correct);
            
            // Rank only correct programs
            const rankedCorrectPrograms = correctPrograms
                .sort((a, b) => b.combined_score - a.combined_score)
                .map((p, i) => ({ ...p, original_rank: i + 1 }));
            
            // Add incorrect programs without ranks (or with special ranking)
            const rankedIncorrectPrograms = incorrectPrograms
                .map((p, i) => ({ ...p, original_rank: '‚Äî' }));
            
            // Combine the arrays
            const rankedPrograms = [...rankedCorrectPrograms, ...rankedIncorrectPrograms];

            let sortedPrograms = [...rankedPrograms];

            sortedPrograms.sort((a, b) => {
                let valA, valB;
                const key = sortState.key;
                const dir = sortState.dir;

                switch (key) {
                    case 'rank':
                        valA = (typeof a.original_rank === 'number') ? a.original_rank : Infinity;
                        valB = (typeof b.original_rank === 'number') ? b.original_rank : Infinity;
                        break;
                    case 'generation':
                        valA = a.generation;
                        valB = b.generation;
                        break;
                    case 'archive':
                        valA = a.in_archive ? 1 : 0;
                        valB = b.in_archive ? 1 : 0;
                        break;
                    case 'api_cost':
                        valA = (a.metadata && a.metadata.api_costs !== null && a.metadata.api_costs !== undefined) ? parseFloat(a.metadata.api_costs) : -Infinity;
                        valB = (b.metadata && b.metadata.api_costs !== null && b.metadata.api_costs !== undefined) ? parseFloat(b.metadata.api_costs) : -Infinity;
                        break;
                    case 'complexity':
                        valA = (a.complexity !== null && a.complexity !== undefined) ? a.complexity : -Infinity;
                        valB = (b.complexity !== null && b.complexity !== undefined) ? b.complexity : -Infinity;
                        break;
                    case 'island_idx':
                        valA = (a.island_idx !== null && a.island_idx !== undefined) ? a.island_idx : -Infinity;
                        valB = (b.island_idx !== null && b.island_idx !== undefined) ? b.island_idx : -Infinity;
                        break;
                    default:
                        return 0;
                }

                const aIsInvalid = valA === -Infinity;
                const bIsInvalid = valB === -Infinity;

                if (aIsInvalid && bIsInvalid) return a.original_rank - b.original_rank;
                if (aIsInvalid) return 1;
                if (bIsInvalid) return -1;

                if (valA === valB) {
                    return a.original_rank - b.original_rank;
                }

                const dirModifier = dir === 'asc' ? 1 : -1;
                return (valA < valB ? -1 : 1) * dirModifier;
            });

            document.querySelectorAll('#program-table th.sortable .sort-arrow').forEach(arrow => {
                arrow.textContent = '';
            });
            const activeHeader = document.querySelector(`#program-table th[data-sort="${sortState.key}"] .sort-arrow`);
            if (activeHeader) {
                activeHeader.textContent = sortState.dir === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
            }

            sortedPrograms.forEach(prog => {
                const row = document.createElement("tr");
                row.setAttribute("data-node-id", prog.id);
                
                // Style incorrect programs differently
                if (!prog.correct) {
                    row.style.backgroundColor = '#fff5f5';
                    row.style.color = '#721c24';
                }
                
                const apiCost = (prog.metadata && prog.metadata.api_costs) ? '$' + parseFloat(prog.metadata.api_costs).toFixed(4) : 'N/A';
                const complexity = prog.complexity ? prog.complexity.toFixed(3) : 'N/A';
                const model = (prog.metadata && prog.metadata.model_name) || 'N/A';

                const islandIdx = prog.island_idx !== null && prog.island_idx !== undefined ? prog.island_idx : 'N/A';
                const archiveStatus = prog.in_archive ? '‚úì' : '';
                const scoreDisplay = prog.combined_score !== null ? prog.combined_score.toFixed(6) : 'N/A';
                
                row.innerHTML = `
                    <td>${prog.original_rank}</td>
                    <td>${prog.generation}</td>
                    <td style="text-align: center; color: ${prog.in_archive ? '#28a745' : '#6c757d'}; font-weight: bold;">${archiveStatus}</td>
                    <td>${prog.metadata.patch_name || 'unnamed'}</td>
                    <td>${prog.metadata.patch_type || 'N/A'}</td>
                    <td>${islandIdx}</td>
                    <td>${scoreDisplay}</td>
                    <td>${apiCost}</td>
                    <td>${complexity}</td>
                    <td>${model}</td>
                `;
                tableBody.appendChild(row);
            });

            tableBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', function() {
                    const nodeId = this.getAttribute('data-node-id');
                    if (!nodeId) return;

                    const nodeElement = d3.selectAll('.node')
                        .filter(d => d.id === nodeId)
                        .node();
                    
                    if (nodeElement) {
                        nodeElement.dispatchEvent(new MouseEvent('click', { bubbles: true, view: window, cancelable: true }));
                    } else {
                        const nodeData = window.treeData.find(d => d.id === nodeId);
                        if (nodeData) {
                            displayNodeDetails(nodeData);
                            document.querySelector('.tab[data-tab="agent-code"]').click();
                        }
                    }
                });
            });
        }

        function selectNodeById(nodeId, switchToTreeView = true, forceRightTabSwitch = true) {
            console.log(`[DEBUG] Selecting node ID: ${nodeId}, switch to tree: ${switchToTreeView}`);
            window.pendingNodeSelectionId = nodeId;

            if (switchToTreeView) {
                const treeTab = document.querySelector('.left-tab[data-tab="tree-view"]');
                if (treeTab && !treeTab.classList.contains('active')) {
                    treeTab.click();
                } else if (window.treeData) {
                    renderGraph(window.treeData);
                }
            } else {
                // Don't switch tab, just show details
                const nodeData = window.treeData.find(d => d.id === nodeId);
                if (!nodeData) {
                    console.warn("[DEBUG] Could not find node data for ID:", nodeId);
                    return;
                };

                displayNodeDetails(nodeData);
                if (forceRightTabSwitch) {
                    document.querySelector('.tab[data-tab="agent-code"]').click();
                }
            }
        }

        // Embedding Analysis Functions
        function cosineSimilarity(vecA, vecB) {
            if (vecA.length !== vecB.length) return 0;
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            
            if (normA === 0 || normB === 0) return 0;
            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        function computeSimilarityMatrix(embeddings) {
            const n = embeddings.length;
            const matrix = new Array(n);
            
            for (let i = 0; i < n; i++) {
                matrix[i] = new Array(n);
                for (let j = 0; j < n; j++) {
                    matrix[i][j] = cosineSimilarity(embeddings[i], embeddings[j]);
                }
            }
            
            return matrix;
        }

        function hierarchicalClustering(similarityMatrix) {
            const n = similarityMatrix.length;
            const clusters = Array.from({length: n}, (_, i) => [i]);
            const distances = [];
            
            // Convert similarity to distance (1 - similarity)
            const distMatrix = similarityMatrix.map(row => 
                row.map(sim => 1 - sim)
            );
            
            while (clusters.length > 1) {
                let minDist = Infinity;
                let mergeI = -1, mergeJ = -1;
                
                // Find closest clusters
                for (let i = 0; i < clusters.length; i++) {
                    for (let j = i + 1; j < clusters.length; j++) {
                        let dist = 0;
                        let count = 0;
                        
                        // Average linkage
                        for (let a of clusters[i]) {
                            for (let b of clusters[j]) {
                                dist += distMatrix[a][b];
                                count++;
                            }
                        }
                        dist /= count;
                        
                        if (dist < minDist) {
                            minDist = dist;
                            mergeI = i;
                            mergeJ = j;
                        }
                    }
                }
                
                // Merge clusters
                const merged = [...clusters[mergeI], ...clusters[mergeJ]];
                clusters.splice(Math.max(mergeI, mergeJ), 1);
                clusters.splice(Math.min(mergeI, mergeJ), 1);
                clusters.push(merged);
            }
            
            return clusters[0]; // Return the final ordering
        }

        function createEmbeddingsHeatmap(data) {
            console.log("[DEBUG] Creating embeddings heatmap");
            
            // Add validation checks
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.warn("[DEBUG] No data available for embeddings heatmap");
                const container = document.getElementById('embeddings-heatmap');
                if (container) {
                    container.innerHTML = '<div style="text-align: center; color: #666; margin-top: 50px;">No data available for embeddings visualization.</div>';
                }
                return;
            }
            
            // Check if the embeddings tab is visible
            const embeddingsView = document.getElementById('embeddings-view');
            if (!embeddingsView || !embeddingsView.classList.contains('active')) {
                console.log("[DEBUG] Embeddings view not active, skipping heatmap creation");
                return;
            }
            
            // Clear existing heatmap
            d3.select("#embeddings-heatmap").selectAll("*").remove();
            
            // Deduplicate generation 0 programs for embeddings view (same logic as main tree)
            let filteredData = [...data];
            const gen0Programs = data.filter(d => d.generation === 0);
            
            if (gen0Programs.length > 1) {
                // Group generation 0 programs by their code content to identify duplicates
                const gen0Groups = {};
                gen0Programs.forEach(prog => {
                    const key = prog.code || 'no-code';
                    if (!gen0Groups[key]) {
                        gen0Groups[key] = [];
                    }
                    gen0Groups[key].push(prog);
                });
                
                // For each group of duplicates, keep only the first one (usually lowest island_idx)
                const duplicateIds = new Set();
                Object.values(gen0Groups).forEach(group => {
                    if (group.length > 1) {
                        // Sort by island_idx to keep the first island's copy
                        group.sort((a, b) => (a.island_idx || 0) - (b.island_idx || 0));
                        // Mark all but the first as duplicates to remove
                        group.slice(1).forEach(prog => duplicateIds.add(prog.id));
                    }
                });
                
                // Filter out the duplicate generation 0 programs
                filteredData = data.filter(d => !duplicateIds.has(d.id));
                console.log(`[DEBUG] Embeddings: Filtered out ${duplicateIds.size} duplicate generation 0 programs`);
            }
            
            // Filter data with embeddings
            const dataWithEmbeddings = filteredData.filter(d => d.embedding && Array.isArray(d.embedding) && d.embedding.length > 0);
            
            if (dataWithEmbeddings.length === 0) {
                d3.select("#embeddings-heatmap")
                    .append("div")
                    .style("text-align", "center")
                    .style("color", "#666")
                    .style("margin-top", "50px")
                    .text("No embedding data available for visualization.");
                return;
            }
            
            // Find best node within the current set of programs with embeddings
            const correctEmbedNodes = dataWithEmbeddings.filter(d => d.correct && d.combined_score !== null && !isNaN(d.combined_score));
            let bestEmbedNodeId = null;
            if (correctEmbedNodes.length > 0) {
                const bestEmbedNode = correctEmbedNodes.reduce((best, current) => (current.combined_score > best.combined_score) ? current : best);
                bestEmbedNodeId = bestEmbedNode.id;
            }
            
            console.log(`[DEBUG] Found ${dataWithEmbeddings.length} programs with embeddings`);
            
            // Create main container div
            const mainContainer = d3.select("#embeddings-heatmap")
                .append("div")
                .style("display", "flex")
                .style("flex-direction", "column")
                .style("align-items", "center")
                .style("width", "100%")
                .style("height", "100%")
                .style("overflow-y", "auto")
                .style("padding", "10px")
                .style("box-sizing", "border-box");

            // Add main heatmap title
            mainContainer.append("h3")
                .style("margin", "0 0 10px 0")
                .style("color", "#2c3e50")
                .style("font-size", "18px")
                .text("All Programs - Embedding Similarity Matrix");

            // Create main heatmap
            const mainHeatmapContainer = mainContainer.append("div")
                .attr("id", "main-heatmap")
                .style("margin-bottom", "10px");

            createSingleEmbeddingHeatmap(dataWithEmbeddings, mainHeatmapContainer, "All Programs", bestEmbedNodeId);

            // Group data by islands for subplots
            const islands = [...new Set(dataWithEmbeddings.filter(d => d.island_idx !== null && d.island_idx !== undefined).map(d => d.island_idx))].sort((a, b) => a - b);
            
            if (islands.length > 1) {
                // Add section title for island subplots
                mainContainer.append("h3")
                    .style("margin", "5px 0 10px 0")
                    .style("color", "#2c3e50")
                    .style("font-size", "18px")
                    .text("Individual Islands - Embedding Similarity Matrices");

                // Create island color scale (same as main visualization)
                const islandColors = [
                    "#1f77b4", "#2ca02c", "#9467bd", "#8c564b", "#e377c2",
                    "#7f7f7f", "#bcbd22", "#17becf", "#aec7e8"
                ];
                const islandColorScale = d3.scaleOrdinal(islandColors);

                // Create subplots container
                const subplotsContainer = mainContainer.append("div")
                    .style("display", "flex")
                    .style("flex-wrap", "wrap")
                    .style("justify-content", "center")
                    .style("gap", "20px")
                    .style("width", "100%");

                // Create subplot for each island
                islands.forEach(islandId => {
                    const islandData = dataWithEmbeddings.filter(d => d.island_idx === islandId);
                    
                    if (islandData.length > 1) { // Only create subplot if there are multiple programs
                        // Find best node in this island
                        const correctIslandNodes = islandData.filter(d => d.correct && d.combined_score !== null && !isNaN(d.combined_score));
                        let bestIslandNodeId = null;
                        if (correctIslandNodes.length > 0) {
                            const bestIslandNode = correctIslandNodes.reduce((best, current) => (current.combined_score > best.combined_score) ? current : best);
                            bestIslandNodeId = bestIslandNode.id;
                        }

                        const subplotContainer = subplotsContainer.append("div")
                            .style("border", `2px solid ${islandColorScale(islandId)}`)
                            .style("border-radius", "8px")
                            .style("padding", "15px")
                            .style("background-color", "#fafafa")
                            .style("min-width", "300px")
                            .style("max-width", "500px")
                            .style("display", "flex")
                            .style("flex-direction", "column")
                            .style("align-items", "center");

                        // Add island title with color coding
                        const titleContainer = subplotContainer.append("div")
                            .style("display", "flex")
                            .style("align-items", "center")
                            .style("margin-bottom", "15px");

                        titleContainer.append("div")
                            .style("width", "20px")
                            .style("height", "20px")
                            .style("background-color", islandColorScale(islandId))
                            .style("border-radius", "4px")
                            .style("margin-right", "10px");

                        titleContainer.append("h4")
                            .style("margin", "0")
                            .style("color", "#2c3e50")
                            .style("font-size", "16px")
                            .text(`Island ${islandId} (${islandData.length} programs)`);

                        createSingleEmbeddingHeatmap(islandData, subplotContainer, `Island ${islandId}`, bestIslandNodeId, true);
                    }
                });
            }
        }

        // Helper function to create a single embedding heatmap
        function createSingleEmbeddingHeatmap(dataWithEmbeddings, container, title, bestNodeId, isSubplot = false) {
            
            // Extract embeddings and metadata
            const embeddings = dataWithEmbeddings.map(d => d.embedding);
            const labelsData = dataWithEmbeddings.map(d => ({ gen: d.generation, name: d.metadata.patch_name || 'unnamed' }));
            const nodeIds = dataWithEmbeddings.map(d => d.id);
            
            // Compute similarity matrix
            const similarityMatrix = computeSimilarityMatrix(embeddings);

            // Get scores for performance bar
            const scores = dataWithEmbeddings
                .filter(d => d.correct && d.combined_score !== null && !isNaN(d.combined_score))
                .map(d => d.combined_score);
            const minScore = scores.length > 0 ? Math.min(...scores) : 0;
            const maxScore = scores.length > 0 ? Math.max(...scores) : 1;
            const scoreColorScale = d3.scaleSequential(d3.interpolatePlasma).domain([minScore, maxScore]);
            
            // Calculate actual min/max similarity values for auto-setting defaults
            let allSimilarities = [];
            for (let i = 0; i < similarityMatrix.length; i++) {
                for (let j = 0; j < similarityMatrix[i].length; j++) {
                    if (i !== j) { // Exclude diagonal (self-similarity = 1.0)
                        allSimilarities.push(similarityMatrix[i][j]);
                    }
                }
            }
            
            const actualMinSim = allSimilarities.length > 0 ? Math.min(...allSimilarities) : 0;
            const actualMaxSim = allSimilarities.length > 0 ? Math.max(...allSimilarities) : 1;
            
            // For subplots, use the same controls as main plot
            // For main plot, auto-set defaults for each database
            let heatMin, heatMax;
            if (isSubplot) {
                // Use the same range as main plot
                heatMin = parseFloat(document.getElementById('heat-min').value);
                heatMax = parseFloat(document.getElementById('heat-max').value);
            } else {
                // Auto-set defaults for main plot
                const heatMinInput = document.getElementById('heat-min');
                const heatMaxInput = document.getElementById('heat-max');
                
                // Check if this is a different database or first time
                const currentDbPath = window.currentDbPath;
                const lastDbPath = window.lastEmbeddingsDbPath;
                
                if (heatMinInput && heatMaxInput && (currentDbPath !== lastDbPath)) {
                    // Auto-set for new database
                    heatMinInput.value = actualMinSim.toFixed(3);
                    heatMaxInput.value = actualMaxSim.toFixed(3);
                    window.lastEmbeddingsDbPath = currentDbPath;
                    console.log(`[DEBUG] Auto-set similarity range for new database: ${actualMinSim.toFixed(3)} - ${actualMaxSim.toFixed(3)}`);
                    
                    // Save the new preferences
                    savePreferences();
                }
                
                heatMin = parseFloat(heatMinInput.value);
                heatMax = parseFloat(heatMaxInput.value);
            }
            
            // Apply sorting method (same for both main plot and subplots)
            let ordering = Array.from({length: dataWithEmbeddings.length}, (_, i) => i);
            
            const sortMethod = document.getElementById('embedding-sort-method').value;
            
            if (sortMethod === 'cluster' && dataWithEmbeddings.length > 1) {
                ordering = hierarchicalClustering(similarityMatrix);
                console.log(`[DEBUG] Applied hierarchical clustering ${isSubplot ? 'to subplot' : 'to main plot'}`);
            } else if (sortMethod === 'performance') {
                const indexedPrograms = dataWithEmbeddings.map((p, i) => ({...p, originalIndex: i}));

                indexedPrograms.sort((a, b) => {
                    const scoreA = (a.correct && a.combined_score != null) ? a.combined_score : -Infinity;
                    const scoreB = (b.correct && b.combined_score != null) ? b.combined_score : -Infinity;
                    return scoreB - scoreA;
                });

                ordering = indexedPrograms.map(p => p.originalIndex);
                console.log(`[DEBUG] Sorted by performance ${isSubplot ? 'for subplot' : 'for main plot'}`);
            } else if (sortMethod === 'chronological') {
                // The default ordering is chronological because dataWithEmbeddings preserves the order from the original data
                console.log(`[DEBUG] Sorted chronologically ${isSubplot ? 'for subplot' : 'for main plot'}`);
            }
            
            // Reorder data according to ordering
            const orderedMatrix = ordering.map(i => ordering.map(j => similarityMatrix[i][j]));
            const orderedLabelsData = ordering.map(i => labelsData[i]);
            const orderedNodeIds = ordering.map(i => nodeIds[i]);
            const orderedScores = ordering.map(i => dataWithEmbeddings[i].combined_score);
            const orderedCorrectness = ordering.map(i => dataWithEmbeddings[i].correct);
            
            // Get visualization parameters
            const cellSize = isSubplot ? Math.max(4, Math.min(parseInt(document.getElementById('cell-size').value), 8)) : parseInt(document.getElementById('cell-size').value);
            const colorScale = document.getElementById('color-scale').value;
            
            // Create color scale
            const colorScales = {
                viridis: d3.scaleSequential(d3.interpolateViridis),
                plasma: d3.scaleSequential(d3.interpolatePlasma),
                inferno: d3.scaleSequential(d3.interpolateInferno),
                magma: d3.scaleSequential(d3.interpolateMagma)
            };
            
            const colorFn = colorScales[colorScale].domain([heatMin, heatMax]);
            
            // Calculate maximum label length for proper margins
            const maxLabelLength = Math.max(...orderedLabelsData.map(label => label.name.length));
            const estimatedLabelWidth = Math.min(maxLabelLength * (isSubplot ? 4 : 6), isSubplot ? 120 : 200);
            
            // Calculate the diagonal length needed for rotated labels
            const diagonalLength = Math.sqrt(estimatedLabelWidth * estimatedLabelWidth + 100);
            
            // Set up dimensions with proper margins (smaller for subplots, no label space needed)
            const margin = {
                top: isSubplot ? 20 : diagonalLength + 10,
                right: isSubplot ? 80 : 130,
                bottom: isSubplot ? 50 : 120,
                left: isSubplot ? 20 : estimatedLabelWidth + 30
            };
            
            const heatmapWidth = orderedMatrix.length * cellSize;
            const heatmapHeight = orderedMatrix.length * cellSize;
            
            // Calculate total SVG dimensions
            const totalWidth = heatmapWidth + margin.left + margin.right;
            const totalHeight = heatmapHeight + margin.top + margin.bottom;
            
            // Create SVG
            const svg = container
                .append("svg")
                .attr("width", totalWidth)
                .attr("height", totalHeight);
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Create heatmap cells
            const rows = g.selectAll(".row")
                .data(orderedMatrix)
                .enter().append("g")
                .attr("class", "row")
                .attr("transform", (d, i) => `translate(0,${i * cellSize})`);
            
            const cells = rows.selectAll(".cell")
                .data(d => d)
                .enter().append("rect")
                .attr("class", "cell")
                .attr("x", (d, i) => i * cellSize)
                .attr("width", cellSize)
                .attr("height", cellSize)
                .style("fill", d => colorFn(d))
                .style("stroke", "#fff")
                .style("stroke-width", 0.5)
                .style("cursor", "pointer")
                .on("mouseover", function(event, d) {
                    const [i, j] = [
                        Math.floor(d3.select(this.parentNode).datum().indexOf(d)),
                        Math.floor(Array.from(this.parentNode.parentNode.children).indexOf(this.parentNode))
                    ];
                    
                    // Show tooltip
                    const tooltip = d3.select("body").append("div")
                        .attr("class", "heatmap-tooltip")
                        .style("position", "absolute")
                        .style("background", "rgba(0,0,0,0.8)")
                        .style("color", "white")
                        .style("padding", "8px")
                        .style("border-radius", "4px")
                        .style("font-size", "12px")
                        .style("pointer-events", "none")
                        .style("z-index", "1000");

                    const label1 = orderedLabelsData[j];
                    const label2 = orderedLabelsData[i];
                    
                    tooltip.html(`
                        <strong><b>${label1.gen}</b>: ${label1.name}</strong><br>
                        <strong><b>${label2.gen}</b>: ${label2.name}</strong><br>
                        Similarity: ${d.toFixed(3)}
                    `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    d3.selectAll(".heatmap-tooltip").remove();
                })
                .on("click", function(event, d) {
                    const [i, j] = [
                        Math.floor(d3.select(this.parentNode).datum().indexOf(d)),
                        Math.floor(Array.from(this.parentNode.parentNode.children).indexOf(this.parentNode))
                    ];
                    
                    // Select the node corresponding to the row
                    const nodeId = orderedNodeIds[j];
                    updateDetailsForNode(nodeId);

                    // Visually update selection in the heatmap view
                    d3.selectAll(`#${isSubplot ? container.attr('id') || 'subplot' : 'main-heatmap'} .cell`)
                        .style("stroke", "#fff")
                        .style("stroke-width", 0.5);
                    
                    d3.select(this.parentNode)
                        .selectAll('.cell')
                        .style("stroke", "#e58e26")
                        .style("stroke-width", 2);
                });
            
            // Add performance score bar (smaller for subplots)
            const perfBarWidth = isSubplot ? 12 : 20;
            
            const perfBar = g.append("g")
                .attr("transform", `translate(${heatmapWidth + 10}, 0)`);

            perfBar.selectAll(".perf-cell")
                .data(orderedScores)
                .enter().append("rect")
                .attr("class", "perf-cell")
                .attr("y", (d, i) => i * cellSize)
                .attr("width", perfBarWidth)
                .attr("height", cellSize)
                .style("fill", (d, i) => {
                    if (!orderedCorrectness[i] || d === null) {
                        return "#ccc"; // Grey for incorrect or no score
                    }
                    return scoreColorScale(d);
                })
                .style("stroke", "#fff")
                .style("stroke-width", 0.5)
                .on("mouseover", function(event, d) {
                    const i = Array.from(this.parentNode.childNodes).filter(n => n.nodeName === 'rect').indexOf(this);
                    const program = dataWithEmbeddings[ordering[i]];
                    
                    const tooltip = d3.select("body").append("div")
                        .attr("class", "heatmap-tooltip")
                        .style("position", "absolute")
                        .style("background", "rgba(0,0,0,0.8)")
                        .style("color", "white")
                        .style("padding", "8px")
                        .style("border-radius", "4px")
                        .style("font-size", "12px")
                        .style("pointer-events", "none")
                        .style("z-index", "1000");

                    tooltip.html(`
                        <strong>${program.metadata.patch_name || 'unnamed'}</strong><br>
                        Score: ${formatScore(d)}
                    `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    d3.selectAll(".heatmap-tooltip").remove();
                });

            // Add a title for the performance bar
            perfBar.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", `translate(${perfBarWidth + (isSubplot ? 45 : 50)}, ${heatmapHeight / 2}) rotate(-90)`)
                .style("font-size", isSubplot ? "11px" : "14px")
                .style("font-weight", "bold")
                .style("fill", "#333")
                .text("Score");


            
            // Add color legend
            const legendWidth = heatmapWidth;
            const legendHeight = isSubplot ? 10 : 15;
            
            const legend = svg.append("g")
                .attr("transform", `translate(${margin.left}, ${heatmapHeight + margin.top + (isSubplot ? 15 : 40)})`);
            
            const legendGradientId = isSubplot ? `legend-gradient-subplot-${Math.random().toString(36).substr(2, 9)}` : "legend-gradient";
            const legendGradient = svg.append("defs")
                .append("linearGradient")
                .attr("id", legendGradientId)
                .attr("x1", "0%")
                .attr("x2", "100%");
            
            const steps = 10;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                legendGradient.append("stop")
                    .attr("offset", `${t * 100}%`)
                    .attr("stop-color", colorFn(t));
            }
            
            legend.append("rect")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", `url(#${legendGradientId})`)
                .style("stroke", "#333")
                .style("stroke-width", 1);
            
            legend.append("text")
                .attr("x", 0)
                .attr("y", legendHeight + (isSubplot ? 15 : 20))
                .style("font-size", isSubplot ? "10px" : "12px")
                .style("text-anchor", "start")
                .text(heatMin.toFixed(2));
            
            legend.append("text")
                .attr("x", legendWidth)
                .attr("y", legendHeight + (isSubplot ? 15 : 20))
                .style("text-anchor", "end")
                .style("font-size", isSubplot ? "10px" : "12px")
                .text(heatMax.toFixed(2));
            
            legend.append("text")
                .attr("x", legendWidth / 2)
                .attr("y", -5)
                .style("text-anchor", "middle")
                .style("font-size", isSubplot ? "12px" : "14px")
                .style("font-weight", "bold")
                .text("Cosine Sim.");

            // Add performance score legend
            if (scores.length > 0) {
                const perfLegendHeight = heatmapHeight;
                const perfLegendWidth = isSubplot ? 10 : 15;
                const perfLegend = svg.append("g")
                    .attr("transform", `translate(${margin.left + heatmapWidth + 10 + perfBarWidth + (isSubplot ? 20 : 15)}, ${margin.top})`);

                const perfLegendGradientId = isSubplot ? `perf-legend-gradient-subplot-${Math.random().toString(36).substr(2, 9)}` : "perf-legend-gradient";
                const perfLegendGradient = svg.append("defs")
                    .append("linearGradient")
                    .attr("id", perfLegendGradientId)
                    .attr("x1", "0%").attr("y1", "100%") // bottom to top
                    .attr("x2", "0%").attr("y2", "0%");

                const perfSteps = 10;
                d3.range(perfSteps + 1).forEach(i => {
                    const t = i / perfSteps;
                    const score = minScore + t * (maxScore - minScore);
                    perfLegendGradient.append("stop")
                        .attr("offset", `${t * 100}%`)
                        .attr("stop-color", scoreColorScale(score));
                });

                perfLegend.append("rect")
                    .attr("width", perfLegendWidth)
                    .attr("height", perfLegendHeight)
                    .style("fill", `url(#${perfLegendGradientId})`)
                    .style("stroke", "#333")
                    .style("stroke-width", 1);

                perfLegend.append("text")
                    .attr("x", perfLegendWidth + (isSubplot ? 3 : 5))
                    .attr("y", perfLegendHeight)
                    .style("font-size", isSubplot ? "9px" : "12px")
                    .style("text-anchor", "start")
                    .attr("dy", "0.35em")
                    .style("fill", "#666")
                    .text(minScore.toFixed(2));

                perfLegend.append("text")
                    .attr("x", perfLegendWidth + (isSubplot ? 3 : 5))
                    .attr("y", 0)
                    .style("font-size", isSubplot ? "9px" : "12px")
                    .style("text-anchor", "start")
                    .attr("dy", "0.35em")
                    .style("fill", "#666")
                    .text(maxScore.toFixed(2));
            }

            // Calculate font size based on cell size to prevent overlap
            const baseFontSize = isSubplot ? 4 : 6;
            const minFontSize = isSubplot ? 3 : 4;
            const maxFontSize = isSubplot ? 8 : 14;
            // Scale font size proportionally to cell size, with reasonable bounds
            const scaledFontSize = Math.max(minFontSize, Math.min(maxFontSize, (cellSize / 8) * baseFontSize));
            
            // Add row labels (only for main plot)
            if (!isSubplot) {
                g.selectAll(".row-label")
                    .data(orderedLabelsData)
                    .enter().append("text")
                    .attr("class", "row-label")
                    .attr("x", -10)
                    .attr("y", (d, i) => i * cellSize + cellSize / 2)
                    .attr("dy", "0.35em")
                    .style("text-anchor", "end")
                    .style("font-size", `${scaledFontSize}px`)
                    .style("fill", "#333")
                    .text(d => `${d.gen}: ${d.name}`);
                
                // Add column labels with better positioning
                g.selectAll(".col-label")
                    .data(orderedLabelsData)
                    .enter().append("text")
                    .attr("class", "col-label")
                    .attr("transform", (d, i) => `translate(${i * cellSize + cellSize / 2}, -8) rotate(-45)`)
                    .style("text-anchor", "start")
                    .style("font-size", `${scaledFontSize}px`)
                    .style("fill", "#333")
                    .text(d => `${d.gen}: ${d.name}`);
            }
        }
        function updateDetailsForNode(nodeId) {
            if (!window.treeData) return;
            const nodeData = window.treeData.find(d => d.id === nodeId);
            if (!nodeData) return;

            // Silently update selection in the main tree view for state persistence
            d3.selectAll('.node.selected').classed('selected', false);
            d3.selectAll('.node').filter(d => d.data.id === nodeId).classed('selected', true);

            // Update details panel on the right
            displayNodeDetails(nodeData);
        }

        // State persistence functions
        function saveState() {
            if (window.isReloadingData) {
                console.log("[DEBUG] Skipping saveState during data reload.");
                return;
            }
            try {
                const state = {
                    leftTab: document.querySelector('.left-tab.active')?.getAttribute('data-tab'),
                    rightTab: document.querySelector('.tab.active')?.getAttribute('data-tab'),
                    selectedNodeId: getSelectedNodeId(),
                    dbPath: window.currentDbPath
                };
                
                // Update URL without page reload
                const url = new URL(window.location);
                if (state.dbPath) url.searchParams.set('db_path', state.dbPath);
                if (state.leftTab) url.searchParams.set('left_tab', state.leftTab);
                if (state.rightTab) url.searchParams.set('right_tab', state.rightTab);
                if (state.selectedNodeId) url.searchParams.set('selected_node', state.selectedNodeId);
                
                window.history.replaceState(null, '', url);
                console.log("[DEBUG] State saved to URL");
            } catch (error) {
                console.error("[DEBUG] Error saving state:", error);
            }
        }
        
        function savePreferences() {
            try {
                const preferences = {
                    embeddingSortMethod: document.getElementById('embedding-sort-method')?.value,
                    colorScale: document.getElementById('color-scale')?.value,
                    cellSize: document.getElementById('cell-size')?.value,
                    heatMin: document.getElementById('heat-min')?.value,
                    heatMax: document.getElementById('heat-max')?.value,
                    panelWidth: document.getElementById('tree-panel')?.style.width
                };
                
                localStorage.setItem('shinka_preferences', JSON.stringify(preferences));
                console.log("[DEBUG] Preferences saved to localStorage");
            } catch (error) {
                console.error("[DEBUG] Error saving preferences:", error);
            }
        }
        
        function restorePreferences() {
            try {
                const saved = localStorage.getItem('shinka_preferences');
                if (!saved) return;
                
                const preferences = JSON.parse(saved);
                
                // Restore embedding controls
                if (preferences.embeddingSortMethod) {
                    const select = document.getElementById('embedding-sort-method');
                    if (select) select.value = preferences.embeddingSortMethod;
                }
                
                if (preferences.colorScale) {
                    const select = document.getElementById('color-scale');
                    if (select) select.value = preferences.colorScale;
                }
                
                if (preferences.cellSize) {
                    const slider = document.getElementById('cell-size');
                    const display = document.getElementById('cell-size-value');
                    if (slider) {
                        slider.value = preferences.cellSize;
                        if (display) display.textContent = preferences.cellSize + 'px';
                    }
                }
                
                if (preferences.heatMin) {
                    const input = document.getElementById('heat-min');
                    if (input) input.value = preferences.heatMin;
                }
                
                if (preferences.heatMax) {
                    const input = document.getElementById('heat-max');
                    if (input) input.value = preferences.heatMax;
                }
                
                // Restore panel width
                if (preferences.panelWidth) {
                    const panel = document.getElementById('tree-panel');
                    if (panel) panel.style.width = preferences.panelWidth;
                }
                
                console.log("[DEBUG] Preferences restored from localStorage");
            } catch (error) {
                console.error("[DEBUG] Error restoring preferences:", error);
            }
        }
        
        function restoreFromURL() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                
                // Restore database selection
                const dbPath = urlParams.get('db_path');
                if (dbPath) {
                    // Parse the path to extract task and result
                    const pathParts = dbPath.split('/');
                    if (pathParts.length >= 3) {
                        const task = pathParts[pathParts.length - 3];
                        const taskSelect = document.getElementById('task-select');
                        const resultSelect = document.getElementById('result-select');
                        
                        if (taskSelect && resultSelect) {
                            taskSelect.value = task;
                            populateResultSelect(task);
                            resultSelect.value = dbPath;
                            loadDatabase(dbPath);
                        }
                    }
                }
                
                // Restore left tab
                const leftTab = urlParams.get('left_tab');
                if (leftTab) {
                    const tabElement = document.querySelector(`.left-tab[data-tab="${leftTab}"]`);
                    if (tabElement) {
                        setTimeout(() => tabElement.click(), 100);
                    }
                }
                
                // Restore selected node (after data loads) and then restore right tab
                const selectedNodeId = urlParams.get('selected_node');
                const rightTab = urlParams.get('right_tab');
                
                if (selectedNodeId) {
                    // Wait for data to load before selecting node
                    const checkDataAndSelect = () => {
                        if (window.treeData) {
                            setTimeout(() => {
                                selectNodeById(selectedNodeId, true, false); // Don't force right tab switch
                                // Restore right tab AFTER node selection
                                if (rightTab) {
                                    const tabElement = document.querySelector(`.tab[data-tab="${rightTab}"]`);
                                    if (tabElement) {
                                        setTimeout(() => tabElement.click(), 100);
                                    }
                                }
                            }, 500);
                        } else {
                            setTimeout(checkDataAndSelect, 100);
                        }
                    };
                    checkDataAndSelect();
                } else {
                    // No node selected, just restore right tab
                    if (rightTab) {
                        const tabElement = document.querySelector(`.tab[data-tab="${rightTab}"]`);
                        if (tabElement) {
                            setTimeout(() => tabElement.click(), 100);
                        }
                    }
                }
                
                console.log("[DEBUG] State restored from URL");
            } catch (error) {
                console.error("[DEBUG] Error restoring from URL:", error);
            }
        }
        
        function updateURL() {
            saveState();
        }
        
        function getSelectedNodeId() {
            try {
                const selectedNodeElement = d3.select('.node.selected');
                if (selectedNodeElement.empty()) {
                    return null;
                }
                
                const selectedNode = selectedNodeElement.datum();
                return selectedNode ? selectedNode.id : null;
            } catch (error) {
                console.warn("[DEBUG] Error getting selected node ID:", error);
                return null;
            }
        }

        // Helper function to ensure embeddings heatmap is loaded
        function ensureEmbeddingsHeatmap() {
            const embeddingsView = document.getElementById('embeddings-view');
            if (!embeddingsView || !embeddingsView.classList.contains('active')) {
                return;
            }
            
            const heatmapContainer = document.getElementById('embeddings-heatmap');
            if (!heatmapContainer) {
                return;
            }
            
            // Check if heatmap already exists (has SVG content)
            const existingHeatmap = heatmapContainer.querySelector('svg');
            if (existingHeatmap) {
                console.log("[DEBUG] Embeddings heatmap already exists");
                return;
            }
            
            // If we have data but no heatmap, create it
            if (window.treeData && window.treeData.length > 0) {
                console.log("[DEBUG] Creating missing embeddings heatmap");
                createEmbeddingsHeatmap(window.treeData);
            } else {
                // Show loading message
                heatmapContainer.innerHTML = '<div style="text-align: center; color: #666; margin-top: 50px;">Waiting for data to load...</div>';
            }
        }

        function createIslandProgressionCurves(container, programs, islands, yMinOverride = null, yMaxOverride = null) {
            console.log("[DEBUG] Creating island progression curves for", islands.length, "islands");
            
            // Clean up any existing tooltips
            d3.selectAll(".island-curve-tooltip").remove();
            
            const containerWidth = container.node().getBoundingClientRect().width;
            const containerHeight = container.node().getBoundingClientRect().height;
            
            // Create SVG for curves
            const curvesSvg = container.append("svg")
                .attr("width", containerWidth)
                .attr("height", containerHeight)
                .style("background", "white");

            // Create tooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "island-curve-tooltip")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("background", "rgba(0, 0, 0, 0.8)")
                .style("color", "white")
                .style("padding", "8px")
                .style("border-radius", "4px")
                .style("font-size", "12px")
                .style("pointer-events", "none")
                .style("z-index", "1000");

            const margin = { top: 45, right: 20, bottom: 30, left: 50 };
            const plotWidth = containerWidth - margin.left - margin.right;
            const plotHeight = containerHeight - margin.top - margin.bottom;

            const g = curvesSvg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add title
            curvesSvg.append("text")
                .attr("x", containerWidth / 2)
                .attr("y", 35)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .style("fill", "#333")
                .text("Performance Progression by Island");

            // Group programs by island and generation
            const islandData = {};
            islands.forEach(islandId => {
                islandData[islandId] = {};
            });

            programs.forEach(program => {
                const islandId = program.island_idx;
                const generation = program.generation || 0;
                const score = program.combined_score;
                
                if (islandId != null && score != null && !isNaN(score)) {
                    if (!islandData[islandId][generation]) {
                        islandData[islandId][generation] = [];
                    }
                    islandData[islandId][generation].push({
                        score: score,
                        program: program  // Keep reference to full program data
                    });
                }
            });

            // Find all unique generations across all islands
            const allUniqueGenerations = new Set();
            programs.forEach(program => {
                const generation = program.generation || 0;
                allUniqueGenerations.add(generation);
            });
            const sortedGenerations = Array.from(allUniqueGenerations).sort((a,b) => a-b);

            // Calculate cumulative maximum score per generation for each island
            const islandCurves = {};
            const allScores = [];
            
            islands.forEach(islandId => {
                islandCurves[islandId] = [];
                let cumulativeMaxScore = -Infinity;
                let cumulativeMaxProgram = null;
                
                sortedGenerations.forEach(gen => {
                    const programData = islandData[islandId][gen];
                    let generationBestData = null;
                    let isNewMax = false;
                    
                    // Find the best program in this generation
                    if (programData && programData.length > 0) {
                        generationBestData = programData.reduce((best, current) => 
                            current.score > best.score ? current : best
                        );
                        
                        // Check if this generation's best beats the cumulative max
                        if (generationBestData.score > cumulativeMaxScore) {
                            cumulativeMaxScore = generationBestData.score;
                            cumulativeMaxProgram = generationBestData.program;
                            isNewMax = true;
                        }
                    }
                    
                    // Always add a point for this generation using cumulative max
                    if (cumulativeMaxScore > -Infinity) {
                        islandCurves[islandId].push({ 
                            generation: gen, 
                            bestScore: cumulativeMaxScore,
                            bestProgram: cumulativeMaxProgram,
                            isCarryForward: !isNewMax && islandCurves[islandId].length > 0,
                            isNewMax: isNewMax
                        });
                        allScores.push(cumulativeMaxScore);
                    }
                });
            });

            if (allScores.length === 0) {
                g.append("text")
                    .attr("x", plotWidth / 2)
                    .attr("y", plotHeight / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("fill", "#666")
                    .text("No progression data available");
                return;
            }

            const xDomain = d3.extent(sortedGenerations);
            let yDomain = d3.extent(allScores);
            
            // Add some padding to y domain
            const yPadding = (yDomain[1] - yDomain[0]) * 0.1;
            yDomain[0] -= yPadding;
            yDomain[1] += yPadding;
            
            // Apply user-defined overrides if provided
            if (yMinOverride !== null && !isNaN(yMinOverride)) {
                yDomain[0] = yMinOverride;
            }
            if (yMaxOverride !== null && !isNaN(yMaxOverride)) {
                yDomain[1] = yMaxOverride;
            }

            const xScale = d3.scaleLinear()
                .domain(xDomain)
                .range([0, plotWidth]);

            const yScale = d3.scaleLinear()
                .domain(yDomain)
                .range([plotHeight, 0]);

            // Create line generator
            const line = d3.line()
                .x(d => xScale(d.generation))
                .y(d => yScale(d.bestScore))
                .curve(d3.curveMonotoneX);

            // Use the same color scheme as the main tree plot
            const islandColors = [
                "#1f77b4", // blue
                "#2ca02c", // green  
                "#9467bd", // purple
                "#8c564b", // brown
                "#e377c2", // pink
                "#7f7f7f", // gray
                "#bcbd22", // olive
                "#17becf", // cyan
                "#aec7e8"  // light blue
            ];
            const color = d3.scaleOrdinal(islandColors);

            // Draw axes
            // Limit number of ticks to prevent overlap when there are many generations
            let tickValues = sortedGenerations;
            if (sortedGenerations.length > 15) {
                // Show every nth generation to avoid overlap
                const step = Math.ceil(sortedGenerations.length / 15);
                tickValues = sortedGenerations.filter((_, i) => i % step === 0);
                // Always include the last generation
                if (tickValues[tickValues.length - 1] !== sortedGenerations[sortedGenerations.length - 1]) {
                    tickValues.push(sortedGenerations[sortedGenerations.length - 1]);
                }
            }
            
            const xAxis = d3.axisBottom(xScale)
                .tickValues(tickValues)
                .tickFormat(d3.format("d"));
            const yAxis = d3.axisLeft(yScale)
                .ticks(4)
                .tickFormat(d3.format(".2f"));

            g.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${plotHeight})`)
                .call(xAxis)
                .append("text")
                .attr("x", plotWidth / 2)
                .attr("y", 25)
                .attr("text-anchor", "middle")
                .style("fill", "black")
                .style("font-size", "12px")
                .text("Generation");

            g.append("g")
                .attr("class", "y-axis")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -35)
                .attr("x", -plotHeight / 2)
                .attr("text-anchor", "middle")
                .style("fill", "black")
                .style("font-size", "12px")
                .text("Best Score");

            // Draw curves and scatter points for each island
            islands.forEach((islandId, index) => {
                const curveData = islandCurves[islandId];
                if (curveData.length === 0) return;

                const islandColor = color(islandId);

                // First, draw scatter points for ALL individual evaluations
                const allIndividualPoints = [];
                sortedGenerations.forEach(gen => {
                    const programData = islandData[islandId][gen];
                    if (programData && programData.length > 0) {
                        programData.forEach(programInfo => {
                            allIndividualPoints.push({
                                generation: gen,
                                score: programInfo.score,
                                program: programInfo.program
                            });
                        });
                    }
                });

                // Draw scatter points for individual evaluations
                g.selectAll(`.island-${islandId}-scatter`)
                    .data(allIndividualPoints)
                    .enter().append("circle")
                    .attr("class", `island-${islandId}-scatter`)
                    .attr("cx", d => xScale(d.generation))
                    .attr("cy", d => yScale(d.score))
                    .attr("r", 2)
                    .attr("fill", islandColor)
                    .attr("fill-opacity", 0.4)
                    .attr("stroke", islandColor)
                    .attr("stroke-width", 0.5)
                    .attr("stroke-opacity", 0.6)
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        // Enlarge the scatter point
                        d3.select(this)
                            .transition()
                            .duration(100)
                            .attr("r", 4)
                            .attr("fill-opacity", 0.8)
                            .attr("stroke-width", 1);
                        
                        // Create tooltip content for individual evaluation
                        const program = d.program;
                        const patchName = program?.metadata?.patch_name || 'Unnamed';
                        const patchType = program?.metadata?.patch_type || 'Unknown';
                        const apiCost = (program?.metadata?.api_costs) ? '$' + parseFloat(program.metadata.api_costs).toFixed(4) : 'N/A';
                        
                        const tooltipContent = `
                            <strong>Island ${islandId} - Gen ${d.generation}</strong><br/>
                            <strong>Score:</strong> ${d.score.toFixed(4)}<br/>
                            <strong>Program:</strong> ${patchName}<br/>
                            <strong>Type:</strong> ${patchType}<br/>
                            <strong>API Cost:</strong> ${apiCost}
                        `;
                        
                        tooltip.html(tooltipContent)
                            .style("visibility", "visible")
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip.style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        // Return scatter point to normal size
                        d3.select(this)
                            .transition()
                            .duration(100)
                            .attr("r", 2)
                            .attr("fill-opacity", 0.4)
                            .attr("stroke-width", 0.5);
                        
                        tooltip.style("visibility", "hidden");
                    });

                // Then, draw the max progression line
                g.append("path")
                    .datum(curveData)
                    .attr("fill", "none")
                    .attr("stroke", islandColor)
                    .attr("stroke-width", 3)
                    .attr("stroke-opacity", 1)
                    .attr("d", line);

                // Draw larger points for the max scores with hover functionality
                g.selectAll(`.island-${islandId}-max-points`)
                    .data(curveData)
                    .enter().append("circle")
                    .attr("class", `island-${islandId}-max-points`)
                    .attr("cx", d => xScale(d.generation))
                    .attr("cy", d => yScale(d.bestScore))
                    .attr("r", 4)
                    .attr("fill", islandColor)
                    .attr("stroke", "white")
                    .attr("stroke-width", 2)
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        // Enlarge the max point
                        d3.select(this)
                            .transition()
                            .duration(100)
                            .attr("r", 6)
                            .attr("stroke-width", 3);
                        
                        // Create tooltip content for cumulative max score
                        const program = d.bestProgram;
                        const patchName = program?.metadata?.patch_name || 'Unnamed';
                        const patchType = program?.metadata?.patch_type || 'Unknown';
                        const apiCost = (program?.metadata?.api_costs) ? '$' + parseFloat(program.metadata.api_costs).toFixed(4) : 'N/A';
                        const statusText = d.isNewMax ? ' (NEW MAX)' : d.isCarryForward ? ' (CUMMAX)' : ' (CUMMAX)';
                        
                        const tooltipContent = `
                            <strong>Island ${islandId} - Gen ${d.generation}${statusText}</strong><br/>
                            <strong>Cumulative Max Score:</strong> ${d.bestScore.toFixed(4)}<br/>
                            <strong>Best Program:</strong> ${patchName}<br/>
                            <strong>Type:</strong> ${patchType}<br/>
                            <strong>API Cost:</strong> ${apiCost}
                        `;
                        
                        tooltip.html(tooltipContent)
                            .style("visibility", "visible")
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip.style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        // Return max point to normal size
                        d3.select(this)
                            .transition()
                            .duration(100)
                            .attr("r", 4)
                            .attr("stroke-width", 2);
                        
                        tooltip.style("visibility", "hidden");
                    });
            });

            // Add legend (positioned at bottom-right)
            const legend = g.append("g")
                .attr("class", "curves-legend")
                .attr("transform", `translate(${plotWidth - 140}, ${plotHeight - islands.length * 22 - 30})`);

            islands.forEach((islandId, index) => {
                const legendItem = legend.append("g")
                    .attr("transform", `translate(0, ${index * 22})`);

                // Color square instead of line/dots
                legendItem.append("rect")
                    .attr("x", 0)
                    .attr("y", -6)
                    .attr("width", 12)
                    .attr("height", 12)
                    .attr("fill", color(islandId))
                    .attr("stroke", "white")
                    .attr("stroke-width", 1);

                legendItem.append("text")
                    .attr("x", 18)
                    .attr("y", 0)
                    .attr("dy", "0.35em")
                    .style("font-size", "11px")
                    .style("fill", "#333")
                    .text(`Island ${islandId}`);
            });

            // Remove legend explanation about lines/dots since we simplified the legend
        }

        function createIslandsVisualization(data) {
            console.log("[DEBUG] Creating islands visualization");
            
            // Check if the islands tab is visible
            const islandsView = document.getElementById('islands-view');
            if (!islandsView || !islandsView.classList.contains('active')) {
                console.log("[DEBUG] Islands view not active, skipping visualization creation");
                return;
            }

            const container = d3.select("#islands-container");
            container.html(""); // Clear previous content

            if (!data || data.length === 0) {
                container.append("p").style('text-align', 'center').style('margin-top', '50px').text("No data to visualize.");
                return;
            }

            const programs = data.filter(d => 
                (d.island_idx !== null && d.island_idx !== undefined && d.correct && d.combined_score != null) ||
                (d.metadata && d.metadata.patch_type === 'init')
            );

            if (programs.length === 0) {
                container.append("p").style('text-align', 'center').style('margin-top', '50px').text("No correct programs with island assignments and scores found.");
                return;
            }

            // Create containers for progression curves, plot and summary
            const curvesContainer = container.append("div")
                .style("height", "25%")
                .style("position", "relative")
                .style("background", "white")
                .style("border-radius", "8px 8px 0 0")
                .style("margin-bottom", "5px")
                .style("border-bottom", "1px solid #dee2e6");

            const plotContainer = container.append("div")
                .style("height", "50%")
                .style("position", "relative")
                .style("background", "white")
                .style("margin-bottom", "5px");

            const summaryContainer = container.append("div")
                .style("height", "23%")
                .style("overflow-y", "auto")
                .style("padding", "15px")
                .style("border-top", "2px solid #dee2e6")
                .style("background-color", "#ffffff")
                .style("border-radius", "0 0 8px 8px")
                .style("box-sizing", "border-box");
            
            // --- PERFORMANCE PROGRESSION CURVES FOR EACH ISLAND ---
            const islands = [...new Set(programs.filter(p => p.island_idx != null).map(p => p.island_idx))].sort((a,b) => a-b);
            const numIslands = islands.length;

            // Get y-axis range values from controls
            const yMinInput = document.getElementById('island-y-min');
            const yMaxInput = document.getElementById('island-y-max');
            const yMinValue = yMinInput && yMinInput.value !== '' ? parseFloat(yMinInput.value) : null;
            const yMaxValue = yMaxInput && yMaxInput.value !== '' ? parseFloat(yMaxInput.value) : null;
            
            // Create progression curves for each island
            createIslandProgressionCurves(curvesContainer, programs, islands, yMinValue, yMaxValue);

            // --- TREE PLOT LOGIC FOR EACH ISLAND ---

            const width = plotContainer.node().getBoundingClientRect().width;
            const height = plotContainer.node().getBoundingClientRect().height;

            const svg = plotContainer.append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height]);

            const g = svg.append("g");
            
            // Zoom behavior
            svg.call(d3.zoom().on("zoom", (event) => g.attr("transform", event.transform)));

            // Use the same color scheme as the main tree plot
            const islandColors = [
                "#1f77b4", // blue
                "#2ca02c", // green  
                "#9467bd", // purple
                "#8c564b", // brown
                "#e377c2", // pink
                "#7f7f7f", // gray
                "#bcbd22", // olive
                "#17becf", // cyan
                "#aec7e8"  // light blue
            ];
            const color = d3.scaleOrdinal(islandColors);

            // Performance metrics
            const scores = programs.map(p => p.combined_score).filter(s => s != null && !isNaN(s));
            const minScore = scores.length > 0 ? Math.min(...scores) : 0;
            const maxScore = scores.length > 0 ? Math.max(...scores) : 1;
            const colorScale = d3.scaleSequential(d3.interpolateViridis).domain([minScore, maxScore]);
            
            const shapeMap = {
                'init': d3.symbolDiamond,
                'full': d3.symbolCircle,
                'diff': d3.symbolSquare,
                'cross': d3.symbolCross
            };
            const getShape = (patchType) => shapeMap[patchType] || d3.symbolCircle;
            const symbol = d3.symbol().size(1500); // Smaller size for island trees

            // Calculate island layout
            const margin = { top: 80, right: 20, bottom: 20, left: 20 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;
            
            const islandWidth = plotWidth / numIslands;
            const islandCenters = islands.map((d, i) => margin.left + (i + 0.5) * islandWidth);

            // Create a copy of programs data to avoid modifying the original
            const programsCopy = programs.map(d => ({...d}));

            // Group programs by island using the copy
            const programsByIsland = {};
            islands.forEach(island => {
                programsByIsland[island] = programsCopy.filter(p => p.island_idx === island);
            });

            // Draw island backgrounds
            g.selectAll(".island-bg")
                .data(islands)
                .enter().append("rect")
                .attr("class", "island-bg")
                .attr("x", (d, i) => margin.left + i * islandWidth + 10)
                .attr("y", margin.top + 10)
                .attr("width", islandWidth - 20)
                .attr("height", plotHeight - 20)
                .attr("fill", d => color(d))
                .attr("fill-opacity", 0.05)
                .attr("stroke", d => color(d))
                .attr("stroke-width", 2)
                .attr("stroke-opacity", 0.3)
                .attr("rx", 12);

            // Island headers
            const headerGroup = g.selectAll(".island-header")
                .data(islands)
                .enter().append("g")
                .attr("class", "island-header")
                .attr("transform", (d, i) => `translate(${islandCenters[i]}, 30)`);

            headerGroup.append("rect")
                .attr("x", -50)
                .attr("y", -15)
                .attr("width", 100)
                .attr("height", 25)
                .attr("fill", d => color(d))
                .attr("fill-opacity", 0.15)
                .attr("stroke", d => color(d))
                .attr("stroke-width", 2)
                .attr("rx", 6);

            headerGroup.append("text")
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("fill", d => color(d))
                .text(d => `Island ${d}`);

            // Create tree layout for each island
            islands.forEach((islandId, islandIndex) => {
                const islandPrograms = programsByIsland[islandId];
                if (islandPrograms.length === 0) return;

                // Create a node map for this island
                const nodeMap = new Map(islandPrograms.map(node => [node.id, node]));
                
                // Create completely isolated hierarchical data for this island
                let hierarchyData = JSON.parse(JSON.stringify(islandPrograms));
                
                // Clear parent_id for nodes whose parent is not in the same island
                // This only affects the hierarchyData copy, not the original data
                hierarchyData.forEach(node => {
                    if (node.parent_id && !nodeMap.has(node.parent_id)) {
                        node.parent_id = null; // Make it a root node in this island's view only
                    }
                });
                
                // Find root nodes (nodes with no parent_id)
                const rootNodes = hierarchyData.filter(n => !n.parent_id);

                // If there are multiple root nodes, create a virtual root
                const virtualRootId = `___virtual_root_island_${islandId}___`;
                if (rootNodes.length > 1) {
                    // Create virtual root node that won't interfere with original data
                    const virtualRoot = { 
                        id: virtualRootId, 
                        parent_id: '', 
                        agent_name: 'VIRTUAL ROOT', 
                        isVirtual: true, 
                        generation: -1,
                        island_idx: islandId,
                        metadata: { patch_type: 'virtual', patch_name: 'Virtual Root' }
                    };
                    
                    // Create a completely new hierarchy data array with virtual root connections
                    const newHierarchyData = [];
                    
                    // Add the virtual root first
                    newHierarchyData.push(virtualRoot);
                    
                    // Add all nodes, updating parent_id only for root nodes
                    hierarchyData.forEach(node => {
                        const isRootNode = rootNodes.some(rn => rn.id === node.id);
                        if (isRootNode) {
                            // Create a new object with updated parent_id
                            newHierarchyData.push({
                                ...node,
                                parent_id: virtualRootId
                            });
                        } else {
                            // Keep original node unchanged
                            newHierarchyData.push(node);
                        }
                    });
                    
                    // Replace hierarchyData with the new structure
                    hierarchyData = newHierarchyData;
                }

                // Create tree hierarchy
                const root = d3.stratify()
                    .id(d => d.id)
                    .parentId(d => d.parent_id)
                    (hierarchyData);

                root.sort((a, b) => a.data.generation - b.data.generation || a.data.timestamp - b.data.timestamp);

                // Tree layout settings for this island
                const nodeWidth = 60;
                const nodeHeight = 80;
                const treeLayout = d3.tree().nodeSize([nodeWidth, nodeHeight]);
                treeLayout(root);

                // Calculate bounds for this tree
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                root.each(d => {
                    if (d.x < minX) minX = d.x;
                    if (d.x > maxX) maxX = d.x;
                    if (d.y < minY) minY = d.y;
                    if (d.y > maxY) maxY = d.y;
                });

                // Calculate equal padding on all sides
                const padding = 50; // Equal padding on all sides
                const headerStatsHeight = 60; // Space reserved for header and stats at top
                
                const availableWidth = islandWidth - (2 * padding); // Equal left/right padding
                const availableHeight = plotHeight - headerStatsHeight - (2 * padding); // Equal top/bottom padding after header
                
                const treeWidth = maxX - minX || nodeWidth;
                const treeHeight = maxY - minY || nodeHeight;
                
                const scaleX = availableWidth / Math.max(treeWidth, 1);
                const scaleY = availableHeight / Math.max(treeHeight, 1);
                const scale = Math.min(scaleX, scaleY, 1); // Don't scale up

                // Calculate island boundaries for tree area (excluding header/stats)
                const islandLeft = margin.left + islandIndex * islandWidth + 10 + padding;
                const islandTop = margin.top + 10 + 30; // Start trees much higher, just below headers
                const islandTreeWidth = availableWidth;
                const islandTreeHeight = availableHeight;
                
                // Center the tree within the available tree area
                const treeCenterX = (minX + maxX) / 2;
                const treeCenterY = (minY + maxY) / 2;
                
                const islandTreeCenterX = islandLeft + islandTreeWidth / 2;
                const islandTreeCenterY = islandTop + islandTreeHeight / 2;
                
                // Position the tree so its center aligns with the island tree area center
                const offsetX = islandTreeCenterX - treeCenterX * scale;
                const offsetY = islandTreeCenterY - treeCenterY * scale;

                // Create group for this island's tree
                const islandGroup = g.append("g")
                    .attr("class", `island-tree-${islandId}`)
                    .attr("transform", `translate(${offsetX}, ${offsetY}) scale(${scale})`);

                // Find best node for this island
                const correctNodes = hierarchyData.filter(d => d.correct && d.combined_score !== null);
                let bestNodeInIsland = null;
                if (correctNodes.length > 0) {
                    bestNodeInIsland = correctNodes.reduce((best, current) => 
                        (current.combined_score > best.combined_score) ? current : best);
                }

                // Get ancestor path for best node
                const ancestorIds = new Set();
                if (bestNodeInIsland) {
                    let bestNodeD3 = null;
                    root.each(d => {
                        if (d.data.id === bestNodeInIsland.id) {
                            bestNodeD3 = d;
                        }
                    });
                    if (bestNodeD3) {
                        bestNodeD3.ancestors().forEach(ancestor => {
                            ancestorIds.add(ancestor.data.id);
                        });
                    }
                }

                // Draw links
                const visibleLinks = root.links().filter(d => !d.source.data.isVirtual);
                
                islandGroup.append("g")
                    .attr("class", "links")
                    .selectAll("path")
                    .data(visibleLinks)
                    .enter().append("path")
                    .attr("class", "link")
                    .attr("fill", "none")
                    .style("stroke", d => {
                        const onAncestorPath = ancestorIds.has(d.source.data.id) && ancestorIds.has(d.target.data.id);
                        if (onAncestorPath) {
                            // Double-check: ensure both nodes are correct before orange highlighting
                            const sourceCorrect = d.source.data.correct === true || d.source.data.correct === 'true' || d.source.data.correct === 1;
                            const targetCorrect = d.target.data.correct === true || d.target.data.correct === 'true' || d.target.data.correct === 1;
                            if (sourceCorrect && targetCorrect) {
                                return "#ff8c00";
                            } else {
                                console.log("[DEBUG] Blocking island view orange highlight for incorrect link:", d.source.data.id.substring(0, 8), "->", d.target.data.id.substring(0, 8));
                                return "#999";
                            }
                        }
                        return "#999";
                    })
                    .style("stroke-width", d => (ancestorIds.has(d.source.data.id) && ancestorIds.has(d.target.data.id)) ? 3 : 1)
                    .style("stroke-opacity", d => (ancestorIds.has(d.source.data.id) && ancestorIds.has(d.target.data.id)) ? 1 : 0.6)
                    .attr("d", d3.linkVertical()
                        .x(d => d.x)
                        .y(d => d.y)
                    );

                // Draw nodes
                const visibleNodes = root.descendants().filter(d => !d.data.isVirtual);
                
                const node = islandGroup.append("g")
                    .attr("class", "nodes")
                    .selectAll("g")
                    .data(visibleNodes)
                    .enter().append("g")
                    .attr("class", d => d.data.id === window.bestNodeId ? "node best-node" : "node")
                    .attr("transform", d => `translate(${d.x},${d.y})`)
                    .style("cursor", "pointer")
                    .on('click', (event, d) => {
                        // Update selection highlighting
                        d3.selectAll('.node').classed('selected', false);
                        d3.select(event.currentTarget).classed('selected', true);
                        
                        const selectedNodeId = d.data.id;
                        const selectedAncestors = new Set(d.ancestors().map(n => n.data.id));

                        // Update link styles for this island
                        islandGroup.selectAll('.link')
                            .style("stroke", l => {
                                const onBestPath = ancestorIds.has(l.source.data.id) && ancestorIds.has(l.target.data.id);
                                if (onBestPath) return "#ff8c00";
                                const onSelectedPath = selectedAncestors.has(l.source.data.id) && selectedAncestors.has(l.target.data.id);
                                if (onSelectedPath) return "gold";
                                return "#999";
                            })
                            .style("stroke-width", l => (selectedAncestors.has(l.source.data.id) && selectedAncestors.has(l.target.data.id)) || (ancestorIds.has(l.source.data.id) && ancestorIds.has(l.target.data.id)) ? 3 : 1)
                            .style("stroke-opacity", l => (selectedAncestors.has(l.source.data.id) && selectedAncestors.has(l.target.data.id)) || (ancestorIds.has(l.source.data.id) && ancestorIds.has(l.target.data.id)) ? 1 : 0.6);
                        
                        // Update node styles
                        node.selectAll('path')
                            .style("stroke", n => ancestorIds.has(n.data.id) ? '#ff8c00' : "#000")
                            .style("stroke-width", n => ancestorIds.has(n.data.id) ? 3 : 2)
                            .style("filter", n => n.data.id === window.bestNodeId ? "drop-shadow(0px 2px 4px rgba(255, 140, 0, 0.3))" : "drop-shadow(0px 1px 2px rgba(0,0,0,0.2))");
                        
                        node.filter('.selected')
                            .select('path')
                            .style("stroke", "#e58e26").style("stroke-width", 3)
                            .style("filter", "drop-shadow(0px 2px 4px rgba(229, 130, 38, 0.4))");

                        // Always use the original node data from window.treeData, not the modified hierarchy data
                        const originalNodeData = window.treeData.find(node => node.id === d.data.id);
                        if (originalNodeData) {
                            displayNodeDetails(originalNodeData);
                        } else {
                            console.error("[DEBUG] Could not find original node data for:", d.data.id);
                            displayNodeDetails(d.data);
                        }
                        document.querySelector('.tab[data-tab="agent-code"]').click();
                    });

                // Add hover tooltips
                node.on('mouseover', (event, d) => {
                    const tooltip = d3.select("body").append("div")
                        .attr("class", "node-tooltip")
                        .style("opacity", 0)
                        .style("background", "rgba(0,0,0,0.8)")
                        .style("color", "white")
                        .style("padding", "8px 12px")
                        .style("border-radius", "6px")
                        .style("font-size", "12px")
                        .style("position", "absolute")
                        .style("pointer-events", "none")
                        .style("z-index", "1000");

                    tooltip.transition().duration(200).style("opacity", 1);
                    
                    const patchName = d.data.metadata.patch_name || 'unnamed';
                    const score = formatScore(d.data.combined_score);
                    const patchType = d.data.metadata.patch_type || 'N/A';
                    const islandIdx = d.data.island_idx;
                    
                    tooltip.html(`
                        <strong style="color: #58a6ff; font-size: 13px;">${patchName}</strong><br>
                        <strong>Score:</strong> ${score}<br>
                        <strong>Type:</strong> ${patchType}<br>
                        <strong>Island:</strong> ${islandIdx}
                    `)
                    .style("left", (event.pageX + 15) + "px")
                    .style("top", (event.pageY - 10) + "px");
                })
                .on('mousemove', (event) => {
                    d3.select(".node-tooltip")
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on('mouseout', () => {
                    d3.selectAll(".node-tooltip").transition().duration(200).style("opacity", 0).remove();
                });

                // Draw node shapes
                node.append("path")
                    .attr("d", d => {
                        symbol.type(getShape(d.data.metadata.patch_type));
                        return symbol();
                    })
                    .style("fill", d => {
                        if (d.data.id === window.bestNodeId) return '#ffd700';
                        if (!d.data.correct) return '#e74c3c';
                        const score = d.data.combined_score;
                        if (score !== null && !isNaN(score)) {
                            return colorScale(score);
                        }
                        return '#3498db';
                    })
                    .style("stroke", d => {
                        const onAncestorPath = ancestorIds.has(d.data.id);
                        if (onAncestorPath) {
                            // Double-check: ensure node is correct before orange highlighting
                            const nodeCorrect = d.data.correct === true || d.data.correct === 'true' || d.data.correct === 1;
                            if (nodeCorrect) {
                                return '#ff8c00';
                            } else {
                                console.log("[DEBUG] Blocking island view orange highlight for incorrect node:", d.data.id.substring(0, 8), "correct:", d.data.correct);
                                return "#000";
                            }
                        }
                        return "#000";
                    })
                    .style("stroke-width", d => ancestorIds.has(d.data.id) ? 3 : 2)
                    .style("filter", d => d.data.id === window.bestNodeId ? "drop-shadow(0px 2px 4px rgba(255, 140, 0, 0.3))" : "drop-shadow(0px 1px 2px rgba(0,0,0,0.2))");

                // Add animated rings for the SINGLE best node (island view)
                if (window.allBestPaths && window.allBestPaths.length > 0) {
                    // FORCE SINGLE PATH: Only process the first path, always use orange
                    const singlePath = window.allBestPaths[0];
                    [singlePath].forEach((path, index) => {
                        const pathColor = '#ff8c00'; // Always orange for single path
                        const shadowColor = 'rgba(255, 140, 0, 0.2)'; // Always orange shadow
                        
                        node.filter(d => d.data.id === path.nodeId)
                            .insert("circle", ":first-child")
                            .attr("r", 18)
                            .style("fill", "none")
                            .style("stroke", pathColor)
                            .style("stroke-width", 2)
                            .style("stroke-dasharray", "4,2")
                            .style("opacity", 0.8)
                            .style("filter", `drop-shadow(0px 1px 2px ${shadowColor})`)
                            .style("animation", "pulse 2s infinite");
                    });
                } else {
                    // Fallback: add ring for the single best node if no paths detected
                    node.filter(d => d.data.id === window.bestNodeId)
                        .insert("circle", ":first-child")
                        .attr("r", 18).style("fill", "none").style("stroke", "#ff8c00")
                        .style("stroke-width", 2).style("stroke-dasharray", "4,2").style("opacity", 0.8)
                        .style("filter", "drop-shadow(0px 1px 2px rgba(255, 140, 0, 0.2))")
                        .style("animation", "pulse 2s infinite");
                }

                // Add generation labels (centered in nodes)
                node.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("dy", "0.35em")
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px").style("font-weight", "bold").style("fill", "white")
                    .style("pointer-events", "none")
                    .style("text-shadow", "1px 1px 1px rgba(0,0,0,0.5)")
                    .text(d => d.data.generation);
            });

            // Add island statistics using the copy
            const islandStats = islands.map(island_idx => {
                const islandPrograms = programsCopy.filter(p => p.island_idx === island_idx);
                const islandScores = islandPrograms.map(p => p.combined_score).filter(s => s != null);
                return {
                    island_idx: island_idx,
                    count: islandPrograms.length,
                    avgScore: islandScores.length > 0 ? d3.mean(islandScores) : null,
                    bestScore: islandScores.length > 0 ? d3.max(islandScores) : null
                };
            });

            const statsGroup = g.selectAll(".island-stats")
                .data(islandStats)
                .enter().append("g")
                .attr("class", "island-stats")
                .attr("transform", (d, i) => `translate(${islandCenters[i]}, 55)`);
            
            // Stats background
            statsGroup.append("rect")
                .attr("x", -40)
                .attr("y", -2)
                .attr("width", 80)
                .attr("height", 24)
                .attr("fill", "white")
                .attr("fill-opacity", 0.9)
                .attr("stroke", "#dee2e6")
                .attr("stroke-width", 1)
                .attr("rx", 4);

            statsGroup.append("text")
                .attr("y", 6)
                .attr("text-anchor", "middle").style("font-size", "9px").style("font-weight", "600")
                .text(d => `${d.count} programs`);

            statsGroup.append("text")
                .attr("y", 16).attr("text-anchor", "middle").style("font-size", "8px").style("fill", "#666")
                .text(d => `Best: ${d.bestScore ? d.bestScore.toFixed(2) : 'N/A'}`);

            // --- SUMMARY LOGIC ---
            const allProgramMigrations = [];
            data.forEach(p => {
                if (p.migration_history && p.migration_history.length > 0) {
                    p.migration_history.forEach(m => {
                        allProgramMigrations.push({ 
                            migration_gen: m.generation, 
                            from: m.from,
                            to: m.to,
                            program_id: p.id,
                            program_gen: p.generation,
                            score: p.combined_score
                        });
                    });
                }
            });
            if (allProgramMigrations.length === 0) {
                summaryContainer.html('<h5 style="margin-top:0;">Migration Summary</h5><p style="color: #666; font-size: 14px;">No migration events have been recorded.</p>');
            } else {
                const migrationsByGen = {};
                allProgramMigrations.forEach(m => {
                    if (!migrationsByGen[m.migration_gen]) {
                        migrationsByGen[m.migration_gen] = [];
                    }
                    migrationsByGen[m.migration_gen].push(m);
                });

                const sortedGenerations = Object.keys(migrationsByGen).map(Number).sort((a, b) => a - b);
                
                let summaryHtml = `
                    <h5 style="margin-top:0; margin-bottom: 10px;">Migration Summary</h5>
                    <table class="llm-result-table" style="font-size: 13px; table-layout: auto;">
                        <thead>
                            <tr>
                                <th style="width: 100px;">Generation</th>
                                <th>Migration Details</th>
                                <th style="width: 120px;">Total Migrated</th>
                            </tr>
                        </thead>
                        <tbody>`;

                sortedGenerations.forEach(gen => {
                    const events = migrationsByGen[gen];
                    events.sort((a,b) => (a.from - b.from) || (a.to - b.to));
                    
                    const detailsString = events.map(p => {
                        const shortId = p.program_id.substring(0, 8) + '...';
                        const score = (p.score !== null && p.score !== undefined) ? p.score.toFixed(2) : 'N/A';
                        const link = `<a href="#" onclick="event.preventDefault(); selectNodeById('${p.program_id}');" style="color: #007bff; text-decoration: underline;">${shortId}</a>`;
                        return `Gen ${p.program_gen}, Program: ${link}, Score: ${score} (${p.from} ‚Üí ${p.to})`;
                    }).join('<br>');

                    const totalCount = events.length;
                    
                    summaryHtml += `
                        <tr>
                            <td>${gen}</td>
                            <td>${detailsString}</td>
                            <td>${totalCount}</td>
                        </tr>`;
                });

                summaryHtml += `</tbody></table>`;
                summaryContainer.html(summaryHtml);
            }
        }

        function createBestPathVisualization(data) {
            console.log("[DEBUG] Creating best path visualization");
            
            // Check if the best path tab is visible
            const bestPathView = document.getElementById('best-path-view');
            if (!bestPathView || !bestPathView.classList.contains('active')) {
                console.log("[DEBUG] Best path view not active, skipping visualization creation");
                return;
            }

            const container = d3.select("#best-path-container");
            container.html(""); // Clear previous content

            if (!data || data.length === 0) {
                container.append("p").style('text-align', 'center').style('margin-top', '50px').text("No data to visualize.");
                return;
            }

            const correctNodes = data.filter(d => d.correct && d.combined_score !== null);
            let bestNode;
            if (correctNodes.length > 0) {
                bestNode = correctNodes.reduce((best, current) => (current.combined_score > best.combined_score) ? current : best);
            } else {
                bestNode = data.reduce((best, current) => {
                    const currentScore = current.combined_score ? current.combined_score : -Infinity;
                    const bestScore = best.combined_score ? best.combined_score : -Infinity;
                    return (currentScore > bestScore) ? current : best;
                }, { combined_score: -Infinity });
            }
            
            if (!bestNode || !bestNode.id) {
                 container.append("p").style('text-align', 'center').style('margin-top', '50px').text("Could not determine the best node.");
                return;
            }

            const nodeMap = new Map(data.map(node => [node.id, node]));
            const path = [];
            let currentNode = bestNode;

            while (currentNode) {
                path.unshift(currentNode);
                currentNode = nodeMap.get(currentNode.parent_id);
            }

            if (path.length === 0) {
                container.append("p").style('text-align', 'center').style('margin-top', '50px').text("Best path is empty or could not be constructed.");
                return;
            }

            const timeline = container.append("div").attr("class", "best-path-timeline");

            const items = timeline.selectAll(".timeline-item")
                .data(path, d => d.id)
                .enter()
                .append("div")
                .attr("class", "timeline-item")
                .attr("data-node-id", d => d.id)
                .style("cursor", "pointer")
                .on('click', (event, d) => {
                    selectNodeById(d.id, false, false);
                });
            
            items.append("div")
                .attr("class", "timeline-content")
                .html(d => {
                        const description = d.metadata.patch_description ? `<p><strong>Description:</strong> ${d.metadata.patch_description}</p>` : '';
                        return `
                        <h4>Gen ${d.generation}: <span style="font-weight: normal;">${d.metadata.patch_name || 'unnamed'}</span></h4>
                        <p><strong>ID:</strong> <a href="#" onclick="event.preventDefault(); event.stopPropagation(); selectNodeById('${d.id}', false, false);">${d.id}</a></p>
                        <p><strong>Type:</strong> ${d.metadata.patch_type || 'N/A'}</p>
                        <p><strong>Score:</strong> ${formatScore(d.combined_score)}</p>
                        ${description}
                        `;
                });
                

        }

        function createModelPosteriorsVisualization(data) {
            console.log("[DEBUG] ==> createModelPosteriorsVisualization called with data length:", data ? data.length : 'null');
            
            // Check if the model posteriors tab is visible
            const modelPosteriorsView = document.getElementById('model-posteriors-view');
            console.log("[DEBUG] Model posteriors view element:", modelPosteriorsView);
            console.log("[DEBUG] Model posteriors view active:", modelPosteriorsView ? modelPosteriorsView.classList.contains('active') : 'element not found');
            
            if (!modelPosteriorsView || !modelPosteriorsView.classList.contains('active')) {
                console.log("[DEBUG] Model posteriors view not active, skipping visualization creation");
                return;
            }
            
            console.log("[DEBUG] Model posteriors view is active, proceeding with visualization");

            const container = d3.select("#model-posteriors-container");
            
            // Show a loading message immediately
            console.log("[DEBUG] Container found:", container.node());
            
            // Ensure the HTML structure exists - FORCE RECREATION
            console.log("[DEBUG] FORCING HTML structure recreation");
            container.html(`
                <h4 style="margin: 0 0 20px 0; text-align: center;">Number of Programs Proposed by Each Model</h4>
                <div id="model-program-counts-chart" style="width: 100%; height: 400px; overflow-x: auto; margin-bottom: 30px; min-width: 1000px;"></div>
                <h4 style="margin: 0 0 20px 0; text-align: center;">Model Posterior Probabilities Over Generations</h4>
                <div id="model-posteriors-chart" style="width: 100%; height: 400px; overflow-x: auto; min-width: 1000px;"></div>
                <div id="model-posteriors-summary" style="margin-top: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">
                    <h5 style="margin: 0 0 10px 0;">Summary Statistics</h5>
                    <div id="model-posteriors-stats"></div>
                </div>
            `);
            console.log("[DEBUG] HTML structure FORCED. Checking if program counts chart exists now:", !container.select("#model-program-counts-chart").empty());
            console.log("[DEBUG] Program counts container after forced creation:", container.select("#model-program-counts-chart").node());
            
            container.select("#model-posteriors-chart").html("<p style='text-align: center; margin-top: 50px; color: blue;'>Loading model posteriors visualization...</p>");
            container.select("#model-program-counts-chart").html("<p style='text-align: center; margin-top: 50px; color: blue;'>Loading program counts visualization...</p>");
            
            // Debug: Check if the second chart container exists
            console.log("[DEBUG] Program counts chart container found:", !container.select("#model-program-counts-chart").empty());
            console.log("[DEBUG] Program counts chart container node:", container.select("#model-program-counts-chart").node());
            console.log("[DEBUG] Main container HTML:", container.node().innerHTML.substring(0, 500) + "...");
            console.log("[DEBUG] Looking for #model-program-counts-chart in document:", document.getElementById("model-program-counts-chart"));
            console.log("[DEBUG] All elements with id containing 'program':", document.querySelectorAll('[id*="program"]'));
            
            if (!data || data.length === 0) {
                container.select("#model-posteriors-chart").html("<p style='text-align: center; margin-top: 50px;'>No data to visualize.</p>");
                container.select("#model-program-counts-chart").html("<p style='text-align: center; margin-top: 50px;'>No data to visualize.</p>");
                container.select("#model-posteriors-stats").html("No data available.");
                return;
            }

            // Extract model_posteriors data from metadata - try multiple possible locations
            let programsWithPosteriors = data.filter(d => 
                d.metadata && d.metadata.llm_result && d.metadata.llm_result.model_posteriors && 
                typeof d.metadata.llm_result.model_posteriors === 'object' &&
                Object.keys(d.metadata.llm_result.model_posteriors).length > 0
            );
            
            // If no programs found with llm_result structure, try direct metadata structure
            if (programsWithPosteriors.length === 0) {
                programsWithPosteriors = data.filter(d => 
                    d.metadata && d.metadata.model_posteriors && 
                    typeof d.metadata.model_posteriors === 'object' &&
                    Object.keys(d.metadata.model_posteriors).length > 0
                );
                console.log("[DEBUG] Using direct metadata.model_posteriors structure");
            } else {
                console.log("[DEBUG] Using metadata.llm_result.model_posteriors structure");
            }

            if (programsWithPosteriors.length === 0) {
                const programsWithLlmResult = data.filter(d => d.metadata && d.metadata.llm_result);
                const debugInfo = `
                    <p style='text-align: center; margin-top: 20px;'>No model posteriors data found in metadata.</p>
                    <div style='background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-top: 20px;'>
                        <h5>Debug Information:</h5>
                        <ul style='text-align: left;'>
                            <li>Total programs: ${data.length}</li>
                            <li>Programs with llm_result: ${programsWithLlmResult.length}</li>
                            <li>Programs with direct model_posteriors: ${data.filter(d => d.metadata && d.metadata.model_posteriors).length}</li>
                        </ul>
                        <p><small>Check the browser console for more detailed debugging information.</small></p>
                    </div>
                `;
                container.select("#model-posteriors-chart").html(debugInfo);
                container.select("#model-program-counts-chart").html("<p style='text-align: center; margin-top: 50px;'>No model posteriors data available for program counts chart.</p>");
                container.select("#model-posteriors-stats").html("No model posteriors data available.");
                console.log("[DEBUG] *** EARLY RETURN - NO POSTERIORS DATA ***");
                return;
            }

            console.log(`[DEBUG] Found ${programsWithPosteriors.length} programs with model posteriors data`);
            
            // Debug: Log first few programs to understand data structure
            if (data.length > 0) {
                console.log("[DEBUG] Total programs:", data.length);
                console.log("[DEBUG] Sample program metadata structure:", data[0].metadata);
                
                const programsWithLlmResult = data.filter(d => d.metadata && d.metadata.llm_result);
                console.log(`[DEBUG] Programs with llm_result: ${programsWithLlmResult.length}`);
                
                if (programsWithLlmResult.length > 0) {
                    console.log("[DEBUG] Sample llm_result:", programsWithLlmResult[0].metadata.llm_result);
                    console.log("[DEBUG] Sample llm_result keys:", Object.keys(programsWithLlmResult[0].metadata.llm_result));
                    
                    if (programsWithLlmResult[0].metadata.llm_result.model_posteriors) {
                        console.log("[DEBUG] Sample model_posteriors:", programsWithLlmResult[0].metadata.llm_result.model_posteriors);
                        console.log("[DEBUG] Model_posteriors type:", typeof programsWithLlmResult[0].metadata.llm_result.model_posteriors);
                        console.log("[DEBUG] Model_posteriors keys:", Object.keys(programsWithLlmResult[0].metadata.llm_result.model_posteriors));
                    } else {
                        console.log("[DEBUG] No model_posteriors in llm_result");
                    }
                }
                
                // Check if any programs have the exact structure we're looking for
                const exactMatch = data.filter(d => 
                    d.metadata && 
                    d.metadata.llm_result && 
                    d.metadata.llm_result.model_posteriors && 
                    typeof d.metadata.llm_result.model_posteriors === 'object'
                );
                console.log(`[DEBUG] Programs with exact model_posteriors structure: ${exactMatch.length}`);
                
                // Also check for alternative structures
                const altStructure1 = data.filter(d => d.metadata && d.metadata.model_posteriors);
                console.log(`[DEBUG] Programs with direct metadata.model_posteriors: ${altStructure1.length}`);
            }

            // Helper function to get model_posteriors from program data
            const getModelPosteriors = (program) => {
                if (program.metadata.llm_result && program.metadata.llm_result.model_posteriors) {
                    return program.metadata.llm_result.model_posteriors;
                } else if (program.metadata.model_posteriors) {
                    return program.metadata.model_posteriors;
                }
                return {};
            };

            // Get all unique models across all programs
            const allModels = new Set();
            programsWithPosteriors.forEach(d => {
                Object.keys(getModelPosteriors(d)).forEach(model => {
                    allModels.add(model);
                });
            });
            const models = Array.from(allModels).sort();
            
            console.log("[DEBUG] Found models:", models);
            console.log("[DEBUG] Sample model posteriors from first program:", getModelPosteriors(programsWithPosteriors[0]));

            // Group data by generation
            const generationData = {};
            programsWithPosteriors.forEach(d => {
                const gen = d.generation;
                if (!generationData[gen]) {
                    generationData[gen] = [];
                }
                generationData[gen].push(d);
            });

            const generations = Object.keys(generationData).map(Number).sort((a, b) => a - b);

            // Calculate average posteriors per generation per model
            const chartData = [];
            generations.forEach(gen => {
                const genPrograms = generationData[gen];
                
                models.forEach(model => {
                    const programsWithThisModel = genPrograms.filter(p => {
                        const posteriors = getModelPosteriors(p);
                        return posteriors[model] !== undefined && posteriors[model] !== null;
                    });
                    const modelPosteriors = programsWithThisModel.map(p => getModelPosteriors(p)[model]);
                    
                    if (modelPosteriors.length > 0) {
                        const avgPosterior = modelPosteriors.reduce((sum, val) => sum + val, 0) / modelPosteriors.length;
                        
                        // Count programs that were actually generated by this model
                        const programsGeneratedByModel = genPrograms.filter(p => {
                            // Try multiple possible locations for model name
                            const modelName = p.metadata?.model_name || 
                                            p.metadata?.llm_result?.model || 
                                            p.metadata?.model ||
                                            p.model_name ||
                                            p.model;
                            return modelName === model;
                        });
                        
                        // Debug logging for first generation
                        if (gen === generations[0] && model === models[0]) {
                            console.log("[DEBUG] Sample program metadata for count calculation:", genPrograms[0]?.metadata);
                            console.log("[DEBUG] Looking for model:", model);
                            console.log("[DEBUG] Found programs for", model, ":", programsGeneratedByModel.length);
                            console.log("[DEBUG] Sample model names found:", genPrograms.slice(0, 3).map(p => ({
                                model_name: p.metadata?.model_name,
                                llm_model: p.metadata?.llm_result?.model,
                                metadata_model: p.metadata?.model,
                                direct_model: p.model
                            })));
                        }
                        
                        // Fallback: if no programs found by model_name, use programs with posteriors for this model
                        const finalCount = programsGeneratedByModel.length > 0 ? 
                                         programsGeneratedByModel.length : 
                                         programsWithThisModel.length;
                        
                        chartData.push({
                            generation: gen,
                            model: model,
                            posterior: avgPosterior,
                            count: finalCount,
                            actualCount: programsGeneratedByModel.length,
                            posteriorCount: programsWithThisModel.length
                        });
                    }
                });
            });

            console.log("[DEBUG] Total chart data points:", chartData.length);
            console.log("[DEBUG] Chart data sample:", chartData.slice(0, 5));
            console.log("[DEBUG] Chart data count analysis:");
            
            // Helper function to reduce number of ticks to prevent overlap when there are many generations
            const getReducedTicks = (generations, maxTicks = 10) => {
                if (generations.length <= maxTicks) return generations;
                const step = Math.ceil(generations.length / maxTicks);
                return generations.filter((_, i) => i % step === 0 || i === generations.length - 1);
            };
            models.forEach(model => {
                const modelData = chartData.filter(d => d.model === model);
                console.log(`[DEBUG] Model ${model}: ${modelData.length} generations, counts: ${modelData.map(d => d.count).join(', ')}`);
                console.log(`[DEBUG] Model ${model}: total programs generated = ${modelData.reduce((sum, d) => sum + d.count, 0)}`);
            });
            
            // Also debug the model_name distribution in the first generation
            if (generations.length > 0) {
                const firstGen = generationData[generations[0]];
                console.log(`[DEBUG] First generation (${generations[0]}) model distribution:`);
                const modelCounts = {};
                firstGen.forEach(p => {
                    const modelName = p.metadata && p.metadata.model_name;
                    if (modelName) {
                        modelCounts[modelName] = (modelCounts[modelName] || 0) + 1;
                    } else {
                        modelCounts['NO_MODEL_NAME'] = (modelCounts['NO_MODEL_NAME'] || 0) + 1;
                    }
                });
                Object.entries(modelCounts).forEach(([model, count]) => {
                    console.log(`[DEBUG] ${model}: ${count} programs`);
                });
            }

            // Clear previous chart
            container.select("#model-posteriors-chart").html("");

            // Set up dimensions with more horizontal space (reduced top margin since legend moved to counts chart)
            const margin = {top: 0, right: 20, bottom: 40, left: 60};
            const width = 1000 - margin.left - margin.right; // Increased from 800
            const height = 400 - margin.top - margin.bottom;

            // Create SVG
            const svg = container.select("#model-posteriors-chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Set up scales
            const xScale = d3.scaleLinear()
                .domain(d3.extent(generations))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, 1])
                .range([height, 0]);

            const colorScale = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(models);

            // Add axes with custom tick values for generations
            const uniqueGenerations = [...new Set(generations)].sort((a, b) => a - b);
            const reducedGenerations = getReducedTicks(uniqueGenerations);
            
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickValues(reducedGenerations)
                    .tickFormat(d3.format("d")));

            g.append("g")
                .call(d3.axisLeft(yScale));

            // Add axis labels
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Average Model Posterior");

            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + margin.bottom})`)
                .style("text-anchor", "middle")
                .text("Generation");

            // Create line generator
            const line = d3.line()
                .x(d => xScale(d.generation))
                .y(d => yScale(d.posterior))
                .curve(d3.curveMonotoneX);

            // Group data by model
            const modelData = {};
            chartData.forEach(d => {
                if (!modelData[d.model]) {
                    modelData[d.model] = [];
                }
                modelData[d.model].push(d);
            });

            // Draw lines for each model
            models.forEach(model => {
                const data = modelData[model] || [];
                if (data.length > 0) {
                    data.sort((a, b) => a.generation - b.generation);
                    
                    g.append("path")
                        .datum(data)
                        .attr("fill", "none")
                        .attr("stroke", colorScale(model))
                        .attr("stroke-width", 2)
                        .attr("d", line);

                    // Add dots
                    g.selectAll(`.dot-${model.replace(/[^a-zA-Z0-9]/g, '_')}`)
                        .data(data)
                        .enter().append("circle")
                        .attr("class", `dot-${model.replace(/[^a-zA-Z0-9]/g, '_')}`)
                        .attr("cx", d => xScale(d.generation))
                        .attr("cy", d => yScale(d.posterior))
                        .attr("r", 4)
                        .attr("fill", colorScale(model))
                        .on("mouseover", function(event, d) {
                            // Create tooltip
                            const tooltip = d3.select("body").append("div")
                                .attr("class", "tooltip")
                                .style("opacity", 0)
                                .style("position", "absolute")
                                .style("background", "rgba(0, 0, 0, 0.8)")
                                .style("color", "white")
                                .style("padding", "8px")
                                .style("border-radius", "4px")
                                .style("font-size", "12px")
                                .style("pointer-events", "none")
                                .style("z-index", "1000");

                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            tooltip.html(`
                                <strong>Model:</strong> ${d.model}<br>
                                <strong>Generation:</strong> ${d.generation}<br>
                                <strong>Percentage:</strong> ${(d.posterior * 100).toFixed(1)}%
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function(d) {
                            d3.selectAll(".tooltip").remove();
                        });
                }
            });

            // Legend will be added to the counts chart instead (which appears first now)

            console.log("[DEBUG] *** REACHED END OF FIRST CHART CREATION ***");

            // Create second chart: Program counts by model
            console.log("[DEBUG] *** STARTING PROGRAM COUNTS CHART CREATION ***");
            console.log("[DEBUG] Creating program counts chart");
            console.log("[DEBUG] Chart data for counts:", chartData);
            console.log("[DEBUG] Models for counts:", models);
            
            // Test: Add a simple test message to the container
            console.log("[DEBUG] Setting test message in program counts chart");
            const testResult = container.select("#model-program-counts-chart").html("<p style='color: red; font-size: 20px; text-align: center; margin-top: 50px;'>PROGRAM COUNTS CHART SECTION - DEBUGGING</p>");
            console.log("[DEBUG] Test message set result:", testResult);
            console.log("[DEBUG] Program counts container after test:", container.select("#model-program-counts-chart").node());
            
            // Check if we have any count data
            const totalCounts = chartData.reduce((sum, d) => sum + d.count, 0);
            console.log("[DEBUG] Total program counts across all data:", totalCounts);
            
            // Clear previous chart and create cumulative program counts plot
            console.log("[DEBUG] Creating cumulative program counts chart");
            container.select("#model-program-counts-chart").html("");
            
            // DEBUG: Let's look at the actual program data instead of chartData
            console.log("[DEBUG] Sample programs from original data:", programsWithPosteriors.slice(0, 3).map(p => ({
                generation: p.generation,
                model_name: p.metadata?.model_name,
                llm_model: p.metadata?.llm_result?.model,
                metadata_model: p.metadata?.model,
                id: p.id
            })));
            
            // Calculate ACTUAL program counts by generation and model from raw data
            const actualGenerationCounts = {};
            programsWithPosteriors.forEach(program => {
                const gen = program.generation;
                if (!actualGenerationCounts[gen]) actualGenerationCounts[gen] = {};
                
                // Try to find the actual model that generated this program
                const actualModel = program.metadata?.model_name || 
                                  program.metadata?.llm_result?.model || 
                                  program.metadata?.model ||
                                  program.model_name ||
                                  program.model;
                
                if (actualModel) {
                    if (!actualGenerationCounts[gen][actualModel]) actualGenerationCounts[gen][actualModel] = 0;
                    actualGenerationCounts[gen][actualModel]++;
                } else {
                    console.log("[DEBUG] No model found for program:", program.id);
                }
            });
            
            console.log("[DEBUG] Actual generation counts:", actualGenerationCounts);
            
            // Get all generations that have actual program data
            const actualSortedGens = Object.keys(actualGenerationCounts).map(Number).sort((a, b) => a - b);
            console.log("[DEBUG] Actual sorted generations:", actualSortedGens);
            
            // Get all models that actually generated programs
            const actualModels = new Set();
            Object.values(actualGenerationCounts).forEach(genData => {
                Object.keys(genData).forEach(model => actualModels.add(model));
            });
            const actualModelsArray = Array.from(actualModels).sort();
            console.log("[DEBUG] Models that actually generated programs:", actualModelsArray);
            
            // Calculate cumulative counts for each ACTUAL model
            const cumulativeData = {};
            actualModelsArray.forEach(model => {
                cumulativeData[model] = [];
                let cumulativeCount = 0;
                
                actualSortedGens.forEach(gen => {
                    const genCount = actualGenerationCounts[gen][model] || 0;
                    cumulativeCount += genCount;
                    cumulativeData[model].push({
                        generation: gen,
                        cumulativeCount: cumulativeCount,
                        genCount: genCount
                    });
                });
                
                console.log(`[DEBUG] Model ${model.split('/').pop()}: ${cumulativeData[model].length} data points, final cumulative: ${cumulativeCount}`);
            });
            
            console.log("[DEBUG] Cumulative data summary:", Object.keys(cumulativeData).map(model => ({
                model: model.split('/').pop(), // Short name
                points: cumulativeData[model].length,
                finalCount: cumulativeData[model][cumulativeData[model].length - 1]?.cumulativeCount || 0
            })));
            
            // Create SVG for cumulative counts chart (same width as posteriors chart for alignment)
            const countsSvg = container.select("#model-program-counts-chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            // Use smaller top margin for counts chart to reduce space between title and plot
            const countsTopMargin = 30; // Reduced from 70
            const countsG = countsSvg.append("g")
                .attr("transform", `translate(${margin.left},${countsTopMargin})`);

            // Set up scales for cumulative counts chart using actual data
            const countsXScale = d3.scaleLinear()
                .domain(d3.extent(actualSortedGens))
                .range([0, width]);

            // Find maximum cumulative count across all models
            const maxCumulativeCount = d3.max(Object.values(cumulativeData), modelData => 
                d3.max(modelData, d => d.cumulativeCount)
            );
            
            // Adjust height for the smaller top margin
            const countsHeight = height + (margin.top - countsTopMargin); // Add back the space we saved
            const countsYScale = d3.scaleLinear()
                .domain([0, maxCumulativeCount])
                .range([countsHeight, 0]);
                
            console.log("[DEBUG] Cumulative chart scales - X domain:", d3.extent(actualSortedGens), "Y domain:", [0, maxCumulativeCount]);

            // Add axes for cumulative counts chart (styled like posteriors chart)
            // Use the same tick reduction logic for consistency
            const reducedCountsGenerations = getReducedTicks(actualSortedGens);
            
            countsG.append("g")
                .attr("transform", `translate(0,${countsHeight})`)
                .call(d3.axisBottom(countsXScale)
                    .tickValues(reducedCountsGenerations)
                    .tickFormat(d3.format("d")))
                .selectAll("line")
                .style("stroke", "#ddd");

            countsG.append("g")
                .call(d3.axisLeft(countsYScale))
                .selectAll("line")
                .style("stroke", "#ddd");

            // Add axis labels for cumulative counts chart (matching posteriors plot style)
            countsG.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (countsHeight / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Cumulative Number of Programs");

            countsG.append("text")
                .attr("transform", `translate(${width / 2}, ${countsHeight + margin.bottom})`)
                .style("text-anchor", "middle")
                .text("Generation");

            // Add legend at the top with automatic layout (moved from posterior chart)
            const legend = countsSvg.append("g")
                .attr("transform", `translate(0, 0)`);

            // First, create temporary text elements to measure widths
            const tempTexts = actualModelsArray.map(model => {
                const tempText = legend.append("text")
                    .style("font-size", "12px")
                    .style("font-family", "monospace")
                    .style("opacity", 0)
                    .text(model);
                const width = tempText.node().getBBox().width;
                tempText.remove();
                return { model, textWidth: width };
            });

            // Calculate layout parameters
            const iconWidth = 15;
            const iconTextGap = 8;
            const itemSpacing = 30;
            const totalSvgWidth = width + margin.left + margin.right;
            
            // Calculate item widths (icon + gap + text + spacing)
            const itemWidths = tempTexts.map(d => iconWidth + iconTextGap + d.textWidth + itemSpacing);
            
            // Arrange items in rows to fit within the available width
            const rows = [];
            let currentRow = [];
            let currentRowWidth = 0;
            
            itemWidths.forEach((itemWidth, i) => {
                if (currentRowWidth + itemWidth > totalSvgWidth - 20 && currentRow.length > 0) {
                    // Start new row
                    rows.push([...currentRow]);
                    currentRow = [i];
                    currentRowWidth = itemWidth;
                } else {
                    currentRow.push(i);
                    currentRowWidth += itemWidth;
                }
            });
            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            // Draw the legend items
            rows.forEach((rowItems, rowIndex) => {
                const rowWidth = rowItems.reduce((sum, i) => sum + itemWidths[i], 0) - itemSpacing;
                const startX = (totalSvgWidth - rowWidth) / 2; // Center each row
                
                let currentX = startX;
                rowItems.forEach(modelIndex => {
                    const model = actualModelsArray[modelIndex];
                    const legendItem = legend.append("g")
                        .attr("transform", `translate(${currentX}, ${rowIndex * 22})`);

                    legendItem.append("rect")
                        .attr("width", iconWidth)
                        .attr("height", iconWidth)
                        .attr("fill", colorScale(model));

                    legendItem.append("text")
                        .attr("x", iconWidth + iconTextGap)
                        .attr("y", 12)
                        .style("font-size", "12px")
                        .style("font-family", "monospace")
                        .text(model);

                    currentX += itemWidths[modelIndex];
                });
            });

            // Create line generator for cumulative counts
            const cumulativeLine = d3.line()
                .x(d => countsXScale(d.generation))
                .y(d => countsYScale(d.cumulativeCount))
                .curve(d3.curveMonotoneX);

            // Draw cumulative lines for each ACTUAL model
            actualModelsArray.forEach((model, modelIndex) => {
                const modelData = cumulativeData[model];
                if (!modelData || modelData.length === 0) {
                    console.log(`[DEBUG] Skipping ${model}: no data`);
                    return;
                }

                console.log(`[DEBUG] Drawing line ${modelIndex + 1}/${models.length} for ${model.split('/').pop()}, data points:`, modelData.length, "color:", colorScale(model));

                // Filter out any invalid data points
                const validData = modelData.filter(d => 
                    d.generation != null && d.cumulativeCount != null && 
                    !isNaN(d.generation) && !isNaN(d.cumulativeCount)
                );
                
                console.log(`[DEBUG] Valid data points for ${model.split('/').pop()}:`, validData.length);
                
                if (validData.length === 0) return;

                // Add cumulative line (styled like posteriors chart)
                const path = countsG.append("path")
                    .datum(validData)
                    .attr("fill", "none")
                    .attr("stroke", colorScale(model))
                    .attr("stroke-width", 2)
                    .attr("d", cumulativeLine);
                
                console.log(`[DEBUG] Path created for ${model.split('/').pop()}, path element:`, path.node());

                // Add dots for each data point
                countsG.selectAll(`.cumulative-dot-${model.replace(/[^a-zA-Z0-9]/g, '_')}`)
                    .data(validData)
                    .enter().append("circle")
                    .attr("class", `cumulative-dot-${model.replace(/[^a-zA-Z0-9]/g, '_')}`)
                    .attr("cx", d => countsXScale(d.generation))
                    .attr("cy", d => countsYScale(d.cumulativeCount))
                    .attr("r", 4)
                    .attr("fill", colorScale(model))
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1)
                    .on("mouseover", function(event, d) {
                        // Create tooltip
                        const tooltip = d3.select("body").append("div")
                            .attr("class", "tooltip")
                            .style("opacity", 0)
                            .style("position", "absolute")
                            .style("background", "rgba(0, 0, 0, 0.8)")
                            .style("color", "white")
                            .style("padding", "8px")
                            .style("border-radius", "4px")
                            .style("font-size", "12px")
                            .style("pointer-events", "none")
                            .style("z-index", "1000");

                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        
                        tooltip.html(`
                            <strong>Model:</strong> ${model}<br>
                            <strong>Generation:</strong> ${d.generation}<br>
                            <strong>Cumulative Programs:</strong> ${d.cumulativeCount}<br>
                            <strong>This Generation:</strong> ${d.genCount}
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        d3.selectAll(".tooltip").remove();
                    });
            });
            // No legend for the program counts chart (legend only on posteriors chart)
            console.log("[DEBUG] *** CUMULATIVE PROGRAM COUNTS CHART COMPLETED ***");
            // Update summary statistics
            const statsContainer = container.select("#model-posteriors-stats");
            statsContainer.html("");
            
            const statsTable = statsContainer.append("table")
                .style("width", "100%")
                .style("border-collapse", "collapse");

            const headerRow = statsTable.append("tr");
            headerRow.append("th").style("border", "1px solid #ddd").style("padding", "8px").text("Model");
            headerRow.append("th").style("border", "1px solid #ddd").style("padding", "8px").text("Total Programs");
            headerRow.append("th").style("border", "1px solid #ddd").style("padding", "8px").text("Avg Posterior");
            headerRow.append("th").style("border", "1px solid #ddd").style("padding", "8px").text("Min Posterior");
            headerRow.append("th").style("border", "1px solid #ddd").style("padding", "8px").text("Max Posterior");

            models.forEach(model => {
                const modelPosteriors = chartData
                    .filter(d => d.model === model)
                    .map(d => d.posterior);
                
                if (modelPosteriors.length > 0) {
                    // Calculate ACTUAL total programs generated by this model
                    let actualTotalPrograms = 0;
                    if (cumulativeData && cumulativeData[model]) {
                        // Get the final cumulative count for this model
                        const finalData = cumulativeData[model][cumulativeData[model].length - 1];
                        actualTotalPrograms = finalData ? finalData.cumulativeCount : 0;
                    }
                    
                    const avgPosterior = modelPosteriors.reduce((sum, val) => sum + val, 0) / modelPosteriors.length;
                    const minPosterior = Math.min(...modelPosteriors);
                    const maxPosterior = Math.max(...modelPosteriors);

                    const row = statsTable.append("tr");
                    row.append("td").style("border", "1px solid #ddd").style("padding", "8px").text(model);
                    row.append("td").style("border", "1px solid #ddd").style("padding", "8px").text(actualTotalPrograms);
                    row.append("td").style("border", "1px solid #ddd").style("padding", "8px").text(avgPosterior.toFixed(4));
                    row.append("td").style("border", "1px solid #ddd").style("padding", "8px").text(minPosterior.toFixed(4));
                    row.append("td").style("border", "1px solid #ddd").style("padding", "8px").text(maxPosterior.toFixed(4));
                }
            });

            console.log("[DEBUG] Model posteriors visualization created successfully");
        }

        function createClusterPlots(data) {
            console.log("[DEBUG] Creating cluster plots");
            
            // Check if the clusters tab is visible
            const clustersView = document.getElementById('clusters-view');
            if (!clustersView || !clustersView.classList.contains('active')) {
                console.log("[DEBUG] Clusters view not active, skipping visualization creation");
                return;
            }
            
            const programsWithEmbeddings = data.filter(p =>
                p.correct &&
                p.embedding_pca_2d && p.embedding_pca_2d.length === 2 &&
                p.embedding_pca_3d && p.embedding_pca_3d.length === 3 &&
                p.embedding_cluster_id !== null && p.combined_score !== null
            );

            if (programsWithEmbeddings.length === 0) {
                document.getElementById('cluster-plot-2d').innerHTML = '<p>No programs with PCA embeddings and cluster IDs found.</p>';
                document.getElementById('cluster-plot-3d').innerHTML = '';
                return;
            }

            const plotContainer2d = document.getElementById('cluster-plot-2d');
            const plotContainer3d = document.getElementById('cluster-plot-3d');
            if (plotContainer2d && plotContainer3d) {
                const containerWidth = plotContainer2d.getBoundingClientRect().width;
                plotContainer2d.style.height = `${containerWidth}px`;
                plotContainer3d.style.height = `${containerWidth}px`;
            }

            const scores = programsWithEmbeddings.map(p => p.combined_score);
            const minScore = Math.min(...scores);
            const maxScore = Math.max(...scores);
            
            const bestProgram = programsWithEmbeddings.reduce((best, current) => (current.combined_score > best.combined_score) ? current : best, programsWithEmbeddings[0]);

            const sizeScale = score => {
                if (maxScore === minScore) return 10;
                return 5 + 15 * (score - minScore) / (maxScore - minScore);
            };
            const sizes = programsWithEmbeddings.map(p => sizeScale(p.combined_score));
            const symbols = programsWithEmbeddings.map(p => p.id === bestProgram.id ? 'star' : 'circle');
            const symbols3d = programsWithEmbeddings.map(p => p.id === bestProgram.id ? 'diamond' : 'circle');
            const borderColors = programsWithEmbeddings.map(p => p.id === bestProgram.id ? 'gold' : 'white');
            const borderWidths = programsWithEmbeddings.map(p => p.id === bestProgram.id ? 3 : 1);

            const uniqueClusterIds = [...new Set(programsWithEmbeddings.map(p => p.embedding_cluster_id))].sort((a,b) => a - b);

            // 2D Plot
            const trace2d = {
                x: programsWithEmbeddings.map(p => p.embedding_pca_2d[0]),
                y: programsWithEmbeddings.map(p => p.embedding_pca_2d[1]),
                customdata: programsWithEmbeddings.map(p => p.id),
                mode: 'markers',
                type: 'scatter',
                text: programsWithEmbeddings.map(p => `<b>${p.metadata.patch_name || 'unnamed'}</b><br>Score: ${formatScore(p.combined_score)}<br>Cluster: ${p.embedding_cluster_id}`),
                hoverinfo: 'text',
                marker: {
                    color: programsWithEmbeddings.map(p => p.embedding_cluster_id),
                    colorscale: 'Portland',
                    showscale: false,
                    size: sizes,
                    symbol: symbols3d,
                    line: {
                        color: borderColors,
                        width: borderWidths
                    }
                }
            };

            const layout2d = {
                title: '2D PCA of Program Embeddings',
                xaxis: { title: 'PC1' },
                yaxis: { 
                    title: 'PC2',
                    scaleanchor: 'x',
                    scaleratio: 1
                },
                margin: { t: 40, b: 40, l: 40, r: 10 },
                paper_bgcolor: '#f8f9fa',
                plot_bgcolor: '#f8f9fa'
            };

            Plotly.newPlot('cluster-plot-2d', [trace2d], layout2d, {responsive: true});

            document.getElementById('cluster-plot-2d').on('plotly_click', function(data) {
                if (data.points.length > 0) {
                    const nodeId = data.points[0].customdata;
                    if (nodeId) {
                        selectNodeById(nodeId, false);
                    }
                }
            });

            // 3D Plot
            const trace3d = {
                x: programsWithEmbeddings.map(p => p.embedding_pca_3d[0]),
                y: programsWithEmbeddings.map(p => p.embedding_pca_3d[1]),
                z: programsWithEmbeddings.map(p => p.embedding_pca_3d[2]),
                customdata: programsWithEmbeddings.map(p => p.id),
                mode: 'markers',
                type: 'scatter3d',
                text: programsWithEmbeddings.map(p => `<b>${p.metadata.patch_name || 'unnamed'}</b><br>Score: ${formatScore(p.combined_score)}<br>Cluster: ${p.embedding_cluster_id}`),
                hoverinfo: 'text',
                marker: {
                    color: programsWithEmbeddings.map(p => p.embedding_cluster_id),
                    colorscale: 'Portland',
                    showscale: true,
                    size: sizes,
                    symbol: symbols3d,
                    line: {
                        color: borderColors,
                        width: borderWidths
                    },
                    colorbar: {
                        title: 'C-ID',
                        tickvals: uniqueClusterIds,
                        ticktext: uniqueClusterIds,
                        len: 0.4,
                        y: 0.5,
                        yanchor: 'middle'
                    }
                }
            };

            const layout3d = {
                title: '3D PCA of Program Embeddings',
                scene: {
                    xaxis: { title: 'PC1' },
                    yaxis: { title: 'PC2' },
                    zaxis: { title: 'PC3' },
                    camera: { eye: {x: 2., y: 2., z: 2.} }
                },
                margin: { t: 40, b: 0, l: 10, r: 0 },
                paper_bgcolor: '#f8f9fa'
            };

            Plotly.newPlot('cluster-plot-3d', [trace3d], layout3d, {responsive: true});

            document.getElementById('cluster-plot-3d').on('plotly_click', function(data) {
                if (data.points.length > 0) {
                    const nodeId = data.points[0].customdata;
                    if (nodeId) {
                        selectNodeById(nodeId, false);
                    }
                }
            });

            const legendContainer = document.getElementById('size-legend-container');
            legendContainer.innerHTML = ''; // Clear previous

            if (maxScore > minScore) {
                const legendTitle = document.createElement('h5');
                legendTitle.style.margin = '0 0 5px 0';
                legendTitle.style.fontSize = '11px';
                legendTitle.textContent = 'Score (size)';
                legendContainer.appendChild(legendTitle);

                const legendItems = document.createElement('div');
                legendItems.style.display = 'flex';
                legendItems.style.justifyContent = 'center';
                legendItems.style.alignItems = 'flex-end';
                legendItems.style.gap = '15px';

                const midScore = (minScore + maxScore) / 2;
                const legendScores = [minScore, midScore, maxScore];
                
                legendScores.forEach(score => {
                    const item = document.createElement('div');
                    item.style.textAlign = 'center';
                    item.style.display = 'flex';
                    item.style.flexDirection = 'column';
                    item.style.alignItems = 'center';

                    const circle = document.createElement('div');
                    const diameter = sizeScale(score);
                    circle.style.width = `${diameter}px`;
                    circle.style.height = `${diameter}px`;
                    circle.style.backgroundColor = '#888';
                    circle.style.borderRadius = '50%';
                    
                    const label = document.createElement('span');
                    label.style.fontSize = '10px';
                    label.style.marginTop = '4px';
                    label.textContent = score.toFixed(2);

                    item.appendChild(circle);
                    item.appendChild(label);
                    legendItems.appendChild(item);
                });

                legendContainer.appendChild(legendItems);
            }
        }

        function setupTableSorting() {
            const headers = document.querySelectorAll('#program-table th.sortable');
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const sortKey = header.dataset.sort;
                    if (sortState.key === sortKey) {
                        sortState.dir = sortState.dir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortState.key = sortKey;
                        sortState.dir = (sortKey === 'rank' || sortKey === 'generation') ? 'asc' : 'desc';
                    }
                    if (window.treeData) {
                        populateProgramsTable(window.treeData);
                    }
                });
            });
        }

        // --- Pareto Front Visualization ---

        function getNestedValue(obj, path) {
            if (!path) return undefined;
            const parts = path.split('.');
            let current = obj;
            for (const part of parts) {
                if (current === null || typeof current === 'undefined') return undefined;
                current = current[part];
            }
            return current;
        }

        function getAvailableParetoMetrics(data) {
            if (!data || data.length === 0) return [];
            const metricsMap = new Map();

            const addMetric = (programObj, path) => {
                const value = getNestedValue(programObj, path);
                if (typeof value === 'number' && !metricsMap.has(path)) {
                    let name = path.split('.').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');
                    name = name.replace(/_/g, ' ');
                    if (path.startsWith('public_metrics')) name = `Public: ${path.split('.')[1]}`;
                    if (path.startsWith('private_metrics')) name = `Private: ${path.split('.')[1]}`;
                    
                    let objective = 'max';
                    const key = path.split('.').pop();
                    if (key.includes('cost') || key.includes('time') || key.includes('complexity') || key.includes('latency')) {
                        objective = 'min';
                    }
                    metricsMap.set(path, { name, path, objective });
                }
            };

            const discoverInObject = (programObj, subObj, prefix) => {
                if (!subObj) return;
                for (const key in subObj) {
                    if (typeof subObj[key] === 'number') {
                        addMetric(programObj, `${prefix}.${key}`);
                    }
                }
            };

            data.forEach(p => {
                addMetric(p, 'combined_score');
                addMetric(p, 'complexity');
                if (p.metadata) addMetric(p, 'metadata.compute_time');
                discoverInObject(p, p.public_metrics, 'public_metrics');
                discoverInObject(p, p.private_metrics, 'private_metrics');
            });
            return Array.from(metricsMap.values());
        }

        function calculateParetoFront(data, xMetric, yMetric) {
            const allPoints = data.map(p => {
                const x = getNestedValue(p, xMetric.path);
                const y = getNestedValue(p, yMetric.path);
                if (typeof x === 'number' && typeof y === 'number') {
                    return { x, y, point: p };
                }
                return null;
            }).filter(p => p !== null);

            const correctPoints = allPoints.filter(p => p.point.correct);

            const paretoPoints = correctPoints.filter(p1 => {
                return !correctPoints.some(p2 => { // Only check against other correct points
                    if (p1 === p2) return false;
                    const x_p2_better = xMetric.objective === 'min' ? p2.x < p1.x : p2.x > p1.x;
                    const y_p2_better = yMetric.objective === 'min' ? p2.y < p1.y : p2.y > p1.y;
                    const x_equal = p2.x === p1.x;
                    const y_equal = p2.y === p1.y;

                    if ((x_p2_better && (y_p2_better || y_equal)) || (y_p2_better && (x_p2_better || x_equal))) {
                        return true; // p2 dominates p1
                    }
                    return false;
                });
            });

            return { allPoints, paretoPoints };
        }

        // Helper function to build hover text showing only the active X and Y axis metrics
        function buildActiveMetricsHoverText(point, xMetric, yMetric) {
            let hoverText = `<b>${point.metadata.patch_name || 'unnamed'}</b><br>`;
            hoverText += `Combined Score: ${formatScore(point.combined_score)}<br>`;
            
            // Show X-axis metric
            const xValue = getNestedValue(point, xMetric.path);
            if (xValue !== undefined) {
                hoverText += `${xMetric.name}: ${formatScore(xValue)}<br>`;
            }
            
            // Show Y-axis metric
            const yValue = getNestedValue(point, yMetric.path);
            if (yValue !== undefined) {
                hoverText += `${yMetric.name}: ${formatScore(yValue)}<br>`;
            }
            
            return hoverText;
        }

        function createParetoPlot(plotData, xMetric, yMetric) {
            const { allPoints, paretoPoints } = plotData;

            const incorrectPoints = allPoints.filter(p => !p.point.correct);
            const correctDominatedPoints = allPoints.filter(p => p.point.correct && !paretoPoints.includes(p));

            const traceDominated = {
                x: correctDominatedPoints.map(p => p.x),
                y: correctDominatedPoints.map(p => p.y),
                mode: 'markers',
                type: 'scatter',
                name: 'Dominated',
                text: correctDominatedPoints.map(p => buildActiveMetricsHoverText(p.point, xMetric, yMetric)),
                hoverinfo: 'text',
                marker: { color: 'rgba(150, 150, 150, 0.5)', size: 8 },
                customdata: correctDominatedPoints.map(p => p.point.id)
            };

            const traceIncorrect = {
                x: incorrectPoints.map(p => p.x),
                y: incorrectPoints.map(p => p.y),
                mode: 'markers',
                type: 'scatter',
                name: 'Incorrect',
                text: incorrectPoints.map(p => buildActiveMetricsHoverText(p.point, xMetric, yMetric)),
                hoverinfo: 'text',
                marker: { color: '#e74c3c', size: 8, symbol: 'x' },
                customdata: incorrectPoints.map(p => p.point.id)
            };
            
            const tracePareto = {
                x: paretoPoints.map(p => p.x),
                y: paretoPoints.map(p => p.y),
                mode: 'markers',
                type: 'scatter',
                name: 'Pareto Optimal',
                text: paretoPoints.map(p => buildActiveMetricsHoverText(p.point, xMetric, yMetric)),
                hoverinfo: 'text',
                marker: { color: '#e58e26', size: 12, symbol: 'diamond' },
                customdata: paretoPoints.map(p => p.point.id)
            };

            const sortedPareto = [...paretoPoints].sort((a,b) => a.x - b.x);

            // Calculate bounds based only on correct programs (for both fill area and axis ranges)
            const correctPointsForBounds = [...paretoPoints, ...correctDominatedPoints];
            const correctX = correctPointsForBounds.map(p => p.x);
            const correctY = correctPointsForBounds.map(p => p.y);
            const xRange = Math.max(...correctX) - Math.min(...correctX);
            const yRange = Math.max(...correctY) - Math.min(...correctY);

            const hullTrace = {
                x: sortedPareto.map(p => p.x),
                y: sortedPareto.map(p => p.y),
                mode: 'lines',
                type: 'scatter',
                name: 'Pareto Boundary',
                line: {
                    color: '#e58e26',
                    width: 2,
                    shape: 'linear'
                },
                marker: {
                    size: 0  // Ensure no markers are shown for the line
                },
                hoverinfo: 'none',
                showlegend: false  // Hide from legend since we already have Pareto Optimal points
            };

            let fillTrace = null;
            if (sortedPareto.length > 0) {
                const boundaryX = [];
                const boundaryY = [];

                if (xMetric.objective === 'min') { // Reversed x-axis means points are sorted descending visually
                    sortedPareto.forEach((p, i) => {
                        if (i > 0) {
                            const prevP = sortedPareto[i-1];
                            boundaryX.push(prevP.x);
                            boundaryY.push(p.y);
                        }
                        boundaryX.push(p.x);
                        boundaryY.push(p.y);
                    });
                } else { // Normal x-axis
                    sortedPareto.forEach((p, i) => {
                        if (i > 0) {
                            const prevP = sortedPareto[i-1];
                            boundaryX.push(p.x);
                            boundaryY.push(prevP.y);
                        }
                        boundaryX.push(p.x);
                        boundaryY.push(p.y);
                    });
                }
                
                // Determine the dominated region boundary based on both axis objectives
                // The dominated region is always "worse" than the Pareto front
                let edgeY, edgeX;
                
                if (yMetric.objective === 'max') {
                    // Y-axis: higher is better, so dominated region is below
                    edgeY = Math.min(...correctY) - 0.05 * yRange;
                } else {
                    // Y-axis: lower is better, so dominated region is above
                    edgeY = Math.max(...correctY) + 0.05 * yRange;
                }
                
                if (xMetric.objective === 'max') {
                    // X-axis: higher is better, so dominated region is to the left
                    edgeX = Math.min(...correctX) - 0.05 * xRange;
                } else {
                    // X-axis: lower is better, so dominated region is to the right
                    edgeX = Math.max(...correctX) + 0.05 * xRange;
                }
                
                // Create fill area below the Pareto line (connecting Pareto points directly)
                const x_fill = [];
                const y_fill = [];
                
                // Use the sorted Pareto points directly (not the step-wise boundary)
                const paretoX = sortedPareto.map(p => p.x);
                const paretoY = sortedPareto.map(p => p.y);
                
                // Determine which direction extends into the dominated region
                const extendRight = xMetric.objective === 'min';  // min x means worse is to the right
                const extendUp = yMetric.objective === 'min';     // min y means worse is above
                
                if (extendRight && !extendUp) {
                    // Dominated region is bottom-right (higher x, lower y)
                    // Start from left edge at the y-level of the first Pareto point
                    x_fill.push(Math.min(...correctX) );
                    y_fill.push(paretoY[0]);
                    
                    // Follow the Pareto points (straight line connections)
                    for (let i = 0; i < paretoX.length; i++) {
                        x_fill.push(paretoX[i]);
                        y_fill.push(paretoY[i]);
                    }
                    
                    // Extend to the bottom-right corner
                    x_fill.push(Math.max(...correctX));
                    y_fill.push(paretoY[paretoY.length - 1]);
                    
                    // Go to bottom edge
                    x_fill.push(Math.max(...correctX));
                    y_fill.push(Math.min(...correctY));
                    
                    // Go to left edge at bottom
                    x_fill.push(Math.min(...correctX));
                    y_fill.push(Math.min(...correctY));
                    
                } else if (!extendRight && !extendUp) {
                    // Dominated region is bottom-left (lower x, lower y)
                    // Start from right edge at the y-level of the last Pareto point
                    x_fill.push(Math.max(...correctX) + 0.05 * xRange);
                    y_fill.push(paretoY[paretoY.length - 1]);
                    
                    // Follow the Pareto points in reverse (straight line connections)
                    for (let i = paretoX.length - 1; i >= 0; i--) {
                        x_fill.push(paretoX[i]);
                        y_fill.push(paretoY[i]);
                    }
                    
                    // Extend to the bottom-left corner
                    x_fill.push(Math.min(...correctX) - 0.05 * xRange);
                    y_fill.push(paretoY[0]);
                    
                    // Go to bottom edge
                    x_fill.push(Math.min(...correctX) - 0.05 * xRange);
                    y_fill.push(Math.min(...correctY) - 0.05 * yRange);
                    
                    // Go to right edge at bottom
                    x_fill.push(Math.max(...correctX) + 0.05 * xRange);
                    y_fill.push(Math.min(...correctY) - 0.05 * yRange);
                    
                } else if (extendRight && extendUp) {
                    // Dominated region is top-right (higher x, higher y)
                    // Start from left edge at the y-level of the first Pareto point
                    x_fill.push(Math.min(...correctX) - 0.05 * xRange);
                    y_fill.push(paretoY[0]);
                    
                    // Follow the Pareto points (straight line connections)
                    for (let i = 0; i < paretoX.length; i++) {
                        x_fill.push(paretoX[i]);
                        y_fill.push(paretoY[i]);
                    }
                    
                    // Extend to the top-right corner
                    x_fill.push(Math.max(...correctX) + 0.05 * xRange);
                    y_fill.push(paretoY[paretoY.length - 1]);
                    
                    // Go to top edge
                    x_fill.push(Math.max(...correctX) + 0.05 * xRange);
                    y_fill.push(Math.max(...correctY) + 0.05 * yRange);
                    
                    // Go to left edge at top
                    x_fill.push(Math.min(...correctX) - 0.05 * xRange);
                    y_fill.push(Math.max(...correctY) + 0.05 * yRange);
                    
                } else {
                    // Dominated region is top-left (lower x, higher y)
                    // Start from right edge at the y-level of the last Pareto point
                    x_fill.push(Math.max(...correctX) + 0.05 * xRange);
                    y_fill.push(paretoY[paretoY.length - 1]);
                    
                    // Follow the Pareto points in reverse (straight line connections)
                    for (let i = paretoX.length - 1; i >= 0; i--) {
                        x_fill.push(paretoX[i]);
                        y_fill.push(paretoY[i]);
                    }
                    
                    // Extend to the top-left corner
                    x_fill.push(Math.min(...correctX) - 0.05 * xRange);
                    y_fill.push(paretoY[0]);
                    
                    // Go to top edge
                    x_fill.push(Math.min(...correctX) - 0.05 * xRange);
                    y_fill.push(Math.max(...correctY) + 0.05 * yRange);
                    
                    // Go to right edge at top
                    x_fill.push(Math.max(...correctX) + 0.05 * xRange);
                    y_fill.push(Math.max(...correctY) + 0.05 * yRange);
                }

                fillTrace = {
                    x: x_fill,
                    y: y_fill,
                    fill: 'toself',
                    fillcolor: 'rgba(231, 76, 60, 0.15)',
                    line: { width: 0 },
                    mode: 'none',
                    type: 'scatter',
                    hoverinfo: 'none',
                    showlegend: false,
                    name: 'Dominated Region'
                };
            }

            const plotTraces = [];
            if (fillTrace) {
                plotTraces.push(fillTrace);
            }
            plotTraces.push(traceDominated, traceIncorrect, tracePareto, hullTrace);

            // Calculate axis ranges based on correct programs (variables already calculated above)
            const xPadding = xRange * 0.1; // 10% padding
            const yPadding = yRange * 0.1; // 10% padding
            
            const layout = {
                title: 'Pareto Front of ShinkaEvolve Programs',
                xaxis: { 
                    title: `${xMetric.name} (${xMetric.objective === 'min' ? 'Lower' : 'Higher'} is better ‚Üí)`,
                    range: [Math.min(...correctX) - xPadding, Math.max(...correctX) + xPadding],
                    autorange: false
                },
                yaxis: { 
                    title: `${yMetric.name} (${yMetric.objective === 'min' ? 'Lower' : 'Higher'} is better ‚Üë)`,
                    range: [Math.min(...correctY) - yPadding, Math.max(...correctY) + yPadding],
                    autorange: false
                },
                hovermode: 'closest',
                showlegend: true
            };
            
            // Apply axis direction after setting ranges
            if (xMetric.objective === 'min') {
                layout.xaxis.autorange = 'reversed';
                delete layout.xaxis.range;
            }
            if (yMetric.objective === 'min') {
                layout.yaxis.autorange = 'reversed';
                delete layout.yaxis.range;
            }

            Plotly.newPlot('pareto-plot', plotTraces, layout, {responsive: true});

            document.getElementById('pareto-plot').on('plotly_click', function(data) {
                if (data.points.length > 0) {
                    selectNodeById(data.points[0].customdata);
                }
            });
        }
        
        let availableParetoMetrics = [];
        let paretoListenersAdded = false;
        function updateParetoView() {
            if (!window.treeData) return;

            if (!paretoListenersAdded) {
                availableParetoMetrics = getAvailableParetoMetrics(window.treeData);
                const ySelect = document.getElementById('pareto-y-axis');
                const xSelect = document.getElementById('pareto-x-axis');
                
                availableParetoMetrics.forEach(metric => {
                    const option = document.createElement('option');
                    option.value = metric.path;
                    option.textContent = metric.name;
                    ySelect.appendChild(option.cloneNode(true));
                    xSelect.appendChild(option.cloneNode(true));
                });

                // Set defaults
                ySelect.value = 'combined_score';
                const computeTimeMetric = availableParetoMetrics.find(m => m.path === 'metadata.compute_time');
                if (computeTimeMetric) {
                    xSelect.value = 'metadata.compute_time';
                } else {
                    const complexityMetric = availableParetoMetrics.find(m => m.path === 'complexity');
                    if (complexityMetric) xSelect.value = 'complexity';
                }

                const updateObjectiveSelect = (axisSelectId) => {
                    const objectiveSelectId = axisSelectId.replace('-axis', '-objective');
                    const objectiveSelect = document.getElementById(objectiveSelectId);
                    const axisSelect = document.getElementById(axisSelectId);
                    const metric = availableParetoMetrics.find(m => m.path === axisSelect.value);
                    if (metric) {
                        objectiveSelect.value = metric.objective;
                    }
                };

                updateObjectiveSelect('pareto-y-axis');
                updateObjectiveSelect('pareto-x-axis');

                document.querySelectorAll('.pareto-axis-select').forEach(sel => sel.addEventListener('change', () => {
                    updateObjectiveSelect(sel.id);
                    updateParetoView();
                }));
                document.querySelectorAll('.pareto-objective-select').forEach(sel => sel.addEventListener('change', updateParetoView));
                paretoListenersAdded = true;
            }
            
            const yPath = document.getElementById('pareto-y-axis').value;
            const xPath = document.getElementById('pareto-x-axis').value;
            const yObjective = document.getElementById('pareto-y-objective').value;
            const xObjective = document.getElementById('pareto-x-objective').value;

            const yMetric = { ...availableParetoMetrics.find(m => m.path === yPath), objective: yObjective };
            const xMetric = { ...availableParetoMetrics.find(m => m.path === xPath), objective: xObjective };

            if (!yMetric || !xMetric) return;

            const paretoData = calculateParetoFront(window.treeData, xMetric, yMetric);
            createParetoPlot(paretoData, xMetric, yMetric);
        }
        function createMetricsVisualization(data) {
            console.log("[DEBUG] Creating metrics visualization with", data ? data.length : 0, "data points");
            
            const metricsContainer = document.getElementById('metrics-plots');
            if (!metricsContainer) {
                console.log("[DEBUG] Metrics plots container not found");
                return;
            }
            
            metricsContainer.innerHTML = ''; // Clear previous plots
            console.log("[DEBUG] Cleared metrics container");

            // Filter data to only include correct programs with scores
            const validData = data.filter(d => d.correct && d.combined_score !== null && !isNaN(d.combined_score));
            
            if (validData.length === 0) {
                metricsContainer.innerHTML = '<p>No valid programs with metrics found.</p>';
                return;
            }

            // Group data by generation
            const generationData = {};
            validData.forEach(d => {
                const gen = d.generation || 0;  // generation is a top-level field, not in metadata
                if (!generationData[gen]) {
                    generationData[gen] = [];
                }
                generationData[gen].push(d);
            });

            const generations = Object.keys(generationData).map(Number).sort((a, b) => a - b);

            // Helper function to get nested value from object
            const getNestedValue = (obj, path) => {
                if (!path) return undefined;
                const parts = path.split('.');
                let current = obj;
                for (const part of parts) {
                    if (current === null || typeof current === 'undefined') return undefined;
                    current = current[part];
                }
                return current;
            };

            // Collect all available metrics
            const allMetrics = new Set();
            allMetrics.add('combined_score');
            
            validData.forEach(d => {
                if (d.public_metrics) {
                    Object.keys(d.public_metrics).forEach(key => {
                        if (typeof d.public_metrics[key] === 'number') {
                            allMetrics.add(`public_metrics.${key}`);
                        }
                    });
                }
                if (d.private_metrics) {
                    Object.keys(d.private_metrics).forEach(key => {
                        if (typeof d.private_metrics[key] === 'number') {
                            allMetrics.add(`private_metrics.${key}`);
                        }
                    });
                }
            });

            // Create plots in rows of 2
            const metricsArray = Array.from(allMetrics);
            for (let i = 0; i < metricsArray.length; i += 2) {
                // Create a row container
                const rowContainer = document.createElement('div');
                rowContainer.style.display = 'flex';
                rowContainer.style.gap = '15px';
                rowContainer.style.marginBottom = '20px';
                rowContainer.style.width = '100%';
                rowContainer.style.overflowX = 'auto';
                metricsContainer.appendChild(rowContainer);

                // Create up to 2 plots in this row
                const rowMetrics = metricsArray.slice(i, i + 2);
                rowMetrics.forEach((metricPath, rowIndex) => {
                    const plotIndex = i + rowIndex;
                        
                        // Create wrapper container for plot + controls
                        const wrapperContainer = document.createElement('div');
                        wrapperContainer.style.width = '50%';
                        wrapperContainer.style.minWidth = '400px';
                        wrapperContainer.style.boxSizing = 'border-box';
                        wrapperContainer.style.display = 'flex';
                        wrapperContainer.style.flexDirection = 'column';
                        rowContainer.appendChild(wrapperContainer);

                        // Create controls container
                        const controlsContainer = document.createElement('div');
                        controlsContainer.style.display = 'flex';
                        controlsContainer.style.justifyContent = 'center';
                        controlsContainer.style.gap = '10px';
                        controlsContainer.style.marginBottom = '10px';
                        controlsContainer.style.padding = '5px';
                        wrapperContainer.appendChild(controlsContainer);

                        // Create toggle button
                        const toggleButton = document.createElement('button');
                        toggleButton.id = `toggle-btn-${plotIndex}`;
                        toggleButton.textContent = 'Switch to Cumulative Max';
                        toggleButton.style.padding = '5px 10px';
                        toggleButton.style.fontSize = '12px';
                        toggleButton.style.border = '1px solid #ddd';
                        toggleButton.style.borderRadius = '4px';
                        toggleButton.style.backgroundColor = '#f8f9fa';
                        toggleButton.style.cursor = 'pointer';
                        controlsContainer.appendChild(toggleButton);

                        // Create plot container
                    const plotContainer = document.createElement('div');
                    plotContainer.id = `metric-plot-${plotIndex}`;
                        plotContainer.style.height = '280px';
                        plotContainer.style.width = '100%';
                    plotContainer.style.boxSizing = 'border-box';
                        wrapperContainer.appendChild(plotContainer);

                    // Prepare individual data points for this metric
                    const individualPoints = [];
                    generations.forEach(gen => {
                        const programs = generationData[gen];
                        programs.forEach(p => {
                            const value = getNestedValue(p, metricPath);
                            if (value !== undefined && !isNaN(value)) {
                                individualPoints.push({
                                    x: gen,
                                    y: value,
                                    id: p.id,
                                    name: p.metadata?.patch_name || 'unnamed'
                                });
                            }
                        });
                    });

                    if (individualPoints.length === 0) {
                        plotContainer.innerHTML = `<p>No data available for metric: ${metricPath}</p>`;
                        return;
                    }

                    // Create scatter trace with individual points
                    const scatterTrace = {
                        x: individualPoints.map(d => d.x),
                        y: individualPoints.map(d => d.y),
                        mode: 'markers',
                        type: 'scatter',
                        name: 'Programs',
                        marker: { 
                            color: '#3498db', 
                            size: 8,
                            opacity: 0.7,
                            line: {
                                color: '#2980b9',
                                width: 1
                            }
                        },
                        customdata: individualPoints.map(d => ({ id: d.id, name: d.name })),
                        text: individualPoints.map(d => `${d.name}<br>Gen: ${d.x}<br>Value: ${d.y.toFixed(4)}`),
                        hoverinfo: 'text'
                    };

                    // Calculate generation-wise statistics for trend line
                    const genStats = generations.map(gen => {
                        const genPoints = individualPoints.filter(p => p.x === gen);
                        if (genPoints.length === 0) return null;
                        const values = genPoints.map(p => p.y);
                        const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
                        const max = Math.max(...values);
                        const min = Math.min(...values);
                        return { x: gen, mean, max, min };
                    }).filter(d => d !== null);

                    // Calculate cumulative max and min
                    let cumulativeMax = -Infinity;
                    let cumulativeMin = Infinity;
                    const cumulativeStats = genStats.map(stat => {
                        cumulativeMax = Math.max(cumulativeMax, stat.max);
                        cumulativeMin = Math.min(cumulativeMin, stat.min);
                        return {
                            x: stat.x,
                            cumulativeMax,
                            cumulativeMin,
                            max: stat.max,
                            min: stat.min
                        };
                    });

                    // Add trend line for best performance (default: raw max)
                    const trendTrace = {
                        x: genStats.map(d => d.x),
                        y: genStats.map(d => d.max),
                        mode: 'lines+markers',
                        type: 'scatter',
                        name: 'Best',
                        line: { color: '#e74c3c', width: 3 },
                        marker: { size: 6 },
                        hoverinfo: 'skip'
                    };

                    // Add cumulative min trace (default view)
                    const cumulativeTrace = {
                        x: cumulativeStats.map(d => d.x),
                        y: cumulativeStats.map(d => d.cumulativeMin),
                        mode: 'lines+markers',
                        type: 'scatter',
                        name: 'Cumulative Min',
                        line: { color: '#27ae60', width: 2, dash: 'dot' },
                        marker: { size: 4 },
                        hoverinfo: 'skip'
                    };

                    // Determine metric name for display
                    let metricDisplayName = metricPath;
                    if (metricPath === 'combined_score') {
                        metricDisplayName = 'Combined Score';
                    } else if (metricPath.startsWith('public_metrics.')) {
                        metricDisplayName = metricPath.split('.')[1];
                    } else if (metricPath.startsWith('private_metrics.')) {
                        metricDisplayName = metricPath.split('.')[1];
                    }

                    const layout = {
                        title: {
                            text: metricDisplayName,
                            font: { size: 14 }
                        },
                        xaxis: { 
                            title: 'Generation',
                            type: 'linear'
                        },
                        yaxis: { title: 'Value' },
                        margin: { t: 40, b: 50, l: 70, r: 20 },
                        showlegend: true,
                        legend: { 
                            x: 0.02, 
                            y: 0.98, 
                            bgcolor: 'rgba(255,255,255,0.8)',
                            font: { size: 8 }
                        },
                        paper_bgcolor: '#f8f9fa',
                        plot_bgcolor: '#ffffff'
                    };

                    // Initial traces (raw scores + cumulative min)
                    let currentTraces = [scatterTrace, trendTrace, cumulativeTrace];
                    Plotly.newPlot(plotContainer.id, currentTraces, layout, { responsive: true });

                    // Store data for toggle functionality
                    plotContainer.cumulativeStats = cumulativeStats;
                    plotContainer.currentMode = 'min'; // 'min' or 'max'

                    // Add toggle button functionality
                    toggleButton.addEventListener('click', function() {
                        const isMin = plotContainer.currentMode === 'min';
                        const newMode = isMin ? 'max' : 'min';
                        
                        // Update cumulative trace
                        const newCumulativeTrace = {
                            x: cumulativeStats.map(d => d.x),
                            y: cumulativeStats.map(d => isMin ? d.cumulativeMax : d.cumulativeMin),
                            mode: 'lines+markers',
                            type: 'scatter',
                            name: isMin ? 'Cumulative Max' : 'Cumulative Min',
                            line: { color: isMin ? '#9b59b6' : '#27ae60', width: 2, dash: 'dot' },
                            marker: { size: 4 },
                            hoverinfo: 'skip'
                        };

                        // Update the plot
                        const newTraces = [scatterTrace, trendTrace, newCumulativeTrace];
                        Plotly.react(plotContainer.id, newTraces, layout);
                        
                        // Update button text and mode
                        toggleButton.textContent = isMin ? 'Switch to Cumulative Min' : 'Switch to Cumulative Max';
                        plotContainer.currentMode = newMode;
                    });

                    // Add click event listener
                    document.getElementById(plotContainer.id).on('plotly_click', function(data) {
                        if (data.points.length > 0 && data.points[0].customdata) {
                            const nodeId = data.points[0].customdata.id;
                            if (nodeId) {
                                // Select the node and switch to code view
                                selectNodeById(nodeId, false);
                                // Switch to the Node Code tab
                                const codeTab = document.querySelector('.tab[data-tab="agent-code"]');
                                if (codeTab) {
                                    codeTab.click();
                                }
                            }
                        }
                    });
                });
            }
        }




        // Function to download top performing programs as ZIP
        function downloadTopPrograms() {
            if (!window.treeData || window.treeData.length === 0) {
                alert('No data available. Please load a database first.');
                return;
            }

            // Ask user how many programs to download
            const count = prompt('How many top performing programs would you like to download?\n\nEnter any number (1-100):', '5');
            
            if (count === null) return; // User cancelled
            
            const numPrograms = parseInt(count);
            if (isNaN(numPrograms) || numPrograms < 1 || numPrograms > 100) {
                alert('Please enter a valid number between 1 and 100.');
                return;
            }

            // Get top performing programs
            const correctPrograms = window.treeData
                .filter(d => d.correct && d.combined_score !== null && d.code)
                .sort((a, b) => b.combined_score - a.combined_score)
                .slice(0, numPrograms);

            if (correctPrograms.length === 0) {
                alert('No correct programs with code found.');
                return;
            }

            const actualCount = Math.min(numPrograms, correctPrograms.length);
            
            // Create ZIP file
            const zip = new JSZip();
            
            // Add a summary file
            let summary = `Top ${actualCount} Performing Programs\n`;
            summary += `Generated on: ${new Date().toISOString()}\n`;
            summary += `Database: ${window.currentDbPath || 'Unknown'}\n\n`;
            summary += `Rank\tGeneration\tScore\tName\tType\tLanguage\tAPI_Cost\tComplexity\tModel\tID\tParent_ID\tDescription\tFilename\n`;
            
            correctPrograms.forEach((program, index) => {
                const rank = index + 1;
                const gen = program.generation;
                const score = program.combined_score.toFixed(6);
                const name = program.metadata.patch_name || 'unnamed';
                const language = program.language || 'py';
                const extension = {
                    'python': 'py',
                    'cpp': 'cpp',
                    'javascript': 'js',
                    'cuda': 'cu'
                }[language] || language;
                
                // Determine comment style based on language
                const commentStyle = {
                    'python': '#',
                    'py': '#',
                    'cpp': '//',
                    'c++': '//',
                    'javascript': '//',
                    'js': '//',
                    'cuda': '//',
                    'cu': '//'
                }[language.toLowerCase()] || '//';
                
                const filename = `${rank}_gen${gen}_${name.replace(/[^a-zA-Z0-9_-]/g, '_')}.${extension}`;
                
                // Collect additional metadata
                const patchType = program.metadata.patch_type || 'N/A';
                const apiCost = program.metadata.api_costs ? `$${parseFloat(program.metadata.api_costs).toFixed(4)}` : 'N/A';
                const complexity = program.complexity ? program.complexity.toFixed(3) : 'N/A';
                const model = program.metadata.model_name || 'N/A';
                const programId = program.id.substring(0, 12) + '...'; // Truncate for readability
                const parentId = program.parent_id ? program.parent_id.substring(0, 12) + '...' : 'N/A';
                const description = program.metadata.patch_description ? 
                    program.metadata.patch_description.replace(/[\t\n\r]/g, ' ').substring(0, 100) + 
                    (program.metadata.patch_description.length > 100 ? '...' : '') : 'N/A';
                
                // Add to summary with all metadata
                summary += `${rank}\t${gen}\t${score}\t${name}\t${patchType}\t${language}\t${apiCost}\t${complexity}\t${model}\t${programId}\t${parentId}\t${description}\t${filename}\n`;
                
                // Create program file content with appropriate comment style
                let content = `${commentStyle} Rank: ${rank}\n`;
                content += `${commentStyle} Generation: ${gen}\n`;
                content += `${commentStyle} Score: ${score}\n`;
                content += `${commentStyle} Name: ${name}\n`;
                content += `${commentStyle} ID: ${program.id}\n`;
                if (program.parent_id) {
                    content += `${commentStyle} Parent ID: ${program.parent_id}\n`;
                }
                content += `${commentStyle} Type: ${program.metadata.patch_type || 'N/A'}\n`;
                if (program.metadata.patch_description) {
                    // Split description by line breaks and comment each line properly
                    const descriptionLines = program.metadata.patch_description.split(/\r?\n/);
                    content += `${commentStyle} Description: ${descriptionLines[0]}\n`;
                    // Add continuation lines with proper commenting
                    for (let i = 1; i < descriptionLines.length; i++) {
                        if (descriptionLines[i].trim()) { // Only add non-empty lines
                            content += `${commentStyle}              ${descriptionLines[i]}\n`;
                        }
                    }
                }
                content += `\n${program.code}`;
                
                // Add file to ZIP
                zip.file(filename, content);
            });
            
            // Add summary file
            zip.file('README.txt', summary);
            
            // Generate and download ZIP
            zip.generateAsync({type: 'blob'}).then(function(content) {
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `top_${actualCount}_programs.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }).catch(function(error) {
                console.error('Error creating ZIP file:', error);
                alert('Error creating ZIP file. Please try again.');
            });
        }



                        // Add event listener for download button
        document.addEventListener('DOMContentLoaded', function() {
            
            const downloadProgramsBtn = document.getElementById('download-programs-btn');
            if (downloadProgramsBtn) {
                downloadProgramsBtn.addEventListener('click', downloadTopPrograms);
            }
            

        });

    </script>
</body>
</html> 